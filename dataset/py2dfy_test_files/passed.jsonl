{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CheckNameAndTemp(name: string, temp: int) returns (result: string)\n  \n{\n  if name != \"?NAME\" || temp != 2 {\n    result := \"Fail\";\n  } else {\n    result := \"Success\";\n  }\n}\nmethod Main() {\n  \n  var output := CheckNameAndTemp(\"?NAME\", 1);\n  print output, \"\\n\";  \n}", "output": "method CheckNameAndTemp(name: string, temp: int) returns (result: string)\n  \n  ensures result == \"Fail\" <==> (name != \"?NAME\" || temp != 2)  \n  ensures result == \"Success\" <==> (name == \"?NAME\" && temp == 2)\n  ensures result == \"Fail\" || result == \"Success\"  \n{\n  if name != \"?NAME\" || temp != 2 {\n    result := \"Fail\";\n  } else {\n    result := \"Success\";\n  }\n}\nmethod Main() {\n  \n  var output := CheckNameAndTemp(\"?NAME\", 1);\n  print output, \"\\n\";  \n}", "name": "py2dfy_41", "id": 41}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module Incrementor {\n    \n    function Increment(n: int, x: int): int \n    {\n        x + n\n    }\n    \n    method MakeAndUseIncrementor(n: int, x: int) returns (result: int)\n    {\n        result := Increment(n, x);\n    }\n    \n    method TestIncrementors()\n    {\n        var result1 := MakeAndUseIncrementor(2, 10);\n        var result2 := MakeAndUseIncrementor(10, 10);\n        \n        \n        \n        print \"Result1: \", result1, \"\\n\";\n        print \"Result2: \", result2, \"\\n\";\n    }\n    \n    method Main() {\n        TestIncrementors();\n    }\n}", "output": "module Incrementor {\n    \n    function Increment(n: int, x: int): int \n        ensures Increment(n, x) == x + n  \n    {\n        x + n\n    }\n    \n    method MakeAndUseIncrementor(n: int, x: int) returns (result: int)\n        ensures result == x + n  \n    {\n        result := Increment(n, x);\n    }\n    \n    method TestIncrementors()\n    {\n        var result1 := MakeAndUseIncrementor(2, 10);\n        var result2 := MakeAndUseIncrementor(10, 10);\n        \n        \n        assert result1 == 12;\n        assert result2 == 20;\n        \n        print \"Result1: \", result1, \"\\n\";\n        print \"Result2: \", result2, \"\\n\";\n    }\n    \n    method Main() {\n        TestIncrementors();\n    }\n}", "name": "py2dfy_66", "id": 66}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype SQLType = Int | Float | String\ndatatype Token = \n  | Keyword(keywordValue: string)\n  | Identity(identityValue: string) \n  | Number(numberValue: real)\n  | StringLit(stringValue: string)\n  | SpecialChar(charValue: string)\nclass Column {\n  var name: string\n  var sqlType: SQLType\n  \n  constructor(n: string, t: SQLType)\n  {\n    name := n;\n    sqlType := t;\n  }\n}\nmethod UnquoteString(s: string, quoteChar: char) returns (result: string)\n{\n  var i := 1;\n  result := \"\";\n  \n  while i < |s|-1\n  {\n    if s[i] == '\\\\' && i+1 < |s|-1 && s[i+1] == quoteChar {\n      \n      i := i + 2;\n    } else {\n      if s[i] != quoteChar {  \n        result := result + [s[i]];\n      }\n      i := i + 1;\n    }\n  }\n}\nmethod ParseNumber(s: string) returns (result: real)\n{\n  \n  \n  result := 0.0;\n  var i := 0;\n  while i < |s|\n  {\n    if s[i] != '.' {\n      result := result * 10.0 + (var digit := s[i] as int - '0' as int; digit as real);\n    }\n    i := i + 1;\n  }\n}", "output": "datatype SQLType = Int | Float | String\ndatatype Token = \n  | Keyword(keywordValue: string)\n  | Identity(identityValue: string) \n  | Number(numberValue: real)\n  | StringLit(stringValue: string)\n  | SpecialChar(charValue: string)\nclass Column {\n  var name: string\n  var sqlType: SQLType\n  \n  constructor(n: string, t: SQLType)\n    ensures name == n && sqlType == t\n  {\n    name := n;\n    sqlType := t;\n  }\n}\nmethod UnquoteString(s: string, quoteChar: char) returns (result: string)\n  requires |s| >= 2 \n  requires s[0] == quoteChar && s[|s|-1] == quoteChar\n  ensures |result| <= |s| \n  ensures forall i :: 0 <= i < |result| ==> result[i] != quoteChar \n{\n  var i := 1;\n  result := \"\";\n  \n  while i < |s|-1\n    invariant 1 <= i <= |s|-1\n    invariant |result| <= i-1 \n    invariant forall k :: 0 <= k < |result| ==> result[k] != quoteChar\n    decreases |s| - i\n  {\n    if s[i] == '\\\\' && i+1 < |s|-1 && s[i+1] == quoteChar {\n      \n      i := i + 2;\n    } else {\n      if s[i] != quoteChar {  \n        result := result + [s[i]];\n      }\n      i := i + 1;\n    }\n  }\n}\nmethod ParseNumber(s: string) returns (result: real)\n  requires forall i :: 0 <= i < |s| ==> ('0' <= s[i] <= '9' || s[i] == '.')\n  ensures result >= 0.0\n{\n  \n  \n  result := 0.0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant result >= 0.0\n    decreases |s| - i\n  {\n    if s[i] != '.' {\n      result := result * 10.0 + (var digit := s[i] as int - '0' as int; digit as real);\n    }\n    i := i + 1;\n  }\n}", "name": "py2dfy_68", "id": 68}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait UIControl {\n  \n  var eventHandlers: seq<UIControl>\n  \n  method NotifyEventHandlers()\n}\nclass ListBox extends UIControl {\n  \n  var selection: string\n  constructor()\n  {\n    selection := \"\";\n    eventHandlers := [];\n  }\n  \n  method GetSelection() returns (result: string)\n  {\n    return selection;\n  }\n  \n  method SetSelection(newSelection: string)\n  {\n    selection := newSelection;\n    NotifyEventHandlers();\n    \n  }\n  \n  method NotifyEventHandlers()\n  {\n    \n  }\n}", "output": "trait UIControl {\n  \n  var eventHandlers: seq<UIControl>\n  \n  method NotifyEventHandlers()\n    modifies this, eventHandlers\n    ensures |eventHandlers| == old(|eventHandlers|)  \n}\nclass ListBox extends UIControl {\n  \n  var selection: string\n  constructor()\n    ensures selection == \"\"  \n    ensures eventHandlers == []  \n  {\n    selection := \"\";\n    eventHandlers := [];\n  }\n  \n  method GetSelection() returns (result: string)\n    ensures result == selection  \n    ensures selection == old(selection)  \n  {\n    return selection;\n  }\n  \n  method SetSelection(newSelection: string)\n    modifies this, eventHandlers\n    ensures selection == newSelection  \n    ensures |eventHandlers| == old(|eventHandlers|)  \n  {\n    selection := newSelection;\n    NotifyEventHandlers();\n    \n    assert selection == newSelection;\n  }\n  \n  method NotifyEventHandlers()\n    modifies this, eventHandlers\n    ensures |eventHandlers| == old(|eventHandlers|)\n    ensures selection == old(selection) \n  {\n    \n  }\n}", "name": "py2dfy_37", "id": 37}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Submission {\n  var review_score: real\n  var total_score: real\n}\nmethod AlterSubmissionFields(s: Submission, new_review_score: real, new_total_score: real)\n{\n  s.review_score := new_review_score;\n  s.total_score := new_total_score;\n}\nmethod Main()\n{\n  var submission := new Submission;\n  submission.review_score := 0.0;\n  submission.total_score := 0.0;\n  AlterSubmissionFields(submission, 85.50, 92.75);\n}", "output": "class Submission {\n  var review_score: real\n  var total_score: real\n}\nmethod AlterSubmissionFields(s: Submission, new_review_score: real, new_total_score: real)\n  modifies s\n  requires 0.0 <= new_review_score <= 999.99\n  requires 0.0 <= new_total_score <= 999.99\n  ensures s.review_score == new_review_score\n  ensures s.total_score == new_total_score\n{\n  s.review_score := new_review_score;\n  s.total_score := new_total_score;\n}\nmethod Main()\n{\n  var submission := new Submission;\n  submission.review_score := 0.0;\n  submission.total_score := 0.0;\n  AlterSubmissionFields(submission, 85.50, 92.75);\n  assert submission.review_score == 85.50;\n  assert submission.total_score == 92.75;\n}", "name": "py2dfy_55", "id": 55}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method ExtraLongFactorials(n: nat) returns (result: nat)\n{\n    result := ItFactorial(n);\n}\nmethod ItFactorial(n: nat) returns (result: nat)\n{\n    var res: nat := 1;\n    var i: nat := 1;\n    while i <= n\n    {\n        res := res * i;\n        i := i + 1;\n    }\n    result := res;\n}\nfunction Factorial(k: nat): nat\n{\n    if k == 0 then 1 else k * Factorial(k - 1)\n}\nmethod Main()\n{\n    var n := 5;\n    var result := ExtraLongFactorials(n);\n    print result;\n}", "output": "method ExtraLongFactorials(n: nat) returns (result: nat)\n    requires n >= 0\n    ensures result == Factorial(n)\n{\n    result := ItFactorial(n);\n}\nmethod ItFactorial(n: nat) returns (result: nat)\n    requires n >= 0\n    ensures result == Factorial(n)\n{\n    var res: nat := 1;\n    var i: nat := 1;\n    while i <= n\n        invariant 1 <= i <= n + 1\n        invariant res == Factorial(i - 1)\n    {\n        res := res * i;\n        i := i + 1;\n    }\n    result := res;\n}\nfunction Factorial(k: nat): nat\n    decreases k\n{\n    if k == 0 then 1 else k * Factorial(k - 1)\n}\nmethod Main()\n{\n    var n := 5;\n    var result := ExtraLongFactorials(n);\n    print result;\n}", "name": "py2dfy_8", "id": 8}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class App {\n  var isRunning: bool\n  var debugMode: bool\n  constructor()\n  {\n    isRunning := false;\n    debugMode := false;\n  }\n  method Run(debug: bool)\n  {\n    isRunning := true;\n    debugMode := debug;\n  }\n}\nmethod Main()\n{\n  var app := new App();\n  app.Run(true);\n}", "output": "class App {\n  var isRunning: bool\n  var debugMode: bool\n  constructor()\n    ensures !isRunning && !debugMode\n  {\n    isRunning := false;\n    debugMode := false;\n  }\n  method Run(debug: bool)\n    modifies this\n    requires !isRunning\n    ensures isRunning\n    ensures debugMode == debug\n  {\n    isRunning := true;\n    debugMode := debug;\n  }\n}\nmethod Main()\n{\n  var app := new App();\n  app.Run(true);\n  assert app.isRunning && app.debugMode;\n}", "name": "py2dfy_86", "id": 86}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module RequirementsProcessor {\n  \n  datatype Line = Line(content: string)\n  \n  \n  type RequirementsList = seq<string>\n  \n  \n  method StripComments(lines: seq<Line>) returns (result: RequirementsList)\n  {\n    result := [];\n    \n    var i := 0;\n    while i < |lines|\n    {\n      var line := lines[i].content;\n      \n      var trimmed := Trim(line);\n      \n      if trimmed != \"\" && !StartsWithChar(trimmed, '#') {\n        var processedLine := trimmed;\n        \n        \n        if ContainsChar(trimmed, '#') {\n          var commentIndex := IndexOf(trimmed, '#');\n          processedLine := trimmed[..commentIndex];\n          processedLine := Trim(processedLine);\n        }\n        \n        if processedLine != \"\" {\n          result := result + [processedLine];\n        }\n      }\n      \n      i := i + 1;\n    }\n  }\n  \n  \n  method GetRequirements(filename: string) returns (requirements: RequirementsList)\n  {\n    \n    \n    var fileLines := ReadFile(filename);\n    requirements := StripComments(fileLines);\n  }\n  \n  \n  method ReadFile(filename: string) returns (lines: seq<Line>)\n  {\n    \n    \n    if filename == \"requirements.txt\" {\n      lines := [\n        Line(\"# This is a comment\"),\n        Line(\"package1>=1.0.0\"),\n        Line(\"package2==2.0.0 # With a comment\"),\n        Line(\"\"),\n        Line(\"  package3  \")\n      ];\n    } else if filename == \"test-requirements.txt\" {\n      lines := [\n        Line(\"pytest>=3.0.0\"),\n        Line(\"# Test packages\"),\n        Line(\"nose # Testing tool\")\n      ];\n    } else {\n      lines := [];\n    }\n  }\n  \n  \n  \n  \n  \n  function Trim(s: string): string\n  {\n    s \n  }\n  \n  \n  predicate StartsWithChar(s: string, c: char)\n  {\n    s[0] == c\n  }\n  \n  \n  predicate ContainsChar(s: string, c: char)\n  {\n    exists i :: 0 <= i < |s| && s[i] == c\n  }\n  \n  \n  function IndexOf(s: string, c: char): int\n  {\n    if |s| == 0 then -1\n    else if s[0] == c then 0\n    else if IndexOf(s[1..], c) == -1 then -1\n    else 1 + IndexOf(s[1..], c)\n  }\n  \n  \n  method Main()\n  {\n    var reqFile := \"requirements.txt\";\n    var testReqFile := \"test-requirements.txt\";\n    \n    var requirements := GetRequirements(reqFile);\n    var testRequirements := GetRequirements(testReqFile);\n    \n    \n    \n  }\n}", "output": "module RequirementsProcessor {\n  \n  datatype Line = Line(content: string)\n  \n  \n  type RequirementsList = seq<string>\n  \n  \n  method StripComments(lines: seq<Line>) returns (result: RequirementsList)\n    ensures |result| <= |lines|\n    ensures forall i :: 0 <= i < |result| ==> result[i] != \"\"\n    ensures forall i :: 0 <= i < |result| ==> '#' !in result[i]\n  {\n    result := [];\n    \n    var i := 0;\n    while i < |lines|\n      invariant 0 <= i <= |lines|\n      invariant |result| <= i\n      invariant forall j :: 0 <= j < |result| ==> result[j] != \"\"\n      invariant forall j :: 0 <= j < |result| ==> '#' !in result[j]\n    {\n      var line := lines[i].content;\n      \n      var trimmed := Trim(line);\n      \n      if trimmed != \"\" && !StartsWithChar(trimmed, '#') {\n        var processedLine := trimmed;\n        \n        \n        if ContainsChar(trimmed, '#') {\n          var commentIndex := IndexOf(trimmed, '#');\n          processedLine := trimmed[..commentIndex];\n          processedLine := Trim(processedLine);\n        }\n        \n        if processedLine != \"\" {\n          result := result + [processedLine];\n        }\n      }\n      \n      i := i + 1;\n    }\n  }\n  \n  \n  method GetRequirements(filename: string) returns (requirements: RequirementsList)\n    requires filename != \"\"\n    ensures forall i :: 0 <= i < |requirements| ==> requirements[i] != \"\"\n    ensures forall i :: 0 <= i < |requirements| ==> '#' !in requirements[i]\n  {\n    \n    \n    var fileLines := ReadFile(filename);\n    requirements := StripComments(fileLines);\n  }\n  \n  \n  method ReadFile(filename: string) returns (lines: seq<Line>)\n    requires filename != \"\"\n    ensures |lines| >= 0\n  {\n    \n    \n    if filename == \"requirements.txt\" {\n      lines := [\n        Line(\"# This is a comment\"),\n        Line(\"package1>=1.0.0\"),\n        Line(\"package2==2.0.0 # With a comment\"),\n        Line(\"\"),\n        Line(\"  package3  \")\n      ];\n    } else if filename == \"test-requirements.txt\" {\n      lines := [\n        Line(\"pytest>=3.0.0\"),\n        Line(\"# Test packages\"),\n        Line(\"nose # Testing tool\")\n      ];\n    } else {\n      lines := [];\n    }\n  }\n  \n  \n  \n  \n  \n  function Trim(s: string): string\n    ensures |Trim(s)| <= |s|\n  {\n    s \n  }\n  \n  \n  predicate StartsWithChar(s: string, c: char)\n    requires |s| > 0\n  {\n    s[0] == c\n  }\n  \n  \n  predicate ContainsChar(s: string, c: char)\n  {\n    exists i :: 0 <= i < |s| && s[i] == c\n  }\n  \n  \n  function IndexOf(s: string, c: char): int\n    ensures -1 <= IndexOf(s, c) < |s|\n    ensures IndexOf(s, c) == -1 ==> !ContainsChar(s, c)\n    ensures IndexOf(s, c) >= 0 ==> s[IndexOf(s, c)] == c\n    ensures IndexOf(s, c) >= 0 ==> forall i :: 0 <= i < IndexOf(s, c) ==> s[i] != c\n  {\n    if |s| == 0 then -1\n    else if s[0] == c then 0\n    else if IndexOf(s[1..], c) == -1 then -1\n    else 1 + IndexOf(s[1..], c)\n  }\n  \n  \n  method Main()\n  {\n    var reqFile := \"requirements.txt\";\n    var testReqFile := \"test-requirements.txt\";\n    \n    var requirements := GetRequirements(reqFile);\n    var testRequirements := GetRequirements(testReqFile);\n    \n    \n    \n  }\n}", "name": "py2dfy_20", "id": 20}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CountStringsWithManyOnes(lines: seq<string>) returns (count: nat)\n  \n  \n  \n{\n  count := 0;\n  var i := 0;\n  var countSet := {};\n  \n  \n  while i < |lines|\n  {\n    if CountOnes(lines[i]) >= 15 {\n      count := count + 1;\n      countSet := countSet + {i};\n    }\n    i := i + 1;\n  }\n}\nfunction CountOnes(s: string): nat\n{\n  \n  |seq(|s|, i requires 0 <= i < |s| => if s[i] == '1' then 1 else 0)|\n}", "output": "method CountStringsWithManyOnes(lines: seq<string>) returns (count: nat)\n  \n  requires forall s :: s in lines ==> |s| >= 0\n  \n  ensures count >= 0\n  \n  ensures count == |set i | 0 <= i < |lines| && CountOnes(lines[i]) >= 15|\n{\n  count := 0;\n  var i := 0;\n  var countSet := {};\n  \n  \n  while i < |lines|\n    invariant 0 <= i <= |lines|\n    invariant count >= 0\n    invariant countSet == set j | 0 <= j < i && CountOnes(lines[j]) >= 15\n    invariant count == |countSet|\n  {\n    if CountOnes(lines[i]) >= 15 {\n      count := count + 1;\n      countSet := countSet + {i};\n    }\n    i := i + 1;\n  }\n}\nfunction CountOnes(s: string): nat\n  requires |s| >= 0\n  ensures CountOnes(s) >= 0\n{\n  \n  |seq(|s|, i requires 0 <= i < |s| => if s[i] == '1' then 1 else 0)|\n}", "name": "py2dfy_24", "id": 24}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ProcessConfiguration = ProcessConfiguration(name: string)\nclass MessageLoggerConfig {\n  var enableCerr: bool\n  var enableCout: bool\n  var threshold: string\n  constructor()\n  {\n    enableCerr := false;\n    enableCout := true;\n    threshold := \"INFO\";\n  }\n}\nclass DatabaseConfig {\n  var connectionString: string\n  var isDumpStatEnabled: bool\n  var records: seq<Record>\n  constructor()\n  {\n    connectionString := \"\";\n    isDumpStatEnabled := false;\n    records := [];\n  }\n}\ndatatype Record = Record(\n  recordName: string,\n  tagName: string\n)\nclass GeometryConfiguration {\n  var geometryType: string\n  var printRPInfo: bool\n  var printSensorInfo: bool\n  constructor()\n  {\n    geometryType := \"misaligned\";\n    printRPInfo := true;\n    printSensorInfo := true;\n  }\n  \n  method ValidateConfiguration() returns (isValid: bool)\n  {\n    isValid := geometryType == \"misaligned\" || geometryType == \"ideal\";\n  }\n}\nmethod ConfigureGeometryProcess(\n  processName: string,\n  dbPath: string\n) returns (config: ProcessConfiguration, geomConfig: GeometryConfiguration, dbConfig: DatabaseConfig)\n{\n  \n  config := ProcessConfiguration(processName);\n  \n  \n  geomConfig := new GeometryConfiguration();\n  \n  \n  dbConfig := new DatabaseConfig();\n  dbConfig.connectionString := dbPath;\n  dbConfig.isDumpStatEnabled := true;\n  \n  \n  var record := Record(\"RPMisalignedAlignmentRecord\", \"CTPPSRPAlignment_misaligned\");\n  dbConfig.records := dbConfig.records + [record];\n}", "output": "datatype ProcessConfiguration = ProcessConfiguration(name: string)\nclass MessageLoggerConfig {\n  var enableCerr: bool\n  var enableCout: bool\n  var threshold: string\n  constructor()\n    ensures enableCout  \n    ensures threshold == \"INFO\"  \n  {\n    enableCerr := false;\n    enableCout := true;\n    threshold := \"INFO\";\n  }\n}\nclass DatabaseConfig {\n  var connectionString: string\n  var isDumpStatEnabled: bool\n  var records: seq<Record>\n  constructor()\n    ensures connectionString == \"\"  \n    ensures |records| == 0         \n  {\n    connectionString := \"\";\n    isDumpStatEnabled := false;\n    records := [];\n  }\n}\ndatatype Record = Record(\n  recordName: string,\n  tagName: string\n)\nclass GeometryConfiguration {\n  var geometryType: string\n  var printRPInfo: bool\n  var printSensorInfo: bool\n  constructor()\n    ensures geometryType == \"misaligned\"  \n    ensures printRPInfo                   \n    ensures printSensorInfo               \n  {\n    geometryType := \"misaligned\";\n    printRPInfo := true;\n    printSensorInfo := true;\n  }\n  \n  method ValidateConfiguration() returns (isValid: bool)\n    ensures isValid ==> (geometryType == \"misaligned\" || geometryType == \"ideal\")\n  {\n    isValid := geometryType == \"misaligned\" || geometryType == \"ideal\";\n  }\n}\nmethod ConfigureGeometryProcess(\n  processName: string,\n  dbPath: string\n) returns (config: ProcessConfiguration, geomConfig: GeometryConfiguration, dbConfig: DatabaseConfig)\n  requires |processName| > 0        \n  requires |dbPath| > 0            \n  ensures config.name == processName\n  ensures dbConfig.connectionString == dbPath\n  ensures geomConfig.geometryType == \"misaligned\"\n{\n  \n  config := ProcessConfiguration(processName);\n  \n  \n  geomConfig := new GeometryConfiguration();\n  \n  \n  dbConfig := new DatabaseConfig();\n  dbConfig.connectionString := dbPath;\n  dbConfig.isDumpStatEnabled := true;\n  \n  \n  var record := Record(\"RPMisalignedAlignmentRecord\", \"CTPPSRPAlignment_misaligned\");\n  dbConfig.records := dbConfig.records + [record];\n}", "name": "py2dfy_90", "id": 90}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module FileOperations {\n    \n    datatype FileContent = FileContent(content: seq<char>)\n    \n    \n    type FileSystem = map<string, FileContent>\n    \n    method ReadFile(fs: FileSystem, filename: string) returns (success: bool, content: string)\n    {\n        if filename in fs {\n            success := true;\n            content := FileContentToString(fs[filename]);\n        } else {\n            success := false;\n            content := \"\";\n        }\n    }\n    \n    function FileContentToString(fc: FileContent): string\n    {\n        seq(|fc.content|, i requires 0 <= i < |fc.content| => fc.content[i])\n    }\n    \n    method Main(fs: FileSystem)\n    {\n        var filename := \"mydata.txt\";\n        var success, content := ReadFile(fs, filename);\n        if !success {\n            print \"file is not found\\n\";\n            print \"Error: File '\", filename, \"' not found\\n\";\n        } else {\n            print \"file: \", content, \"\\n\";\n        }\n        print \"finished working\\n\";\n    }\n}", "output": "module FileOperations {\n    \n    datatype FileContent = FileContent(content: seq<char>)\n    \n    \n    type FileSystem = map<string, FileContent>\n    \n    method ReadFile(fs: FileSystem, filename: string) returns (success: bool, content: string)\n    requires fs.Keys != {}\n    ensures success ==> filename in fs\n    ensures !success ==> filename !in fs\n    ensures success ==> content == FileContentToString(fs[filename])\n    ensures !success ==> content == \"\"\n    {\n        if filename in fs {\n            success := true;\n            content := FileContentToString(fs[filename]);\n        } else {\n            success := false;\n            content := \"\";\n        }\n    }\n    \n    function FileContentToString(fc: FileContent): string\n    {\n        seq(|fc.content|, i requires 0 <= i < |fc.content| => fc.content[i])\n    }\n    \n    method Main(fs: FileSystem)\n    requires fs.Keys != {}\n    {\n        var filename := \"mydata.txt\";\n        var success, content := ReadFile(fs, filename);\n        if !success {\n            print \"file is not found\\n\";\n            print \"Error: File '\", filename, \"' not found\\n\";\n        } else {\n            print \"file: \", content, \"\\n\";\n        }\n        print \"finished working\\n\";\n    }\n}", "name": "py2dfy_10", "id": 10}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type unit = bool  \ndatatype Logger = Logger(debug: string -> unit, info: string -> unit, warn: (string, int) -> unit)\ndatatype ExecutionResult = ExecutionResult(exitCode: int, reportFile: string)\ndatatype Project = Project(sources: seq<string>)\ndatatype ExecutableCheck = Success | Failure(error: string)\nmethod AssertCanExecute(command: string) returns (result: ExecutableCheck)\n{\n  if command == \"\" {\n    return Failure(\"Empty command\");\n  }\n  \n  return Success;\n}\nmethod ReadFile(filename: string) returns (lines: seq<string>)\n{\n  \n  lines := [];  \n}\nmethod Analyze(project: Project, logger: Logger) returns (warningCount: int)\n{\n  \n  var _ := logger.info(\"Applying flake8 to project sources.\");\n  \n  var result := ExecuteToolOnSourceFiles(project);\n  \n  \n  var reportLines := ReadFile(result.reportFile);\n  warningCount := |reportLines|;\n  \n  if warningCount > 0 {\n    var _ := logger.warn(\"flake8 found %d warning(s).\", warningCount);\n  }\n}\nmethod ExecuteToolOnSourceFiles(project: Project) returns (result: ExecutionResult)\n{\n  \n  return ExecutionResult(0, \"report.txt\");\n}\nmethod VerifyFlake8Plugin(project: Project, logger: Logger) returns (success: bool)\n{\n  \n  var executableCheck := AssertCanExecute(\"flake8\");\n  if executableCheck.Failure? {\n    return false;\n  }\n  \n  var warnings := Analyze(project, logger);\n  \n  \n  return true;\n}", "output": "type unit = bool  \ndatatype Logger = Logger(debug: string -> unit, info: string -> unit, warn: (string, int) -> unit)\ndatatype ExecutionResult = ExecutionResult(exitCode: int, reportFile: string)\ndatatype Project = Project(sources: seq<string>)\ndatatype ExecutableCheck = Success | Failure(error: string)\nmethod AssertCanExecute(command: string) returns (result: ExecutableCheck)\n  ensures result.Success? ==> command != \"\"  \n  ensures result.Failure? ==> |result.error| > 0  \n{\n  if command == \"\" {\n    return Failure(\"Empty command\");\n  }\n  \n  return Success;\n}\nmethod ReadFile(filename: string) returns (lines: seq<string>)\n  requires filename != \"\"  \n  ensures |lines| >= 0  \n{\n  \n  lines := [];  \n}\nmethod Analyze(project: Project, logger: Logger) returns (warningCount: int)\n  requires |project.sources| >= 0  \n  ensures warningCount >= 0  \n{\n  \n  var _ := logger.info(\"Applying flake8 to project sources.\");\n  \n  var result := ExecuteToolOnSourceFiles(project);\n  \n  \n  var reportLines := ReadFile(result.reportFile);\n  warningCount := |reportLines|;\n  \n  if warningCount > 0 {\n    var _ := logger.warn(\"flake8 found %d warning(s).\", warningCount);\n  }\n}\nmethod ExecuteToolOnSourceFiles(project: Project) returns (result: ExecutionResult)\n  requires |project.sources| >= 0\n  ensures result.exitCode >= 0  \n  ensures result.reportFile != \"\"  \n{\n  \n  return ExecutionResult(0, \"report.txt\");\n}\nmethod VerifyFlake8Plugin(project: Project, logger: Logger) returns (success: bool)\n  requires |project.sources| >= 0\n  ensures success ==> |project.sources| >= 0  \n{\n  \n  var executableCheck := AssertCanExecute(\"flake8\");\n  if executableCheck.Failure? {\n    return false;\n  }\n  \n  var warnings := Analyze(project, logger);\n  \n  \n  return true;\n}", "name": "py2dfy_44", "id": 44}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Print(x: int)\n{\n    print x, \"\\n\";\n}\nmethod Basic()\n{\n    var i := 0;\n    while i < 251\n    {\n        Print(i);\n        i := i + 1;\n    }\n}\nmethod MultiplesOf5()\n{\n    var i := 5;\n    while i <= 1000\n    {\n        Print(i);\n        i := i + 5;\n    }\n}\nmethod DojoCount()\n{\n    var i := 1;\n    while i <= 100\n    {\n        if i % 10 == 0 {\n            print \"Coding Dojo\\n\";\n        } else if i % 5 == 0 {\n            print \"Coding\\n\";\n        } else {\n            Print(i);\n        }\n        i := i + 1;\n    }\n}\nmethod Huge() returns (sum: int)\n{\n    sum := 0;\n    var i := 0;\n    while i <= 500000\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}\nmethod Countdown4()\n{\n    var i := 2018;\n    while i > 0\n    {\n        Print(i);\n        i := i - 4;\n    }\n}\nmethod FlexCounter(lowNum: int, highNum: int, mult: int)\n{\n    var i := lowNum;\n    while i <= highNum\n    {\n        if i % mult == 0 {\n            Print(i);\n        }\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n    Basic();\n    print \"\\n\";\n    MultiplesOf5();\n    print \"\\n\";\n    DojoCount();\n    print \"\\n\";\n    var sum := Huge();\n    Print(sum);\n    print \"\\n\";\n    Countdown4();\n    print \"\\n\";\n    FlexCounter(2, 9, 3);\n}", "output": "method Print(x: int)\n{\n    print x, \"\\n\";\n}\nmethod Basic()\n{\n    var i := 0;\n    while i < 251\n        invariant 0 <= i <= 251\n    {\n        Print(i);\n        i := i + 1;\n    }\n}\nmethod MultiplesOf5()\n{\n    var i := 5;\n    while i <= 1000\n        invariant 5 <= i <= 1005\n        invariant i % 5 == 0\n    {\n        Print(i);\n        i := i + 5;\n    }\n}\nmethod DojoCount()\n{\n    var i := 1;\n    while i <= 100\n        invariant 1 <= i <= 101\n    {\n        if i % 10 == 0 {\n            print \"Coding Dojo\\n\";\n        } else if i % 5 == 0 {\n            print \"Coding\\n\";\n        } else {\n            Print(i);\n        }\n        i := i + 1;\n    }\n}\nmethod Huge() returns (sum: int)\n    ensures sum == 500000 * 500001 / 2\n{\n    sum := 0;\n    var i := 0;\n    while i <= 500000\n        invariant 0 <= i <= 500001\n        invariant sum == i * (i - 1) / 2\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}\nmethod Countdown4()\n{\n    var i := 2018;\n    while i > 0\n        invariant i <= 2018\n        invariant i > -4\n    {\n        Print(i);\n        i := i - 4;\n    }\n}\nmethod FlexCounter(lowNum: int, highNum: int, mult: int)\n    requires lowNum <= highNum\n    requires mult > 0\n{\n    var i := lowNum;\n    while i <= highNum\n        invariant lowNum <= i <= highNum + 1\n    {\n        if i % mult == 0 {\n            Print(i);\n        }\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n    Basic();\n    print \"\\n\";\n    MultiplesOf5();\n    print \"\\n\";\n    DojoCount();\n    print \"\\n\";\n    var sum := Huge();\n    Print(sum);\n    print \"\\n\";\n    Countdown4();\n    print \"\\n\";\n    FlexCounter(2, 9, 3);\n}", "name": "py2dfy_73", "id": 73}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ModelOptions = ModelOptions(\n  ordering: seq<string>,\n  permissions: seq<(string, string)>,\n  defaultPermissions: seq<string>,\n  managed: bool\n)\ndatatype Model = Model(\n  name: string,\n  options: ModelOptions\n)\ndatatype Dependency = Dependency(\n  app: string,\n  name: string\n)\nmethod AlterModelOptions(\n  models: map<string, Model>, \n  modelName: string, \n  newOptions: ModelOptions\n) returns (updatedModels: map<string, Model>)\n            m in updatedModels && updatedModels[m] == models[m]  \n{\n  updatedModels := models;\n  var model := models[modelName];\n  var updatedModel := Model(model.name, newOptions);\n  updatedModels := updatedModels[modelName := updatedModel];\n}\nmethod Migration0021_AlterUserModelOptions(database: map<string, Model>) returns (newDatabase: map<string, Model>)\n            m in newDatabase && newDatabase[m] == database[m]  \n{\n  \n  var emptyOptions := ModelOptions([], [], [], true);\n  \n  \n  newDatabase := AlterModelOptions(database, \"user\", emptyOptions);\n}", "output": "datatype ModelOptions = ModelOptions(\n  ordering: seq<string>,\n  permissions: seq<(string, string)>,\n  defaultPermissions: seq<string>,\n  managed: bool\n)\ndatatype Model = Model(\n  name: string,\n  options: ModelOptions\n)\ndatatype Dependency = Dependency(\n  app: string,\n  name: string\n)\nmethod AlterModelOptions(\n  models: map<string, Model>, \n  modelName: string, \n  newOptions: ModelOptions\n) returns (updatedModels: map<string, Model>)\n  requires modelName in models  \n  ensures modelName in updatedModels  \n  ensures updatedModels[modelName].name == models[modelName].name  \n  ensures updatedModels[modelName].options == newOptions  \n  ensures forall m :: m in models && m != modelName ==> \n            m in updatedModels && updatedModels[m] == models[m]  \n{\n  updatedModels := models;\n  var model := models[modelName];\n  var updatedModel := Model(model.name, newOptions);\n  updatedModels := updatedModels[modelName := updatedModel];\n}\nmethod Migration0021_AlterUserModelOptions(database: map<string, Model>) returns (newDatabase: map<string, Model>)\n  requires \"user\" in database  \n  ensures \"user\" in newDatabase  \n  ensures newDatabase[\"user\"].name == database[\"user\"].name  \n  ensures newDatabase[\"user\"].options == ModelOptions([], [], [], true)  \n  ensures forall m :: m in database && m != \"user\" ==> \n            m in newDatabase && newDatabase[m] == database[m]  \n{\n  \n  var emptyOptions := ModelOptions([], [], [], true);\n  \n  \n  newDatabase := AlterModelOptions(database, \"user\", emptyOptions);\n}", "name": "py2dfy_26", "id": 26}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method BetToWin() returns (count: nat)\n{\n    count := 1;\n    while true\n    {\n        var outcome := if Random() then \"win\" else \"lose\";\n        if outcome == \"win\" {\n            return count;\n        }\n        count := count + 1;\n    }\n}\nmethod Main()\n{\n    var maxCount: nat := 0;\n    var earning: int := 0;\n    \n    while true\n    {\n        var count := BetToWin();\n        \n        if maxCount < count {\n            maxCount := count;\n        }\n        \n        earning := earning + 1;\n        \n        print \"earning: \", earning, \", count: \", count, \n              \", max count: \", maxCount, \", max stake: \", Pow2(maxCount - 1), \"\\n\";\n        \n        Sleep(10); \n    }\n}\nfunction {:axiom} Random(): bool\nmethod {:axiom} Sleep(ms: nat)\nfunction Pow2(n: int): nat\n{\n    if n == 0 then 1 else 2 * Pow2(n-1)\n}\nmethod {:main} RunMain()\n{\n    Main();\n}", "output": "method BetToWin() returns (count: nat)\nensures count >= 1\ndecreases *\n{\n    count := 1;\n    while true\n        invariant count >= 1\n        decreases *\n    {\n        var outcome := if Random() then \"win\" else \"lose\";\n        if outcome == \"win\" {\n            return count;\n        }\n        count := count + 1;\n    }\n}\nmethod Main()\ndecreases *\n{\n    var maxCount: nat := 0;\n    var earning: int := 0;\n    \n    while true\n        invariant maxCount >= 0\n        invariant earning >= 0\n        decreases *\n    {\n        var count := BetToWin();\n        \n        if maxCount < count {\n            maxCount := count;\n        }\n        \n        earning := earning + 1;\n        \n        print \"earning: \", earning, \", count: \", count, \n              \", max count: \", maxCount, \", max stake: \", Pow2(maxCount - 1), \"\\n\";\n        \n        Sleep(10); \n    }\n}\nfunction {:axiom} Random(): bool\nensures true  \nmethod {:axiom} Sleep(ms: nat)\nrequires ms >= 0\nensures true  \nfunction Pow2(n: int): nat\nrequires n >= 0\nensures Pow2(n) >= 1\n{\n    if n == 0 then 1 else 2 * Pow2(n-1)\n}\nmethod {:main} RunMain()\ndecreases *\n{\n    Main();\n}", "name": "py2dfy_47", "id": 47}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait AppConfig {\n    \n    var name: string\n    \n    predicate Valid()\n    {\n        name != \"\"  \n    }\n    \n    method GetName() returns (appName: string)\n    {\n        appName := name;\n    }\n}\nclass ClassromConfig extends AppConfig {\n    \n    constructor Init()\n    {\n        name := \"classrom\";\n    }\n}", "output": "trait AppConfig {\n    \n    var name: string\n    \n    predicate Valid()\n        reads this\n    {\n        name != \"\"  \n    }\n    \n    method GetName() returns (appName: string)\n        requires Valid()        \n        ensures appName == name \n        ensures Valid()         \n    {\n        appName := name;\n    }\n}\nclass ClassromConfig extends AppConfig {\n    \n    constructor Init()\n        ensures Valid()                \n        ensures name == \"classrom\"     \n    {\n        name := \"classrom\";\n    }\n}", "name": "py2dfy_72", "id": 72}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Field {\n  var value: string\n  constructor()\n  {\n    value := \"\";\n  }\n  method SetValue(newValue: string)\n  {\n    value := newValue;\n  }\n  function GetValue(): string\n  {\n    value\n  }\n}\nclass JiayuanItem {\n  var person_id: Field\n  var user_info: Field\n  var main_url: Field\n  var nick_name: Field\n  var height: Field\n  constructor()\n  {\n    person_id := new Field();\n    user_info := new Field();\n    main_url := new Field();\n    nick_name := new Field();\n    height := new Field();\n  }\n}\nclass PersonInfo {\n  var person_id: Field\n  var buy_car: Field\n  var address: Field\n  constructor()\n  {\n    person_id := new Field();\n    buy_car := new Field();\n    address := new Field();\n  }\n}\nclass OtherItem {\n  var user_info: Field\n  var main_url: Field\n  var nick_name: Field\n  var height: Field\n  constructor()\n  {\n    user_info := new Field();\n    main_url := new Field();\n    nick_name := new Field();\n    height := new Field();\n  }\n}", "output": "class Field {\n  var value: string\n  constructor()\n  ensures value == \"\"\n  {\n    value := \"\";\n  }\n  method SetValue(newValue: string)\n  modifies this\n  ensures value == newValue\n  {\n    value := newValue;\n  }\n  function GetValue(): string\n  reads this\n  {\n    value\n  }\n}\nclass JiayuanItem {\n  var person_id: Field\n  var user_info: Field\n  var main_url: Field\n  var nick_name: Field\n  var height: Field\n  constructor()\n  ensures fresh(person_id) && fresh(user_info) && fresh(main_url) && fresh(nick_name) && fresh(height)\n  {\n    person_id := new Field();\n    user_info := new Field();\n    main_url := new Field();\n    nick_name := new Field();\n    height := new Field();\n  }\n}\nclass PersonInfo {\n  var person_id: Field\n  var buy_car: Field\n  var address: Field\n  constructor()\n  ensures fresh(person_id) && fresh(buy_car) && fresh(address)\n  {\n    person_id := new Field();\n    buy_car := new Field();\n    address := new Field();\n  }\n}\nclass OtherItem {\n  var user_info: Field\n  var main_url: Field\n  var nick_name: Field\n  var height: Field\n  constructor()\n  ensures fresh(user_info) && fresh(main_url) && fresh(nick_name) && fresh(height)\n  {\n    user_info := new Field();\n    main_url := new Field();\n    nick_name := new Field();\n    height := new Field();\n  }\n}", "name": "py2dfy_2", "id": 2}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintNTimes(n: nat)\n  \n  \n{\n  if n > 0 {\n    print \"12345\\n\";\n    PrintNTimes(n-1);\n  }\n}\nmethod Main() {\n  PrintNTimes(5);\n}", "output": "method PrintNTimes(n: nat)\n  \n  requires n >= 0\n  \n  decreases n\n{\n  if n > 0 {\n    print \"12345\\n\";\n    PrintNTimes(n-1);\n  }\n}\nmethod Main() {\n  PrintNTimes(5);\n}", "name": "py2dfy_34", "id": 34}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module ParcelLookup {\n    datatype Option<T> = Some(value: T) | None\n    class Database {\n        var rows: seq<map<string, string>>\n        constructor()\n        {\n            rows := [];\n        }\n        method Execute(query: string, params: seq<string>) returns (rowCount: nat)\n            rows == [map[\"parcel_id\" := params[0]]]\n            rows == []\n        {\n            if query == \"select * from parcels where parcel_id = (?)\" && |params| == 1 {\n                rows := [map[\"parcel_id\" := params[0]]];\n            } else {\n                rows := [];\n            }\n            rowCount := |rows|;\n        }\n        method Fetchone() returns (result: Option<map<string, string>>)\n        {\n            if |rows| > 0 {\n                result := Some(rows[0]);\n            } else {\n                result := None;\n            }\n        }\n    }\n    method ParcelRoute(db: Database?, query: string) returns (result: Option<map<string, string>>)\n    {\n        if !IsNumeric(query) {\n            return None;\n        }\n        var rowCount := db.Execute(\"select * from parcels where parcel_id = (?)\", [query]);\n        if rowCount > 0 {\n            result := db.Fetchone();\n        } else {\n            result := None;\n        }\n    }\n    predicate IsNumeric(s: string)\n    {\n        forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    }\n}", "output": "module ParcelLookup {\n    datatype Option<T> = Some(value: T) | None\n    class Database {\n        var rows: seq<map<string, string>>\n        constructor()\n        ensures rows == []\n        {\n            rows := [];\n        }\n        method Execute(query: string, params: seq<string>) returns (rowCount: nat)\n        modifies this\n        ensures rowCount == |rows|\n        ensures query == \"select * from parcels where parcel_id = (?)\" && |params| == 1 ==>\n            rows == [map[\"parcel_id\" := params[0]]]\n        ensures query != \"select * from parcels where parcel_id = (?)\" || |params| != 1 ==>\n            rows == []\n        {\n            if query == \"select * from parcels where parcel_id = (?)\" && |params| == 1 {\n                rows := [map[\"parcel_id\" := params[0]]];\n            } else {\n                rows := [];\n            }\n            rowCount := |rows|;\n        }\n        method Fetchone() returns (result: Option<map<string, string>>)\n        requires |rows| > 0\n        ensures result.Some? ==> result.value == rows[0]\n        ensures result.None? ==> rows == []\n        {\n            if |rows| > 0 {\n                result := Some(rows[0]);\n            } else {\n                result := None;\n            }\n        }\n    }\n    method ParcelRoute(db: Database?, query: string) returns (result: Option<map<string, string>>)\n    requires db != null\n    modifies db\n    ensures result.Some? ==> result.value.Keys == {\"parcel_id\"}\n    ensures result.Some? ==> result.value[\"parcel_id\"] == query\n    ensures IsNumeric(query) || result.None?\n    {\n        if !IsNumeric(query) {\n            return None;\n        }\n        var rowCount := db.Execute(\"select * from parcels where parcel_id = (?)\", [query]);\n        if rowCount > 0 {\n            result := db.Fetchone();\n        } else {\n            result := None;\n        }\n    }\n    predicate IsNumeric(s: string)\n    {\n        forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    }\n}", "name": "py2dfy_51", "id": 51}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method GenerateSquareNumbers(n: nat) returns (x: seq<int>, y: seq<int>)\n{\n  x := [];\n  y := [];\n  var i := 0;\n  while i < n\n  {\n    x := x + [i + 1];\n    y := y + [(i + 1) * (i + 1)];\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var x, y := GenerateSquareNumbers(1000);\n}", "output": "method GenerateSquareNumbers(n: nat) returns (x: seq<int>, y: seq<int>)\n  requires n > 0\n  ensures |x| == n && |y| == n\n  ensures forall i :: 0 <= i < n ==> x[i] == i + 1\n  ensures forall i :: 0 <= i < n ==> y[i] == (i + 1) * (i + 1)\n{\n  x := [];\n  y := [];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant |x| == i && |y| == i\n    invariant forall j :: 0 <= j < i ==> x[j] == j + 1\n    invariant forall j :: 0 <= j < i ==> y[j] == (j + 1) * (j + 1)\n  {\n    x := x + [i + 1];\n    y := y + [(i + 1) * (i + 1)];\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var x, y := GenerateSquareNumbers(1000);\n  assert x[0] == 1 && y[0] == 1;\n  assert x[999] == 1000 && y[999] == 1000000;\n}", "name": "py2dfy_88", "id": 88}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "const PI: real := 3.14159265359  \nmethod CalculateCircleArea(radius: real) returns (area: real)\n{\n  area := PI * radius * radius;\n}\nmethod Main() {\n  \n  var radius := 5.0;\n  var area := CalculateCircleArea(radius);\n  print \"Area of circle with radius \", radius, \" is: \", area, \"\\n\";\n}", "output": "const PI: real := 3.14159265359  \nmethod CalculateCircleArea(radius: real) returns (area: real)\n  requires radius >= 0.0  \n  ensures area == PI * radius * radius  \n  ensures area >= 0.0  \n{\n  area := PI * radius * radius;\n}\nmethod Main() {\n  \n  var radius := 5.0;\n  var area := CalculateCircleArea(radius);\n  print \"Area of circle with radius \", radius, \" is: \", area, \"\\n\";\n}", "name": "py2dfy_35", "id": 35}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype TableEntry = TableEntry(value: seq<string>)\nclass MainWindow {\n  var baseFile: string\n  var baseFrame: seq<TableEntry>\n  var statusBar: string\n  constructor()\n  {\n    baseFile := \"\";\n    baseFrame := [];\n    statusBar := \"\";\n  }\n}\nclass BaseFileEventHandler {\n  var mainWindow: MainWindow  \n  var patterns: seq<string>   \n  constructor(pats: seq<string>, window: MainWindow)\n  {\n    patterns := pats;\n    mainWindow := window;\n  }\n  method getDataXls(filename: string) returns (data: seq<TableEntry>)\n  {\n    var entry := TableEntry([\"dummy\"]);\n    data := [entry];\n  }\n  method getAllEntriesAsList() returns (entries: seq<TableEntry>)\n  {\n    entries := mainWindow.baseFrame;\n  }\n  method loadBase()\n  {\n    mainWindow.statusBar := \"База обновлена\";\n  }\n  method onModified()\n            mainWindow.statusBar == \"База обновлена\"\n  {\n    var success := true;\n    \n    if success {\n      var baseData := getDataXls(mainWindow.baseFile);\n      var tableData := getAllEntriesAsList();\n      if |baseData| > 1 && baseData[1..] != tableData {\n        loadBase();\n      }\n    }\n  }\n}", "output": "datatype TableEntry = TableEntry(value: seq<string>)\nclass MainWindow {\n  var baseFile: string\n  var baseFrame: seq<TableEntry>\n  var statusBar: string\n  constructor()\n    ensures baseFile == \"\"\n    ensures |baseFrame| == 0 \n    ensures statusBar == \"\"\n  {\n    baseFile := \"\";\n    baseFrame := [];\n    statusBar := \"\";\n  }\n}\nclass BaseFileEventHandler {\n  var mainWindow: MainWindow  \n  var patterns: seq<string>   \n  constructor(pats: seq<string>, window: MainWindow)\n    requires |pats| > 0\n    ensures mainWindow == window\n    ensures patterns == pats\n  {\n    patterns := pats;\n    mainWindow := window;\n  }\n  method getDataXls(filename: string) returns (data: seq<TableEntry>)\n    requires filename != \"\"\n    ensures |data| > 0  \n  {\n    var entry := TableEntry([\"dummy\"]);\n    data := [entry];\n  }\n  method getAllEntriesAsList() returns (entries: seq<TableEntry>)\n    ensures |entries| >= 0  \n  {\n    entries := mainWindow.baseFrame;\n  }\n  method loadBase()\n    modifies mainWindow`baseFrame, mainWindow`statusBar\n    ensures mainWindow.statusBar == \"База обновлена\"\n  {\n    mainWindow.statusBar := \"База обновлена\";\n  }\n  method onModified()\n    modifies mainWindow`baseFrame, mainWindow`statusBar\n    requires mainWindow.baseFile != \"\"  \n    ensures old(mainWindow.baseFrame) != mainWindow.baseFrame ==>\n            mainWindow.statusBar == \"База обновлена\"\n  {\n    var success := true;\n    \n    if success {\n      var baseData := getDataXls(mainWindow.baseFile);\n      var tableData := getAllEntriesAsList();\n      if |baseData| > 1 && baseData[1..] != tableData {\n        loadBase();\n      }\n    }\n  }\n}", "name": "py2dfy_49", "id": 49}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Route = Route(start: string, end: string, distance: int)\nclass RouteGenerator {\n    \n    ghost predicate Valid()\n    {\n        true  \n    }\n    \n    method GenerateRoutes(source: string) returns (routes: seq<Route>)\n    {\n        \n        routes := [];\n        \n        \n        \n        var destination := \"DefaultDest\";\n        routes := routes + [Route(source, destination, 1)];\n        \n        \n        \n    }\n    \n    predicate IsValidRoute(r: Route)\n    {\n        && r.start != \"\"\n        && r.end != \"\"\n        && r.distance > 0\n    }\n    \n    method FilterValidRoutes(input: seq<Route>) returns (output: seq<Route>)\n    {\n        var validRoutes: seq<Route> := [];\n        var i := 0;\n        \n        \n        while i < |input|\n        {\n            if IsValidRoute(input[i]) {\n                validRoutes := validRoutes + [input[i]];\n            }\n            i := i + 1;\n        }\n        \n        output := validRoutes;\n    }\n}", "output": "datatype Route = Route(start: string, end: string, distance: int)\nclass RouteGenerator {\n    \n    ghost predicate Valid()\n    reads this\n    {\n        true  \n    }\n    \n    method GenerateRoutes(source: string) returns (routes: seq<Route>)\n    requires source != \"\"  \n    ensures |routes| > 0   \n    ensures forall r :: r in routes ==> r.start == source  \n    ensures forall r :: r in routes ==> r.distance > 0     \n    {\n        \n        routes := [];\n        \n        \n        \n        var destination := \"DefaultDest\";\n        routes := routes + [Route(source, destination, 1)];\n        \n        \n        \n    }\n    \n    predicate IsValidRoute(r: Route)\n    {\n        && r.start != \"\"\n        && r.end != \"\"\n        && r.distance > 0\n    }\n    \n    method FilterValidRoutes(input: seq<Route>) returns (output: seq<Route>)\n    ensures forall r :: r in output ==> IsValidRoute(r)  \n    ensures |output| <= |input|  \n    ensures forall r :: r in output ==> r in input  \n    {\n        var validRoutes: seq<Route> := [];\n        var i := 0;\n        \n        \n        while i < |input|\n        invariant 0 <= i <= |input|\n        invariant forall r :: r in validRoutes ==> IsValidRoute(r)\n        invariant |validRoutes| <= i\n        invariant forall r :: r in validRoutes ==> r in input\n        {\n            if IsValidRoute(input[i]) {\n                validRoutes := validRoutes + [input[i]];\n            }\n            i := i + 1;\n        }\n        \n        output := validRoutes;\n    }\n}", "name": "py2dfy_75", "id": 75}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method OddTuples<T>(input: seq<T>) returns (output: seq<T>)\n  \n{\n  \n  output := [];\n  \n  \n  var i := 0;\n  \n  while i < |input|\n    \n  {\n    if i % 2 == 0 {\n      output := output + [input[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var input := [4, 15, 4, 5, 2, 15, 7, 20];\n  var result := OddTuples(input);\n  print \"Result: \", result, \"\\n\";\n}", "output": "method OddTuples<T>(input: seq<T>) returns (output: seq<T>)\n  \n  ensures |output| == (|input| + 1) / 2  \n  ensures forall i :: 0 <= i < |output| ==> output[i] == input[2*i]  \n{\n  \n  output := [];\n  \n  \n  var i := 0;\n  \n  while i < |input|\n    \n    invariant 0 <= i <= |input|\n    invariant |output| == (i + 1) / 2\n    invariant forall k :: 0 <= k < |output| ==> output[k] == input[2*k]\n  {\n    if i % 2 == 0 {\n      output := output + [input[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var input := [4, 15, 4, 5, 2, 15, 7, 20];\n  var result := OddTuples(input);\n  print \"Result: \", result, \"\\n\";\n}", "name": "py2dfy_63", "id": 63}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Article {\n  var title: string\n  var slug: string\n  var authorId: int\n}\nclass Author {\n  var id: int\n  var name: string\n}\nclass LogEntry {\n  var path: string\n  var time: string\n  var status: string\n}\nclass NewsAnalyzer {\n  var articles: seq<Article>\n  var authors: seq<Author>\n  var logs: seq<LogEntry>\n  method GetTopArticles(limit: int) returns (result: seq<(string, int)>)\n  {\n    var viewCounts: map<string, int> := map[];\n    \n    var i := 0;\n    while i < |logs|\n    {\n      var path := logs[i].path;\n      var j := 0;\n      while j < |articles|\n      {\n        if \"/article/\" + articles[j].slug == path {\n          var title := articles[j].title;\n          viewCounts := viewCounts[title := if title in viewCounts then viewCounts[title] + 1 else 1];\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    result := [];\n  }\n  method GetAuthorViews() returns (result: seq<(string, int)>)\n  {\n    var authorViews: map<int, int> := map[];\n    result := [];\n  }\n  method GetErrorDays(errorThreshold: real) returns (result: seq<(string, real)>)\n  {\n    var dailyStats: map<string, (int, int)> := map[];\n    result := [];\n  }\n  method WriteResults(content: string) returns (success: bool)\n  {\n    success := true;\n  }\n}", "output": "class Article {\n  var title: string\n  var slug: string\n  var authorId: int\n}\nclass Author {\n  var id: int\n  var name: string\n}\nclass LogEntry {\n  var path: string\n  var time: string\n  var status: string\n}\nclass NewsAnalyzer {\n  var articles: seq<Article>\n  var authors: seq<Author>\n  var logs: seq<LogEntry>\n  method GetTopArticles(limit: int) returns (result: seq<(string, int)>)\n    requires limit > 0\n    requires |articles| > 0 && |logs| > 0\n    ensures |result| <= limit\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i].1 >= result[j].1\n  {\n    var viewCounts: map<string, int> := map[];\n    \n    var i := 0;\n    while i < |logs|\n      invariant 0 <= i <= |logs|\n      invariant forall title :: title in viewCounts ==> viewCounts[title] >= 1\n    {\n      var path := logs[i].path;\n      var j := 0;\n      while j < |articles|\n        invariant 0 <= j <= |articles|\n        invariant forall title :: title in viewCounts ==> viewCounts[title] >= 1\n      {\n        if \"/article/\" + articles[j].slug == path {\n          var title := articles[j].title;\n          viewCounts := viewCounts[title := if title in viewCounts then viewCounts[title] + 1 else 1];\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    result := [];\n  }\n  method GetAuthorViews() returns (result: seq<(string, int)>)\n    requires |articles| > 0 && |authors| > 0 && |logs| > 0\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i].1 >= result[j].1\n  {\n    var authorViews: map<int, int> := map[];\n    result := [];\n  }\n  method GetErrorDays(errorThreshold: real) returns (result: seq<(string, real)>)\n    requires errorThreshold > 0.0\n    requires |logs| > 0\n    ensures forall i :: 0 <= i < |result| ==> result[i].1 > errorThreshold\n  {\n    var dailyStats: map<string, (int, int)> := map[];\n    result := [];\n  }\n  method WriteResults(content: string) returns (success: bool)\n    ensures success ==> true\n  {\n    success := true;\n  }\n}", "name": "py2dfy_84", "id": 84}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Task = Task(id: int)\nclass Worker {\n    \n    var tasks: seq<Task>\n    \n    var numThreads: nat\n    \n    var running: bool\n    \n    \n    ghost var tasksProcessed: set<Task>\n    \n    \n    predicate Valid()\n    {\n        numThreads > 0 &&\n        |tasks| >= 0\n    }\n    \n    constructor(threadCount: nat)\n    {\n        numThreads := threadCount;\n        tasks := [];\n        running := true;\n        tasksProcessed := {};\n    }\n    \n    \n    method Post(task: Task)\n    {\n        tasks := tasks + [task];\n    }\n    \n    \n    method AcquireJob() returns (success: bool, task: Task)\n    {\n        if |tasks| > 0 && running {\n            task := tasks[0];\n            tasks := tasks[1..];\n            success := true;\n            tasksProcessed := tasksProcessed + {task};\n        } else {\n            task := Task(0);\n            success := false;\n        }\n    }\n    \n    \n    method Stop()\n    {\n        running := false;\n    }\n}", "output": "datatype Task = Task(id: int)\nclass Worker {\n    \n    var tasks: seq<Task>\n    \n    var numThreads: nat\n    \n    var running: bool\n    \n    \n    ghost var tasksProcessed: set<Task>\n    \n    \n    predicate Valid()\n    reads this\n    {\n        numThreads > 0 &&\n        |tasks| >= 0\n    }\n    \n    constructor(threadCount: nat)\n    requires threadCount > 0\n    ensures Valid()\n    ensures fresh(this)\n    ensures tasks == []\n    ensures numThreads == threadCount\n    ensures running == true\n    ensures tasksProcessed == {}\n    {\n        numThreads := threadCount;\n        tasks := [];\n        running := true;\n        tasksProcessed := {};\n    }\n    \n    \n    method Post(task: Task)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures |tasks| == |old(tasks)| + 1\n    ensures tasks[|tasks|-1] == task\n    ensures running == old(running)\n    {\n        tasks := tasks + [task];\n    }\n    \n    \n    method AcquireJob() returns (success: bool, task: Task)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures success ==> old(|tasks|) > 0\n    ensures !success ==> task == Task(0)\n    ensures |tasks| == if success then |old(tasks)| - 1 else |old(tasks)|\n    {\n        if |tasks| > 0 && running {\n            task := tasks[0];\n            tasks := tasks[1..];\n            success := true;\n            tasksProcessed := tasksProcessed + {task};\n        } else {\n            task := Task(0);\n            success := false;\n        }\n    }\n    \n    \n    method Stop()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures !running\n    ensures tasks == old(tasks)\n    {\n        running := false;\n    }\n}", "name": "py2dfy_21", "id": 21}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module MaintenanceCalculator {\n    \n    method FixedMaintenance(flatSqft: real) returns (result: real)\n    {\n        result := flatSqft * 300.0;\n    }\n    \n    method MaintenanceAmount(flatSqft: real, chargePerSqft: real) returns (result: real)\n    {\n        result := flatSqft * chargePerSqft;\n    }\n    \n    method VariableMaintenance(flatSqft: real, chargePerSqft: real) returns (result: real)\n                         (if flatSqft > 1500.0 then flatSqft else flatSqft * 3.0/4.0)\n        \n    {\n        var sqftSurcharge: real;\n        if flatSqft > 1500.0 {\n            sqftSurcharge := flatSqft;\n        } else {\n            sqftSurcharge := flatSqft * 3.0/4.0;\n        }\n        result := (flatSqft * chargePerSqft) + sqftSurcharge;\n    }\n}", "output": "module MaintenanceCalculator {\n    \n    method FixedMaintenance(flatSqft: real) returns (result: real)\n        requires flatSqft > 0.0  \n        ensures result == flatSqft * 300.0  \n    {\n        result := flatSqft * 300.0;\n    }\n    \n    method MaintenanceAmount(flatSqft: real, chargePerSqft: real) returns (result: real)\n        requires flatSqft > 0.0  \n        requires chargePerSqft > 0.0  \n        ensures result == flatSqft * chargePerSqft  \n    {\n        result := flatSqft * chargePerSqft;\n    }\n    \n    method VariableMaintenance(flatSqft: real, chargePerSqft: real) returns (result: real)\n        requires flatSqft > 0.0  \n        requires chargePerSqft > 0.0  \n        ensures result == (flatSqft * chargePerSqft) + \n                         (if flatSqft > 1500.0 then flatSqft else flatSqft * 3.0/4.0)\n        \n    {\n        var sqftSurcharge: real;\n        if flatSqft > 1500.0 {\n            sqftSurcharge := flatSqft;\n        } else {\n            sqftSurcharge := flatSqft * 3.0/4.0;\n        }\n        result := (flatSqft * chargePerSqft) + sqftSurcharge;\n    }\n}", "name": "py2dfy_29", "id": 29}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Point = Point(y: real, z: real)\ndatatype Rectangle = Rectangle(leftY: real, rightY: real, bottomZ: real, topZ: real)\ntype Polygon = seq<Point>\nclass GeometryHelpers {\n    \n    method CreateRectangle(leftY: real, rightY: real, bottomZ: real, topZ: real) returns (rect: Rectangle)\n    {\n        rect := Rectangle(leftY, rightY, bottomZ, topZ);\n    }\n    \n    method GetPolygonCorner(polygon: Polygon) returns (corners: Rectangle)\n    {\n        var minY := polygon[0].y;\n        var maxY := polygon[0].y;\n        var minZ := polygon[0].z;\n        var maxZ := polygon[0].z;\n        \n        var i := 1;\n        while i < |polygon|\n        {\n            if polygon[i].y < minY { minY := polygon[i].y; }\n            if polygon[i].y > maxY { maxY := polygon[i].y; }\n            if polygon[i].z < minZ { minZ := polygon[i].z; }\n            if polygon[i].z > maxZ { maxZ := polygon[i].z; }\n            i := i + 1;\n        }\n        corners := Rectangle(minY, maxY, minZ, maxZ);\n    }\n    \n    method MeasurePolygonsWidthAlongYAxis(polygons: seq<Polygon>) returns (intervals: seq<(real, real)>)\n    {\n        var result: seq<(real, real)> := [];\n        \n        var i := 0;\n        while i < |polygons|\n        {\n            var minY := polygons[i][0].y;\n            var maxY := polygons[i][0].y;\n            \n            var j := 1;\n            while j < |polygons[i]|\n            {\n                if polygons[i][j].y < minY { minY := polygons[i][j].y; }\n                if polygons[i][j].y > maxY { maxY := polygons[i][j].y; }\n                j := j + 1;\n            }\n            \n            result := result + [(minY, maxY)];\n            i := i + 1;\n        }\n        \n        intervals := result;\n    }\n}", "output": "datatype Point = Point(y: real, z: real)\ndatatype Rectangle = Rectangle(leftY: real, rightY: real, bottomZ: real, topZ: real)\ntype Polygon = seq<Point>\nclass GeometryHelpers {\n    \n    method CreateRectangle(leftY: real, rightY: real, bottomZ: real, topZ: real) returns (rect: Rectangle)\n        requires leftY <= rightY  \n        requires bottomZ <= topZ  \n        ensures rect.leftY == leftY && rect.rightY == rightY \n        ensures rect.bottomZ == bottomZ && rect.topZ == topZ\n    {\n        rect := Rectangle(leftY, rightY, bottomZ, topZ);\n    }\n    \n    method GetPolygonCorner(polygon: Polygon) returns (corners: Rectangle)\n        requires |polygon| >= 4  \n        ensures corners.leftY <= corners.rightY\n        ensures corners.bottomZ <= corners.topZ\n    {\n        var minY := polygon[0].y;\n        var maxY := polygon[0].y;\n        var minZ := polygon[0].z;\n        var maxZ := polygon[0].z;\n        \n        var i := 1;\n        while i < |polygon|\n            invariant 1 <= i <= |polygon|\n            invariant minY <= maxY\n            invariant minZ <= maxZ\n            invariant forall k :: 0 <= k < i ==> minY <= polygon[k].y <= maxY\n            invariant forall k :: 0 <= k < i ==> minZ <= polygon[k].z <= maxZ\n        {\n            if polygon[i].y < minY { minY := polygon[i].y; }\n            if polygon[i].y > maxY { maxY := polygon[i].y; }\n            if polygon[i].z < minZ { minZ := polygon[i].z; }\n            if polygon[i].z > maxZ { maxZ := polygon[i].z; }\n            i := i + 1;\n        }\n        corners := Rectangle(minY, maxY, minZ, maxZ);\n    }\n    \n    method MeasurePolygonsWidthAlongYAxis(polygons: seq<Polygon>) returns (intervals: seq<(real, real)>)\n        requires forall i :: 0 <= i < |polygons| ==> |polygons[i]| > 0\n        ensures |intervals| == |polygons|\n        ensures forall i :: 0 <= i < |intervals| ==> intervals[i].0 <= intervals[i].1\n    {\n        var result: seq<(real, real)> := [];\n        \n        var i := 0;\n        while i < |polygons|\n            invariant 0 <= i <= |polygons|\n            invariant |result| == i\n            invariant forall k :: 0 <= k < |result| ==> result[k].0 <= result[k].1\n        {\n            var minY := polygons[i][0].y;\n            var maxY := polygons[i][0].y;\n            \n            var j := 1;\n            while j < |polygons[i]|\n                invariant 1 <= j <= |polygons[i]|\n                invariant minY <= maxY\n            {\n                if polygons[i][j].y < minY { minY := polygons[i][j].y; }\n                if polygons[i][j].y > maxY { maxY := polygons[i][j].y; }\n                j := j + 1;\n            }\n            \n            result := result + [(minY, maxY)];\n            i := i + 1;\n        }\n        \n        intervals := result;\n    }\n}", "name": "py2dfy_57", "id": 57}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Image {\n  var width: int\n  var height: int \n  var pixels: array3<int>  \n  constructor(w: int, h: int)\n  {\n    width := w;\n    height := h;\n    pixels := new int[h, w, 3];\n  }\n}\ndatatype DatasetEntry = DatasetEntry(imagePath: string, labels: seq<real>)\nclass CartoonDataset {\n  var entries: seq<DatasetEntry>\n  var imageDir: string\n  \n  constructor(attrFile: string, imgDir: string)\n  {\n    var loadedData := LoadLabelsStatic(attrFile);\n    entries := loadedData;\n    imageDir := imgDir;\n  }\n  static method LoadLabelsStatic(filename: string) returns (data: seq<DatasetEntry>)\n  {\n    \n    var lines: seq<string> := [];\n    \n    if |lines| < 2 {\n      data := [];\n      return;\n    }\n    data := [];\n    var i := 2;  \n    \n    while i < |lines|\n                |data[j].labels| > 0  \n    {\n      var parts := SplitString(lines[i]);  \n      if |parts| > 1 {\n        var imgPath := parts[0];\n        var labelVals := ConvertToReals(parts[1..]);  \n        data := data + [DatasetEntry(imgPath, labelVals)];\n      }\n      i := i + 1;\n    }\n  }\n  method GetItem(idx: int) returns (entry: DatasetEntry)\n  {\n    entry := entries[idx];\n  }\n  method Length() returns (len: int)\n  {\n    len := |entries|;\n  }\n}\nmethod {:axiom} SplitString(s: string) returns (parts: seq<string>)\nmethod {:axiom} ConvertToReals(strings: seq<string>) returns (reals: seq<real>)", "output": "class Image {\n  var width: int\n  var height: int \n  var pixels: array3<int>  \n  constructor(w: int, h: int)\n    requires w > 0 && h > 0\n    ensures width == w && height == h\n    ensures fresh(pixels)\n    ensures pixels.Length0 == h && pixels.Length1 == w && pixels.Length2 == 3\n  {\n    width := w;\n    height := h;\n    pixels := new int[h, w, 3];\n  }\n}\ndatatype DatasetEntry = DatasetEntry(imagePath: string, labels: seq<real>)\nclass CartoonDataset {\n  var entries: seq<DatasetEntry>\n  var imageDir: string\n  \n  constructor(attrFile: string, imgDir: string)\n    requires attrFile != \"\"\n    requires imgDir != \"\"\n    ensures imageDir == imgDir\n    ensures |entries| >= 0\n  {\n    var loadedData := LoadLabelsStatic(attrFile);\n    entries := loadedData;\n    imageDir := imgDir;\n  }\n  static method LoadLabelsStatic(filename: string) returns (data: seq<DatasetEntry>)\n    requires filename != \"\"\n    ensures |data| >= 0\n  {\n    \n    var lines: seq<string> := [];\n    \n    if |lines| < 2 {\n      data := [];\n      return;\n    }\n    data := [];\n    var i := 2;  \n    \n    while i < |lines|\n      invariant 2 <= i <= |lines|\n      invariant |data| == i - 2  \n      invariant forall j :: 0 <= j < |data| ==> \n                |data[j].labels| > 0  \n    {\n      var parts := SplitString(lines[i]);  \n      if |parts| > 1 {\n        var imgPath := parts[0];\n        var labelVals := ConvertToReals(parts[1..]);  \n        data := data + [DatasetEntry(imgPath, labelVals)];\n      }\n      i := i + 1;\n    }\n  }\n  method GetItem(idx: int) returns (entry: DatasetEntry)\n    requires 0 <= idx < |entries|\n    ensures entry == entries[idx]\n  {\n    entry := entries[idx];\n  }\n  method Length() returns (len: int)\n    ensures len == |entries|\n  {\n    len := |entries|;\n  }\n}\nmethod {:axiom} SplitString(s: string) returns (parts: seq<string>)\n  ensures |parts| > 0\nmethod {:axiom} ConvertToReals(strings: seq<string>) returns (reals: seq<real>)\n  requires |strings| > 0\n  ensures |reals| == |strings|", "name": "py2dfy_65", "id": 65}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module PythonUtils {\n  \n  class Counter {\n    var value: int\n    constructor()\n    {\n      value := 0;\n    }\n    \n    method increment() returns (newValue: int)\n    {\n      value := value + 1;\n      newValue := value;\n    }\n  }\n  \n  const INDENT: string := \"  \"\n  const INDENT_TWO: string := \"    \"  \n  const INDENT_THREE: string := \"      \"  \n  \n  method escapeString(s: string) returns (result: string)\n  {\n    \n    var escaped := \"\\\"\" + s; \n    result := escaped + \"\\\"\";\n  }\n}", "output": "module PythonUtils {\n  \n  class Counter {\n    var value: int\n    constructor()\n    ensures value == 0\n    {\n      value := 0;\n    }\n    \n    method increment() returns (newValue: int)\n    modifies this\n    ensures value == old(value) + 1  \n    ensures newValue == value        \n    ensures value > old(value)       \n    {\n      value := value + 1;\n      newValue := value;\n    }\n  }\n  \n  const INDENT: string := \"  \"\n  const INDENT_TWO: string := \"    \"  \n  const INDENT_THREE: string := \"      \"  \n  \n  method escapeString(s: string) returns (result: string)\n  ensures |result| >= |s|  \n  ensures |result| > 0     \n  ensures result[0] == '\"' && result[|result|-1] == '\"'  \n  {\n    \n    var escaped := \"\\\"\" + s; \n    result := escaped + \"\\\"\";\n  }\n}", "name": "py2dfy_77", "id": 77}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "const factorials := [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\nfunction CharToDigit(c: char): (d: nat)\n{\n  (c as int) - ('0' as int)\n}\nmethod SumOfDigitFactorials(n: nat) returns (sum: nat)\n{\n  var nStr := NatToString(n);\n  sum := 0;\n  \n  for i := 0 to |nStr|\n  {\n    var digit := CharToDigit(nStr[i]);\n    sum := sum + factorials[digit];\n  }\n}\nfunction NatToString(n: nat): string\n{\n  if n < 10 then [(n as char + '0')]\n  else NatToString(n / 10) + [((n % 10) as char + '0')]\n}\nmethod FindSpecialNumbers(limit: nat) returns (result: seq<nat>)\n{\n  var numbers: seq<nat> := [];\n  \n  var i := 3;\n  while i < limit\n  {\n    var sum := SumOfDigitFactorials(i);\n    if sum == i {\n      numbers := numbers + [i];\n    }\n    i := i + 1;\n  }\n  result := numbers;\n}\nmethod SumSequence(numbers: seq<nat>) returns (sum: nat)\n{\n  sum := 0;\n  var i := 0;\n  while i < |numbers|\n  {\n    sum := sum + numbers[i];\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var specialNumbers := FindSpecialNumbers(3000000);\n  var result := SumSequence(specialNumbers);\n  print \"Sum of special numbers: \", result, \"\\n\";\n}", "output": "const factorials := [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\nfunction CharToDigit(c: char): (d: nat)\n  requires '0' <= c <= '9'\n  ensures 0 <= d <= 9\n  ensures d == (c as int) - ('0' as int)\n{\n  (c as int) - ('0' as int)\n}\nmethod SumOfDigitFactorials(n: nat) returns (sum: nat)\n  requires n > 0\n  ensures sum >= 0\n{\n  var nStr := NatToString(n);\n  sum := 0;\n  \n  for i := 0 to |nStr|\n    invariant 0 <= i <= |nStr|\n    invariant sum >= 0\n    invariant forall j :: 0 <= j < i ==> '0' <= nStr[j] <= '9'\n  {\n    var digit := CharToDigit(nStr[i]);\n    sum := sum + factorials[digit];\n  }\n}\nfunction NatToString(n: nat): string\n  ensures |NatToString(n)| > 0\n  ensures forall i :: 0 <= i < |NatToString(n)| ==> '0' <= NatToString(n)[i] <= '9'\n{\n  if n < 10 then [(n as char + '0')]\n  else NatToString(n / 10) + [((n % 10) as char + '0')]\n}\nmethod FindSpecialNumbers(limit: nat) returns (result: seq<nat>)\n  requires limit >= 3\n  ensures forall x :: x in result ==> x > 0 && x < limit\n{\n  var numbers: seq<nat> := [];\n  \n  var i := 3;\n  while i < limit\n    invariant 3 <= i <= limit\n    invariant forall x :: x in numbers ==> 3 <= x < i\n  {\n    var sum := SumOfDigitFactorials(i);\n    if sum == i {\n      numbers := numbers + [i];\n    }\n    i := i + 1;\n  }\n  result := numbers;\n}\nmethod SumSequence(numbers: seq<nat>) returns (sum: nat)\n  ensures sum >= 0\n{\n  sum := 0;\n  var i := 0;\n  while i < |numbers|\n    invariant 0 <= i <= |numbers|\n    invariant sum >= 0\n  {\n    sum := sum + numbers[i];\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var specialNumbers := FindSpecialNumbers(3000000);\n  var result := SumSequence(specialNumbers);\n  print \"Sum of special numbers: \", result, \"\\n\";\n}", "name": "py2dfy_52", "id": 52}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class OpenText {\n  var path: string\n  var listname: seq<string>\n  constructor(path: string)\n  {\n    this.path := path;\n    this.listname := [];\n  }\n  method txtlist() returns (result: seq<string>)\n  {\n    var lines := ReadLines(this.path);\n    var tempList: seq<string> := [];\n    var i := 0;\n    while i < |lines|\n    {\n      var line := lines[i];\n      var trimmedLine := Trim(line);\n      if trimmedLine != \"\" {\n        tempList := tempList + [trimmedLine];\n      }\n      i := i + 1;\n    }\n    this.listname := tempList;\n    result := this.listname;\n  }\n  method total() returns (count: nat)\n  {\n    count := |this.listname|;\n  }\n  method ReadLines(filePath: string) returns (lines: seq<string>)\n  {\n    lines := [\"line1\", \"line2\", \"  \", \"line3\", \"\"];\n  }\n  function Trim(s: string): string\n  {\n    if s == \"  \" then \"\" else s\n  }\n}\nclass Element {\n  var name: string\n  \n  constructor(name: string)\n  {\n    this.name := name;\n  }\n  \n  method GetAttribute(attributeName: string) returns (value: string)\n  {\n    return this.name;\n  }\n}\nclass Elements {\n  var elements: seq<Element>\n  var listname: seq<string>\n  \n  constructor(elements: seq<Element>)\n  {\n    this.elements := elements;\n    this.listname := [];\n  }\n  \n  method elementslist() returns (result: seq<string>)\n  {\n    this.listname := [];\n    var i := 0;\n    while i < |this.elements|\n    {\n      var element := this.elements[i];\n      var name := element.GetAttribute(\"name\");\n      this.listname := this.listname + [name];\n      i := i + 1;\n    }\n    result := this.listname;\n  }\n}", "output": "class OpenText {\n  var path: string\n  var listname: seq<string>\n  constructor(path: string)\n    requires path != \"\"\n    ensures this.path == path\n  {\n    this.path := path;\n    this.listname := [];\n  }\n  method txtlist() returns (result: seq<string>)\n    modifies this\n    ensures forall i :: 0 <= i < |result| ==> result[i] != \"\"\n    ensures |result| <= |old(this.listname)| + 5 \n  {\n    var lines := ReadLines(this.path);\n    var tempList: seq<string> := [];\n    var i := 0;\n    while i < |lines|\n      invariant 0 <= i <= |lines|\n      invariant |tempList| <= i\n      invariant |tempList| <= |old(this.listname)| + 5\n      invariant forall j :: 0 <= j < |tempList| ==> tempList[j] != \"\"\n    {\n      var line := lines[i];\n      var trimmedLine := Trim(line);\n      if trimmedLine != \"\" {\n        tempList := tempList + [trimmedLine];\n      }\n      i := i + 1;\n    }\n    this.listname := tempList;\n    result := this.listname;\n  }\n  method total() returns (count: nat)\n    ensures count == |this.listname|\n  {\n    count := |this.listname|;\n  }\n  method ReadLines(filePath: string) returns (lines: seq<string>)\n    ensures |lines| == 5\n  {\n    lines := [\"line1\", \"line2\", \"  \", \"line3\", \"\"];\n  }\n  function Trim(s: string): string\n  {\n    if s == \"  \" then \"\" else s\n  }\n}\nclass Element {\n  var name: string\n  \n  constructor(name: string)\n    ensures this.name == name\n  {\n    this.name := name;\n  }\n  \n  method GetAttribute(attributeName: string) returns (value: string)\n    requires attributeName == \"name\"\n    ensures value == this.name\n  {\n    return this.name;\n  }\n}\nclass Elements {\n  var elements: seq<Element>\n  var listname: seq<string>\n  \n  constructor(elements: seq<Element>)\n    ensures this.elements == elements\n  {\n    this.elements := elements;\n    this.listname := [];\n  }\n  \n  method elementslist() returns (result: seq<string>)\n    modifies this\n    ensures |result| == |this.elements|\n  {\n    this.listname := [];\n    var i := 0;\n    while i < |this.elements|\n      invariant 0 <= i <= |this.elements|\n      invariant |this.listname| == i\n    {\n      var element := this.elements[i];\n      var name := element.GetAttribute(\"name\");\n      this.listname := this.listname + [name];\n      i := i + 1;\n    }\n    result := this.listname;\n  }\n}", "name": "py2dfy_61", "id": 61}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class NameGenerator {\n  \n  constructor()\n  {\n    \n  }\n  \n  predicate Valid()\n  {\n    \n    true  \n  }\n  \n  method generate() returns (name: string)\n  {\n    \n    name := \"DefaultName\";\n  }\n}\nmethod TestNameGenerator()\n{\n  var generator := new NameGenerator();\n  var generatedName := generator.generate();\n}", "output": "class NameGenerator {\n  \n  constructor()\n    ensures Valid()\n  {\n    \n  }\n  \n  predicate Valid()\n    reads this\n  {\n    \n    true  \n  }\n  \n  method generate() returns (name: string)\n    requires Valid()\n    ensures Valid()\n    ensures |name| > 0  \n  {\n    \n    name := \"DefaultName\";\n  }\n}\nmethod TestNameGenerator()\n{\n  var generator := new NameGenerator();\n  assert generator.Valid();\n  var generatedName := generator.generate();\n  assert |generatedName| > 0;\n}", "name": "py2dfy_54", "id": 54}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module DataProcessing {\n    datatype JsonData = JsonData(populations: seq<Population>)\n    datatype Population = Population(chromosomes: seq<Chromosome>)\n    datatype Chromosome = Chromosome(objective: real)\n    method ReadData() returns (data: JsonData)\n    {\n        var pop1 := Population([Chromosome(1.0), Chromosome(2.0)]);\n        var pop2 := Population([Chromosome(3.0), Chromosome(4.0)]);\n        data := JsonData([pop1, pop2]);\n    }\n    method GetObjectives(data: JsonData) returns (objectives: seq<real>)\n                    objectives[i] == data.populations[i].chromosomes[0].objective\n    {\n        objectives := [];\n        var i := 0;\n        while i < |data.populations|\n                        objectives[j] == data.populations[j].chromosomes[0].objective\n        {\n            objectives := objectives + [data.populations[i].chromosomes[0].objective];\n            i := i + 1;\n        }\n    }\n    method GetNewValues(values: seq<real>) returns (newValues: seq<real>)\n    {\n        newValues := [values[0]];\n        var i := 1;\n        var currentMax := values[0];\n        \n        while i < |values|\n        {\n            if values[i] > currentMax {\n                currentMax := values[i];\n            }\n            newValues := newValues + [currentMax];\n            i := i + 1;\n        }\n    }\n    method Main()\n    {\n        var data := ReadData();\n        var objectives := GetObjectives(data);\n        var newValues := GetNewValues(objectives);\n        \n        print \"Processed data: \", newValues;\n    }\n}", "output": "module DataProcessing {\n    datatype JsonData = JsonData(populations: seq<Population>)\n    datatype Population = Population(chromosomes: seq<Chromosome>)\n    datatype Chromosome = Chromosome(objective: real)\n    method ReadData() returns (data: JsonData)\n        ensures data.populations != []\n        ensures forall p :: p in data.populations ==> p.chromosomes != []\n    {\n        var pop1 := Population([Chromosome(1.0), Chromosome(2.0)]);\n        var pop2 := Population([Chromosome(3.0), Chromosome(4.0)]);\n        data := JsonData([pop1, pop2]);\n    }\n    method GetObjectives(data: JsonData) returns (objectives: seq<real>)\n        requires data.populations != []\n        requires forall p :: p in data.populations ==> p.chromosomes != []\n        ensures |objectives| == |data.populations|\n        ensures forall i :: 0 <= i < |objectives| ==>\n                    objectives[i] == data.populations[i].chromosomes[0].objective\n    {\n        objectives := [];\n        var i := 0;\n        while i < |data.populations|\n            invariant 0 <= i <= |data.populations|\n            invariant |objectives| == i\n            invariant forall j :: 0 <= j < i ==>\n                        objectives[j] == data.populations[j].chromosomes[0].objective\n        {\n            objectives := objectives + [data.populations[i].chromosomes[0].objective];\n            i := i + 1;\n        }\n    }\n    method GetNewValues(values: seq<real>) returns (newValues: seq<real>)\n        requires |values| > 0\n        ensures |newValues| == |values|\n        ensures forall i :: 0 <= i < |newValues| ==> newValues[i] >= values[i]\n        ensures forall i :: 0 < i < |newValues| ==> newValues[i] >= newValues[i-1]\n    {\n        newValues := [values[0]];\n        var i := 1;\n        var currentMax := values[0];\n        \n        while i < |values|\n            invariant 1 <= i <= |values|\n            invariant |newValues| == i\n            invariant forall j :: 0 <= j < i ==> newValues[j] >= values[j]\n            invariant forall j :: 0 < j < i ==> newValues[j] >= newValues[j-1]\n            invariant currentMax == newValues[i-1]\n        {\n            if values[i] > currentMax {\n                currentMax := values[i];\n            }\n            newValues := newValues + [currentMax];\n            i := i + 1;\n        }\n    }\n    method Main()\n    {\n        var data := ReadData();\n        var objectives := GetObjectives(data);\n        var newValues := GetNewValues(objectives);\n        \n        print \"Processed data: \", newValues;\n    }\n}", "name": "py2dfy_93", "id": 93}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Player = Player(id: int, nick: string)\ndatatype Result = Result(id: int, player_id: int, ladder_id: int, date: int)\ndatatype Match = Match(id: int, result_id: int)\ndatatype Ladder = Ladder(id: int, name: string)\nclass Session {\n  \n  var isOpen: bool\n  \n  constructor()\n  {\n    isOpen := true;\n  }\n  method Close()\n  {\n    isOpen := false;\n  }\n}\nclass PlayerManager {\n  \n  method GetPlayerDetails(\n    session: Session, \n    playerName: string\n  ) returns (\n    player: Player,\n    recentMatches: seq<Match>,\n    positions: map<int, int>,\n    played: map<int, int>\n  )\n  {\n    \n    \n    player := Player(0, playerName);  \n    recentMatches := [];\n    positions := map[];\n    played := map[];\n  }\n  \n  method GetPlayerList(\n    session: Session,\n    ladderId: int,\n    orderBy: string,\n    ascending: bool,\n    limit: int,\n    offset: int\n  ) returns (\n    players: seq<(Player, int)>  \n  )\n      (orderBy == \"nick\" && ascending ==> players[i].0.nick <= players[j].0.nick) &&\n      (orderBy == \"id\" && ascending ==> players[i].0.id <= players[j].0.id) &&\n      (orderBy == \"played\" && ascending ==> players[i].1 <= players[j].1)\n  {\n    \n    players := [];  \n  }\n}\nmethod GetSingleField<T>(\n  fieldName: string,\n  defaultValue: T\n) returns (value: T)\n{\n  return defaultValue;\n}", "output": "datatype Player = Player(id: int, nick: string)\ndatatype Result = Result(id: int, player_id: int, ladder_id: int, date: int)\ndatatype Match = Match(id: int, result_id: int)\ndatatype Ladder = Ladder(id: int, name: string)\nclass Session {\n  \n  var isOpen: bool\n  \n  constructor()\n    ensures isOpen\n  {\n    isOpen := true;\n  }\n  method Close()\n    requires isOpen\n    modifies this\n    ensures !isOpen\n  {\n    isOpen := false;\n  }\n}\nclass PlayerManager {\n  \n  method GetPlayerDetails(\n    session: Session, \n    playerName: string\n  ) returns (\n    player: Player,\n    recentMatches: seq<Match>,\n    positions: map<int, int>,\n    played: map<int, int>\n  )\n    requires session.isOpen\n    requires playerName != \"\"\n    ensures session.isOpen\n    ensures |recentMatches| <= 5  \n    ensures forall l :: l in positions.Keys ==> l in played.Keys  \n  {\n    \n    \n    player := Player(0, playerName);  \n    recentMatches := [];\n    positions := map[];\n    played := map[];\n  }\n  \n  method GetPlayerList(\n    session: Session,\n    ladderId: int,\n    orderBy: string,\n    ascending: bool,\n    limit: int,\n    offset: int\n  ) returns (\n    players: seq<(Player, int)>  \n  )\n    requires session.isOpen\n    requires limit > 0\n    requires offset >= 0\n    requires orderBy in {\"nick\", \"id\", \"played\"}\n    ensures session.isOpen\n    ensures |players| <= limit\n    ensures forall i, j :: 0 <= i < j < |players| ==>\n      (orderBy == \"nick\" && ascending ==> players[i].0.nick <= players[j].0.nick) &&\n      (orderBy == \"id\" && ascending ==> players[i].0.id <= players[j].0.id) &&\n      (orderBy == \"played\" && ascending ==> players[i].1 <= players[j].1)\n  {\n    \n    players := [];  \n  }\n}\nmethod GetSingleField<T>(\n  fieldName: string,\n  defaultValue: T\n) returns (value: T)\n  ensures value == defaultValue  \n{\n  return defaultValue;\n}", "name": "py2dfy_38", "id": 38}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module URLRouter {\n    datatype URL = URL(path: seq<string>)\n    datatype Handler = AdminHandler | ViewHandler | BlogHandler | NotFoundHandler\n    method Route(url: URL) returns (handler: Handler)\n    {\n        if url.path == [\"admin\"] {\n            return AdminHandler;\n        } else if url.path == [\"hello\"] || (|url.path| == 2 && url.path[0] == \"hello\" && IsNumeric(url.path[1])) || url.path == [\"ifor\"] {\n            return ViewHandler;\n        } else if url.path == [\"blog\"] {\n            return BlogHandler;\n        } else {\n            return NotFoundHandler;\n        }\n    }\n    predicate IsNumeric(s: string)\n    {\n        |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    }\n    method Main()\n    {\n        var url1 := URL([\"admin\"]);\n        var handler1 := Route(url1);\n        var url2 := URL([\"hello\", \"2023\"]);\n        var handler2 := Route(url2);\n        var url3 := URL([\"blog\"]);\n        var handler3 := Route(url3);\n    }\n}", "output": "module URLRouter {\n    datatype URL = URL(path: seq<string>)\n    datatype Handler = AdminHandler | ViewHandler | BlogHandler | NotFoundHandler\n    method Route(url: URL) returns (handler: Handler)\n        ensures handler == AdminHandler ==> url.path == [\"admin\"]\n        ensures handler == ViewHandler ==> (url.path == [\"hello\"] || (|url.path| == 2 && url.path[0] == \"hello\" && IsNumeric(url.path[1])) || url.path == [\"ifor\"])\n        ensures handler == BlogHandler ==> url.path == [\"blog\"]\n        ensures url.path == [\"admin\"] ==> handler == AdminHandler\n        ensures (url.path == [\"hello\"] || (|url.path| == 2 && url.path[0] == \"hello\" && IsNumeric(url.path[1])) || url.path == [\"ifor\"]) ==> handler == ViewHandler\n        ensures url.path == [\"blog\"] ==> handler == BlogHandler\n    {\n        if url.path == [\"admin\"] {\n            return AdminHandler;\n        } else if url.path == [\"hello\"] || (|url.path| == 2 && url.path[0] == \"hello\" && IsNumeric(url.path[1])) || url.path == [\"ifor\"] {\n            return ViewHandler;\n        } else if url.path == [\"blog\"] {\n            return BlogHandler;\n        } else {\n            return NotFoundHandler;\n        }\n    }\n    predicate IsNumeric(s: string)\n        ensures IsNumeric(s) ==> |s| > 0\n    {\n        |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    }\n    method Main()\n    {\n        var url1 := URL([\"admin\"]);\n        var handler1 := Route(url1);\n        assert handler1 == AdminHandler;\n        var url2 := URL([\"hello\", \"2023\"]);\n        var handler2 := Route(url2);\n        assert handler2 == ViewHandler;\n        var url3 := URL([\"blog\"]);\n        var handler3 := Route(url3);\n        assert handler3 == BlogHandler;\n    }\n}", "name": "py2dfy_81", "id": 81}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\nclass Tweet {\n  \n  var text: string\n  var authorEmail: string\n  var createdAt: int  \n  var publishedAt: Option<int>  \n  var state: string\n  var comments: seq<Comment>  \n  \n  \n  static const VALID_STATES: set<string> := {\"pending\", \"published\", \"rejected\"}\n  \n  \n  predicate Valid()\n  {\n    \n    |text| <= 140 &&\n    \n    |authorEmail| <= 200 &&\n    \n    state in VALID_STATES &&\n    \n    createdAt >= 0 &&\n    \n    (publishedAt.Some? ==> publishedAt.value >= createdAt)\n  }\n  \n  \n  constructor(txt: string, email: string)\n  {\n    text := txt;\n    authorEmail := email;\n    createdAt := 0;  \n    publishedAt := None;\n    state := \"pending\";\n    comments := [];\n  }\n  \n  \n  method Approve()\n  {\n    state := \"published\";\n    publishedAt := Some(createdAt + 1);  \n  }\n  \n  \n  method Reject()\n  {\n    state := \"rejected\";\n  }\n  \n  \n  method AddComment(commentText: string) returns (comment: Comment)\n  {\n    comment := new Comment(commentText, this.createdAt + 1);\n    comments := comments + [comment];\n  }\n}\nclass Comment {\n  var text: string\n  var createdAt: int\n  \n  predicate Valid()\n  {\n    |text| <= 300 &&\n    createdAt >= 0\n  }\n  \n  constructor(txt: string, timestamp: int)\n  {\n    text := txt;\n    createdAt := timestamp;\n  }\n}", "output": "datatype Option<T> = None | Some(value: T)\nclass Tweet {\n  \n  var text: string\n  var authorEmail: string\n  var createdAt: int  \n  var publishedAt: Option<int>  \n  var state: string\n  var comments: seq<Comment>  \n  \n  \n  static const VALID_STATES: set<string> := {\"pending\", \"published\", \"rejected\"}\n  \n  \n  predicate Valid()\n    reads this\n  {\n    \n    |text| <= 140 &&\n    \n    |authorEmail| <= 200 &&\n    \n    state in VALID_STATES &&\n    \n    createdAt >= 0 &&\n    \n    (publishedAt.Some? ==> publishedAt.value >= createdAt)\n  }\n  \n  \n  constructor(txt: string, email: string)\n    requires |txt| <= 140 && |email| <= 200\n    ensures Valid()\n    ensures text == txt\n    ensures authorEmail == email\n    ensures state == \"pending\"\n    ensures fresh(this)\n  {\n    text := txt;\n    authorEmail := email;\n    createdAt := 0;  \n    publishedAt := None;\n    state := \"pending\";\n    comments := [];\n  }\n  \n  \n  method Approve()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures state == \"published\"\n    ensures publishedAt.Some?\n    ensures old(text) == text\n    ensures old(authorEmail) == authorEmail\n  {\n    state := \"published\";\n    publishedAt := Some(createdAt + 1);  \n  }\n  \n  \n  method Reject()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures state == \"rejected\"\n    ensures old(text) == text\n    ensures old(authorEmail) == authorEmail\n  {\n    state := \"rejected\";\n  }\n  \n  \n  method AddComment(commentText: string) returns (comment: Comment)\n    requires Valid()\n    requires |commentText| <= 300\n    modifies this\n    ensures Valid()\n    ensures fresh(comment)\n    ensures comment.text == commentText\n    ensures comment.createdAt >= this.createdAt\n    ensures comments == old(comments) + [comment]\n  {\n    comment := new Comment(commentText, this.createdAt + 1);\n    comments := comments + [comment];\n  }\n}\nclass Comment {\n  var text: string\n  var createdAt: int\n  \n  predicate Valid()\n    reads this\n  {\n    |text| <= 300 &&\n    createdAt >= 0\n  }\n  \n  constructor(txt: string, timestamp: int)\n    requires |txt| <= 300\n    requires timestamp >= 0\n    ensures Valid()\n    ensures text == txt\n    ensures createdAt == timestamp\n    ensures fresh(this)\n  {\n    text := txt;\n    createdAt := timestamp;\n  }\n}", "name": "py2dfy_59", "id": 59}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DataPoint {\n  var time: real\n  var gain: real\n  constructor(t: real, g: real)\n  {\n    time := t;\n    gain := g;\n  }\n}\nclass DataBuffer {\n  var points: seq<DataPoint>\n  const MAX_SIZE: int\n  constructor(maxSize: int)\n  {\n    MAX_SIZE := maxSize;\n    points := [];\n  }\n  method AddPoint(time: real, gain: real) returns (success: bool)\n  {\n    if |points| < MAX_SIZE {\n      var newPoint := new DataPoint(time, gain);\n      points := points + [newPoint];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method GetPoints() returns (times: seq<real>, gains: seq<real>)\n      times[i] == points[i].time && gains[i] == points[i].gain\n  {\n    times := [];\n    gains := [];\n    var i := 0;\n    \n    while i < |points|\n        times[k] == points[k].time && gains[k] == points[k].gain\n    {\n      times := times + [points[i].time];\n      gains := gains + [points[i].gain];\n      i := i + 1;\n    }\n  }\n  method Clear()\n  {\n    points := [];\n  }\n}\nmethod Main()\n{\n  var buffer := new DataBuffer(50);\n  var success1 := buffer.AddPoint(0.1, 0.5);\n  var success2 := buffer.AddPoint(0.2, 0.7);\n  var times, gains := buffer.GetPoints();\n}", "output": "class DataPoint {\n  var time: real\n  var gain: real\n  constructor(t: real, g: real)\n    ensures time == t\n    ensures gain == g\n  {\n    time := t;\n    gain := g;\n  }\n}\nclass DataBuffer {\n  var points: seq<DataPoint>\n  const MAX_SIZE: int\n  constructor(maxSize: int)\n    requires maxSize > 0\n    ensures MAX_SIZE == maxSize\n    ensures |points| == 0\n  {\n    MAX_SIZE := maxSize;\n    points := [];\n  }\n  method AddPoint(time: real, gain: real) returns (success: bool)\n    requires 0.0 <= gain <= 1.0\n    requires time >= 0.0\n    modifies this\n    ensures success <==> (old(|points|) < MAX_SIZE)\n    ensures success ==> |points| == old(|points|) + 1\n    ensures !success ==> points == old(points)\n    ensures success ==> fresh(points[|points|-1])\n    ensures success ==> points == old(points) + [points[|points|-1]]\n    ensures success ==> points[|points|-1].time == time\n    ensures success ==> points[|points|-1].gain == gain\n  {\n    if |points| < MAX_SIZE {\n      var newPoint := new DataPoint(time, gain);\n      points := points + [newPoint];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method GetPoints() returns (times: seq<real>, gains: seq<real>)\n    ensures |times| == |gains| == |points|\n    ensures forall i :: 0 <= i < |points| ==>\n      times[i] == points[i].time && gains[i] == points[i].gain\n  {\n    times := [];\n    gains := [];\n    var i := 0;\n    \n    while i < |points|\n      invariant 0 <= i <= |points|\n      invariant |times| == |gains| == i\n      invariant forall k :: 0 <= k < i ==>\n        times[k] == points[k].time && gains[k] == points[k].gain\n    {\n      times := times + [points[i].time];\n      gains := gains + [points[i].gain];\n      i := i + 1;\n    }\n  }\n  method Clear()\n    modifies this\n    ensures |points| == 0\n  {\n    points := [];\n  }\n}\nmethod Main()\n{\n  var buffer := new DataBuffer(50);\n  var success1 := buffer.AddPoint(0.1, 0.5);\n  var success2 := buffer.AddPoint(0.2, 0.7);\n  var times, gains := buffer.GetPoints();\n}", "name": "py2dfy_30", "id": 30}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Version = Version(major: nat, minor: nat, patch: nat)\nclass PackageMetadata {\n    \n    var name: string\n    var version: Version\n    var description: string\n    var longDescription: string\n    var author: string\n    var authorEmail: string\n    var url: string\n    var packages: seq<string>\n    var license: string\n    var classifiers: seq<string>\n    \n    predicate Valid()\n    {\n        \n        |name| > 0 &&\n        |description| > 0 &&\n        |author| > 0 &&\n        |packages| > 0 &&\n        |license| > 0\n    }\n    \n    constructor Init(\n        pkgName: string, \n        ver: Version,\n        desc: string,\n        longDesc: string,\n        auth: string,\n        email: string,\n        pkgUrl: string,\n        pkgs: seq<string>,\n        lic: string,\n        cls: seq<string>\n    )\n    {\n        name := pkgName;\n        version := ver;\n        description := desc;\n        longDescription := longDesc;\n        author := auth;\n        authorEmail := email;\n        url := pkgUrl;\n        packages := pkgs;\n        license := lic;\n        classifiers := cls;\n    }\n    \n    method ValidatePythonVersions(versions: seq<string>) returns (isValid: bool)\n        v == \"2.6\" || v == \"2.7\" \n    {\n        isValid := true;\n        var i := 0;\n        while i < |versions|\n            versions[k] == \"2.6\" || versions[k] == \"2.7\"\n        {\n            if versions[i] != \"2.6\" && versions[i] != \"2.7\" {\n                isValid := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method IsDjangoPackage() returns (isDjango: bool)\n    {\n        isDjango := false;\n        var i := 0;\n        while i < |classifiers|\n            classifiers[k] != \"Framework :: Django\"\n            classifiers[k] == \"Framework :: Django\"\n        {\n            if classifiers[i] == \"Framework :: Django\" {\n                isDjango := true;\n                return;\n            }\n            i := i + 1;\n        }\n        return;\n    }\n}", "output": "datatype Version = Version(major: nat, minor: nat, patch: nat)\nclass PackageMetadata {\n    \n    var name: string\n    var version: Version\n    var description: string\n    var longDescription: string\n    var author: string\n    var authorEmail: string\n    var url: string\n    var packages: seq<string>\n    var license: string\n    var classifiers: seq<string>\n    \n    predicate Valid()\n    reads this\n    {\n        \n        |name| > 0 &&\n        |description| > 0 &&\n        |author| > 0 &&\n        |packages| > 0 &&\n        |license| > 0\n    }\n    \n    constructor Init(\n        pkgName: string, \n        ver: Version,\n        desc: string,\n        longDesc: string,\n        auth: string,\n        email: string,\n        pkgUrl: string,\n        pkgs: seq<string>,\n        lic: string,\n        cls: seq<string>\n    )\n    requires |pkgName| > 0 && |desc| > 0 && |auth| > 0 && |pkgs| > 0 && |lic| > 0\n    ensures Valid()\n    ensures name == pkgName && version == ver && description == desc\n    ensures longDescription == longDesc && author == auth\n    ensures authorEmail == email && url == pkgUrl\n    ensures packages == pkgs && license == lic && classifiers == cls\n    {\n        name := pkgName;\n        version := ver;\n        description := desc;\n        longDescription := longDesc;\n        author := auth;\n        authorEmail := email;\n        url := pkgUrl;\n        packages := pkgs;\n        license := lic;\n        classifiers := cls;\n    }\n    \n    method ValidatePythonVersions(versions: seq<string>) returns (isValid: bool)\n    requires Valid()\n    ensures isValid ==> forall v | v in versions :: \n        v == \"2.6\" || v == \"2.7\" \n    {\n        isValid := true;\n        var i := 0;\n        while i < |versions|\n        invariant 0 <= i <= |versions|\n        invariant isValid ==> forall k :: 0 <= k < i ==>\n            versions[k] == \"2.6\" || versions[k] == \"2.7\"\n        {\n            if versions[i] != \"2.6\" && versions[i] != \"2.7\" {\n                isValid := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method IsDjangoPackage() returns (isDjango: bool)\n    requires Valid()\n    ensures isDjango ==> exists c | c in classifiers :: c == \"Framework :: Django\"\n    ensures !isDjango ==> forall c | c in classifiers :: c != \"Framework :: Django\"\n    {\n        isDjango := false;\n        var i := 0;\n        while i < |classifiers|\n        invariant 0 <= i <= |classifiers|\n        invariant !isDjango ==> forall k | 0 <= k < i :: \n            classifiers[k] != \"Framework :: Django\"\n        invariant isDjango ==> exists k | 0 <= k < i :: \n            classifiers[k] == \"Framework :: Django\"\n        {\n            if classifiers[i] == \"Framework :: Django\" {\n                isDjango := true;\n                assert exists k | 0 <= k < i + 1 :: classifiers[k] == \"Framework :: Django\";\n                assert classifiers[i] in classifiers;\n                return;\n            }\n            i := i + 1;\n        }\n        assert !isDjango;\n        assert forall k | 0 <= k < |classifiers| :: classifiers[k] != \"Framework :: Django\";\n        return;\n    }\n}", "name": "py2dfy_3", "id": 3}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Slice(s: seq<char>, start: nat, end: nat) returns (result: seq<char>)\n{\n  result := s[start..end];\n}\nmethod StringToSixBitList(input: seq<char>) returns (result: seq<seq<char>>)\n    (i * 6 + j < |input| ==> result[i][j] == input[i * 6 + j]) &&  \n    (i * 6 + j >= |input| ==> result[i][j] == '0')  \n{\n  var sixBitList: seq<seq<char>> := [];\n  var i := 0;\n  \n  \n  while i < |input| - 5\n      sixBitList[k][j] == input[k * 6 + j]\n  {\n    var chunk := Slice(input, i, i + 6);\n    sixBitList := sixBitList + [chunk];\n    i := i + 6;\n  }\n  \n  if i < |input| {\n    var remainingChars := |input| - i;\n    var lastChunk := Slice(input, i, |input|);\n    var padding := seq(6 - remainingChars, _ => '0');\n    sixBitList := sixBitList + [lastChunk + padding];\n  }\n  result := sixBitList;\n}", "output": "method Slice(s: seq<char>, start: nat, end: nat) returns (result: seq<char>)\n  requires start <= end <= |s|\n  ensures |result| == end - start\n  ensures forall i :: 0 <= i < |result| ==> result[i] == s[start + i]\n{\n  result := s[start..end];\n}\nmethod StringToSixBitList(input: seq<char>) returns (result: seq<seq<char>>)\n  ensures |result| == (|input| + 5) / 6  \n  ensures forall i :: 0 <= i < |result| ==> |result[i]| == 6  \n  ensures forall i, j :: 0 <= i < |result| && 0 <= j < 6 ==>\n    (i * 6 + j < |input| ==> result[i][j] == input[i * 6 + j]) &&  \n    (i * 6 + j >= |input| ==> result[i][j] == '0')  \n{\n  var sixBitList: seq<seq<char>> := [];\n  var i := 0;\n  \n  \n  while i < |input| - 5\n    invariant 0 <= i <= |input|\n    invariant i % 6 == 0\n    invariant |sixBitList| == i / 6\n    invariant forall k :: 0 <= k < |sixBitList| ==> |sixBitList[k]| == 6\n    invariant forall k, j :: 0 <= k < |sixBitList| && 0 <= j < 6 ==>\n      sixBitList[k][j] == input[k * 6 + j]\n  {\n    var chunk := Slice(input, i, i + 6);\n    sixBitList := sixBitList + [chunk];\n    i := i + 6;\n  }\n  \n  if i < |input| {\n    var remainingChars := |input| - i;\n    var lastChunk := Slice(input, i, |input|);\n    var padding := seq(6 - remainingChars, _ => '0');\n    sixBitList := sixBitList + [lastChunk + padding];\n  }\n  result := sixBitList;\n}", "name": "py2dfy_1", "id": 1}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = Some(value: T) | None\ndatatype Plant = Plant(\n  id: int,\n  location: string, \n  name: string,\n  directorId: int\n)\ndatatype Employee = Employee(\n  id: int,\n  name: string,\n  email: string,\n  departmentType: string,\n  departmentId: int,\n  isDirector: bool\n)\nclass Database {\n  var plants: seq<Plant>\n  constructor()\n  {\n    plants := [];\n  }\n  \n  method GetPlantById(id: int) returns (p: Option<Plant>)\n  {\n    var i := 0;\n    while i < |plants|\n    {\n      if plants[i].id == id {\n        return Some(plants[i]);\n      }\n      i := i + 1;\n    }\n    return None;\n  }\n}", "output": "datatype Option<T> = Some(value: T) | None\ndatatype Plant = Plant(\n  id: int,\n  location: string, \n  name: string,\n  directorId: int\n)\ndatatype Employee = Employee(\n  id: int,\n  name: string,\n  email: string,\n  departmentType: string,\n  departmentId: int,\n  isDirector: bool\n)\nclass Database {\n  var plants: seq<Plant>\n  constructor()\n  {\n    plants := [];\n  }\n  \n  method GetPlantById(id: int) returns (p: Option<Plant>)\n    ensures p.Some? ==> exists i :: 0 <= i < |plants| && plants[i].id == id && plants[i] == p.value\n    ensures p.None? ==> (forall i :: 0 <= i < |plants| ==> plants[i].id != id)\n  {\n    var i := 0;\n    while i < |plants|\n      invariant 0 <= i <= |plants|\n      invariant forall j :: 0 <= j < i ==> plants[j].id != id\n    {\n      if plants[i].id == id {\n        return Some(plants[i]);\n      }\n      i := i + 1;\n    }\n    return None;\n  }\n}", "name": "py2dfy_48", "id": 48}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype RGB = RGB(r: int, g: int, b: int)\ndatatype YCbCr = YCbCr(y: int, cb: int, cr: int)\ndatatype Size = Size(cx: int, cy: int, unit: int)\ndatatype Offset = Offset(x: int, y: int)\ndatatype Area = Area(x: int, y: int, cx: int, cy: int, unit: int)\ndatatype BlockRGB = BlockRGB(size: Size, rows: seq<seq<RGB>>)\ndatatype BlockInt = BlockInt(size: Size, rows: seq<seq<int>>)\ndatatype PlaneYCbCr = PlaneYCbCr(\n    size: Size, \n    y: seq<seq<int>>, \n    cb: seq<seq<int>>, \n    cr: seq<seq<int>>\n)\ndatatype PlaneYCbCr420 = PlaneYCbCr420(\n    size: Size,\n    y: seq<seq<int>>,\n    cb: seq<seq<int>>,\n    cr: seq<seq<int>>\n)\npredicate ValidRGBValues(rgb: RGB)\n{\n    0 <= rgb.r <= 255 && \n    0 <= rgb.g <= 255 && \n    0 <= rgb.b <= 255\n}\npredicate ValidYCbCrValues(ycbcr: YCbCr)\n{\n    0 <= ycbcr.y <= 255 && \n    -128 <= ycbcr.cb <= 127 && \n    -128 <= ycbcr.cr <= 127\n}\npredicate ValidSize(size: Size)\n{\n    size.cx > 0 && size.cy > 0 && size.unit > 0\n}\nmethod CreateBlockRGB(size: Size, pixelData: seq<seq<RGB>>) returns (block: BlockRGB)\n        0 <= i < |pixelData| && \n        0 <= j < |pixelData[i]| ==> \n        ValidRGBValues(pixelData[i][j])\n{\n    block := BlockRGB(size, pixelData);\n}\nmethod RGBToYCbCr(rgb: RGB) returns (ycbcr: YCbCr)\n{\n    var y := ((299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000) as int;\n    var cb := ((-169 * rgb.r - 331 * rgb.g + 500 * rgb.b) / 1000) as int + 128;\n    var cr := ((500 * rgb.r - 419 * rgb.g - 81 * rgb.b) / 1000) as int + 128;\n    \n    \n    y := if y < 0 then 0 else if y > 255 then 255 else y;\n    cb := if cb < -128 then -128 else if cb > 127 then 127 else cb;\n    cr := if cr < -128 then -128 else if cr > 127 then 127 else cr;\n    \n    ycbcr := YCbCr(y, cb, cr);\n}", "output": "datatype RGB = RGB(r: int, g: int, b: int)\ndatatype YCbCr = YCbCr(y: int, cb: int, cr: int)\ndatatype Size = Size(cx: int, cy: int, unit: int)\ndatatype Offset = Offset(x: int, y: int)\ndatatype Area = Area(x: int, y: int, cx: int, cy: int, unit: int)\ndatatype BlockRGB = BlockRGB(size: Size, rows: seq<seq<RGB>>)\ndatatype BlockInt = BlockInt(size: Size, rows: seq<seq<int>>)\ndatatype PlaneYCbCr = PlaneYCbCr(\n    size: Size, \n    y: seq<seq<int>>, \n    cb: seq<seq<int>>, \n    cr: seq<seq<int>>\n)\ndatatype PlaneYCbCr420 = PlaneYCbCr420(\n    size: Size,\n    y: seq<seq<int>>,\n    cb: seq<seq<int>>,\n    cr: seq<seq<int>>\n)\npredicate ValidRGBValues(rgb: RGB)\n{\n    0 <= rgb.r <= 255 && \n    0 <= rgb.g <= 255 && \n    0 <= rgb.b <= 255\n}\npredicate ValidYCbCrValues(ycbcr: YCbCr)\n{\n    0 <= ycbcr.y <= 255 && \n    -128 <= ycbcr.cb <= 127 && \n    -128 <= ycbcr.cr <= 127\n}\npredicate ValidSize(size: Size)\n{\n    size.cx > 0 && size.cy > 0 && size.unit > 0\n}\nmethod CreateBlockRGB(size: Size, pixelData: seq<seq<RGB>>) returns (block: BlockRGB)\n    requires ValidSize(size)\n    requires |pixelData| == size.cy\n    requires forall i :: 0 <= i < |pixelData| ==> |pixelData[i]| == size.cx\n    requires forall i, j :: \n        0 <= i < |pixelData| && \n        0 <= j < |pixelData[i]| ==> \n        ValidRGBValues(pixelData[i][j])\n    ensures block.size == size\n    ensures block.rows == pixelData\n{\n    block := BlockRGB(size, pixelData);\n}\nmethod RGBToYCbCr(rgb: RGB) returns (ycbcr: YCbCr)\n    requires ValidRGBValues(rgb)\n    ensures ValidYCbCrValues(ycbcr)\n{\n    var y := ((299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000) as int;\n    var cb := ((-169 * rgb.r - 331 * rgb.g + 500 * rgb.b) / 1000) as int + 128;\n    var cr := ((500 * rgb.r - 419 * rgb.g - 81 * rgb.b) / 1000) as int + 128;\n    \n    \n    y := if y < 0 then 0 else if y > 255 then 255 else y;\n    cb := if cb < -128 then -128 else if cb > 127 then 127 else cb;\n    cr := if cr < -128 then -128 else if cr > 127 then 127 else cr;\n    \n    ycbcr := YCbCr(y, cb, cr);\n}", "name": "py2dfy_83", "id": 83}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Status = Status(streaming: bool, error: seq<Error>)\ndatatype Error = Error(errorType: string)\ndatatype Route = Route(methods: seq<string>, route: string)\ndatatype ThreadState = Running | Stopped\nclass Routes {\n    \n    var threads: map<string, ThreadState>\n    var middlewares: map<string, Middleware>\n    \n    \n    ghost predicate Valid()\n    {\n        \n        forall sid :: sid in middlewares ==> sid in threads\n    }\n    constructor()\n    {\n        threads := map[];\n        middlewares := map[];\n    }\n    \n    method OnConnect(sid: string)\n    {\n        threads := threads[sid := Running];\n    }\n    \n    method OnDisconnect(sid: string)\n    {\n        if sid in middlewares {\n            middlewares := map sid' | sid' in middlewares && sid' != sid :: middlewares[sid'];\n        }\n        threads := map sid' | sid' in threads && sid' != sid :: threads[sid'];\n    }\n    \n    method ManageEvents(sid: string, streaming: bool, topics: seq<string>, reservoirSize: nat)\n    {\n        if streaming {\n            var isRunning := sid in threads && threads[sid] == Running;\n            if !isRunning {\n                \n                var mw := new Middleware(topics, reservoirSize);\n                middlewares := middlewares[sid := mw];\n                threads := threads[sid := Running];\n            }\n        } else {\n            if sid in middlewares {\n                \n                threads := threads[sid := Stopped];\n                \n                middlewares := map sid' | sid' in middlewares && sid' != sid :: middlewares[sid'];\n            }\n        }\n    }\n    \n    method ListRoutes(routes: seq<Route>) returns (result: seq<Route>)\n    {\n        result := routes;\n    }\n}\nclass Middleware {\n    var topics: seq<string>\n    var reservoirSize: nat\n    \n    constructor(topics': seq<string>, reservoirSize': nat)\n    {\n        topics := topics';\n        reservoirSize := reservoirSize';\n    }\n}", "output": "datatype Status = Status(streaming: bool, error: seq<Error>)\ndatatype Error = Error(errorType: string)\ndatatype Route = Route(methods: seq<string>, route: string)\ndatatype ThreadState = Running | Stopped\nclass Routes {\n    \n    var threads: map<string, ThreadState>\n    var middlewares: map<string, Middleware>\n    \n    \n    ghost predicate Valid()\n        reads this\n    {\n        \n        forall sid :: sid in middlewares ==> sid in threads\n    }\n    constructor()\n        ensures Valid()\n        ensures fresh(this)\n        ensures threads == map[]\n        ensures middlewares == map[]\n    {\n        threads := map[];\n        middlewares := map[];\n    }\n    \n    method OnConnect(sid: string)\n        requires sid != \"\"\n        requires Valid()\n        modifies this\n        ensures Valid()\n        ensures sid in threads\n        ensures threads[sid] == Running\n    {\n        threads := threads[sid := Running];\n    }\n    \n    method OnDisconnect(sid: string)\n        requires sid != \"\"\n        requires Valid()\n        modifies this\n        ensures Valid()\n        ensures sid !in middlewares\n        ensures sid !in threads\n    {\n        if sid in middlewares {\n            middlewares := map sid' | sid' in middlewares && sid' != sid :: middlewares[sid'];\n        }\n        threads := map sid' | sid' in threads && sid' != sid :: threads[sid'];\n    }\n    \n    method ManageEvents(sid: string, streaming: bool, topics: seq<string>, reservoirSize: nat)\n        requires sid != \"\"\n        requires Valid()\n        requires reservoirSize > 0\n        modifies this\n        ensures Valid()\n    {\n        if streaming {\n            var isRunning := sid in threads && threads[sid] == Running;\n            if !isRunning {\n                \n                var mw := new Middleware(topics, reservoirSize);\n                middlewares := middlewares[sid := mw];\n                threads := threads[sid := Running];\n            }\n        } else {\n            if sid in middlewares {\n                \n                threads := threads[sid := Stopped];\n                \n                middlewares := map sid' | sid' in middlewares && sid' != sid :: middlewares[sid'];\n            }\n        }\n    }\n    \n    method ListRoutes(routes: seq<Route>) returns (result: seq<Route>)\n        ensures |result| == |routes|\n        ensures forall i :: 0 <= i < |routes| ==> result[i] == routes[i]\n    {\n        result := routes;\n    }\n}\nclass Middleware {\n    var topics: seq<string>\n    var reservoirSize: nat\n    \n    constructor(topics': seq<string>, reservoirSize': nat)\n        requires reservoirSize' > 0\n        ensures topics == topics'\n        ensures reservoirSize == reservoirSize'\n        ensures fresh(this)\n    {\n        topics := topics';\n        reservoirSize := reservoirSize';\n    }\n}", "name": "py2dfy_94", "id": 94}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class BillingProfile {\n  var customerId: string\n  var isActive: bool\n  constructor()\n  {\n    customerId := \"\";\n    isActive := false;\n  }\n}\nclass Card {\n  var token: string\n  var billingProfile: BillingProfile?\n  \n  constructor()\n  {\n    token := \"\";\n    billingProfile := null;\n  }\n}\ndatatype Result = Success | Error(msg: string)\nclass PaymentSystem {\n  \n  var profiles: seq<BillingProfile>\n  var cards: seq<Card>\n  \n  constructor()\n  {\n    profiles := [];\n    cards := [];\n  }\n  \n  method PaymentMethodView(requestUser: string, nextUrl: string) returns (result: Result)\n  {\n    var billingProfile := GetBillingProfile(requestUser);\n    if billingProfile == null {\n      return Error(\"No billing profile found\");\n    }\n    \n    \n    return Success;\n  }\n  \n  method PaymentMethodCreate(requestUser: string, token: string) returns (result: Result)\n      (result.msg == \"No billing profile found\" || \n       result.msg == \"Invalid token\")\n  {\n    var billingProfile := GetBillingProfile(requestUser);\n    if billingProfile == null {\n      return Error(\"No billing profile found\");\n    }\n    if !IsValidToken(token) {\n      return Error(\"Invalid token\");\n    }\n    \n    var card := new Card();\n    card.token := token;\n    card.billingProfile := billingProfile;\n    cards := cards + [card];\n    return Success;\n  }\n  \n  method GetBillingProfile(user: string) returns (profile: BillingProfile?)\n  {\n    \n    var i := 0;\n    while i < |profiles|\n    {\n      if profiles[i].customerId == user {\n        return profiles[i];\n      }\n      i := i + 1;\n    }\n    return null;\n  }\n  \n  predicate IsValidToken(token: string)\n  {\n    \n    |token| > 10\n  }\n}", "output": "class BillingProfile {\n  var customerId: string\n  var isActive: bool\n  constructor()\n    ensures isActive == false\n  {\n    customerId := \"\";\n    isActive := false;\n  }\n}\nclass Card {\n  var token: string\n  var billingProfile: BillingProfile?\n  \n  constructor()\n    ensures billingProfile == null\n  {\n    token := \"\";\n    billingProfile := null;\n  }\n}\ndatatype Result = Success | Error(msg: string)\nclass PaymentSystem {\n  \n  var profiles: seq<BillingProfile>\n  var cards: seq<Card>\n  \n  constructor()\n    ensures profiles == []\n    ensures cards == []\n  {\n    profiles := [];\n    cards := [];\n  }\n  \n  method PaymentMethodView(requestUser: string, nextUrl: string) returns (result: Result)\n    requires requestUser != \"\"\n    requires nextUrl != \"\"\n    ensures result.Success? ==> exists p :: p in profiles\n    ensures result.Error? ==> result.msg == \"No billing profile found\"\n  {\n    var billingProfile := GetBillingProfile(requestUser);\n    if billingProfile == null {\n      return Error(\"No billing profile found\");\n    }\n    \n    \n    return Success;\n  }\n  \n  method PaymentMethodCreate(requestUser: string, token: string) returns (result: Result)\n    requires requestUser != \"\"\n    requires token != \"\"\n    modifies this`cards\n    ensures result.Success? ==> exists c :: c in cards && c.token == token\n    ensures result.Error? ==> \n      (result.msg == \"No billing profile found\" || \n       result.msg == \"Invalid token\")\n    ensures old(cards) <= cards \n  {\n    var billingProfile := GetBillingProfile(requestUser);\n    if billingProfile == null {\n      return Error(\"No billing profile found\");\n    }\n    if !IsValidToken(token) {\n      return Error(\"Invalid token\");\n    }\n    \n    var card := new Card();\n    card.token := token;\n    card.billingProfile := billingProfile;\n    cards := cards + [card];\n    assert card in cards; \n    assert card.token == token; \n    return Success;\n  }\n  \n  method GetBillingProfile(user: string) returns (profile: BillingProfile?)\n    requires user != \"\"\n    ensures profile != null ==> profile in profiles\n  {\n    \n    var i := 0;\n    while i < |profiles|\n      invariant 0 <= i <= |profiles|\n    {\n      if profiles[i].customerId == user {\n        return profiles[i];\n      }\n      i := i + 1;\n    }\n    return null;\n  }\n  \n  predicate IsValidToken(token: string)\n    requires token != \"\"\n  {\n    \n    |token| > 10\n  }\n}", "name": "py2dfy_33", "id": 33}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Point = Point(x: int, y: int)\ndatatype Dimension = Dimension(width: int, height: int)\ndatatype Color = Color(r: int, g: int, b: int)\nclass ResizingElement {\n    var dimension: Dimension\n    var Valid: bool  \n    predicate ValidState()\n    {\n        Valid && \n        dimension.width >= 0 && \n        dimension.height >= 0\n    }\n    constructor()\n    {\n        dimension := Dimension(0, 0);\n        Valid := true;\n    }\n    \n    method Resize(newWidth: int, newHeight: int)\n    {\n        var oldWidth := dimension.width;\n        var oldHeight := dimension.height;\n        \n        \n        var wscale := if oldWidth == 0 then 1.0 else (newWidth as real) / (oldWidth as real);\n        var hscale := if oldHeight == 0 then 1.0 else (newHeight as real) / (oldHeight as real);\n        \n        dimension := Dimension(newWidth, newHeight);\n    }\n    \n    static method FindCenter(a: int, b: int) returns (center: int)\n    {\n        center := (a + b) / 2;\n    }\n    \n    method CalculateWindowCenter(\n        windowDim: Dimension, \n        screenDim: Dimension\n    ) returns (position: Point)\n    {\n        var x := (screenDim.width - windowDim.width) / 2;\n        var y := (screenDim.height - windowDim.height) / 2;\n        position := Point(x, y);\n    }\n}\nclass GridHelper {\n    \n    method CalculateColumnWeights(numColumns: nat, defaultWeight: nat) returns (weights: seq<nat>)\n    {\n        weights := [];\n        var i := 0;\n        while i < numColumns\n        {\n            weights := weights + [defaultWeight];\n            i := i + 1;\n        }\n    }\n}", "output": "datatype Point = Point(x: int, y: int)\ndatatype Dimension = Dimension(width: int, height: int)\ndatatype Color = Color(r: int, g: int, b: int)\nclass ResizingElement {\n    var dimension: Dimension\n    var Valid: bool  \n    predicate ValidState()\n    reads this\n    {\n        Valid && \n        dimension.width >= 0 && \n        dimension.height >= 0\n    }\n    constructor()\n    ensures ValidState()\n    ensures dimension.width == 0 && dimension.height == 0\n    {\n        dimension := Dimension(0, 0);\n        Valid := true;\n    }\n    \n    method Resize(newWidth: int, newHeight: int)\n    requires ValidState()\n    requires newWidth >= 0 && newHeight >= 0\n    modifies this\n    ensures ValidState()\n    ensures dimension.width == newWidth\n    ensures dimension.height == newHeight\n    {\n        var oldWidth := dimension.width;\n        var oldHeight := dimension.height;\n        \n        \n        var wscale := if oldWidth == 0 then 1.0 else (newWidth as real) / (oldWidth as real);\n        var hscale := if oldHeight == 0 then 1.0 else (newHeight as real) / (oldHeight as real);\n        \n        dimension := Dimension(newWidth, newHeight);\n    }\n    \n    static method FindCenter(a: int, b: int) returns (center: int)\n    requires a <= b  \n    ensures center == (a + b) / 2\n    ensures center >= a && center <= b  \n    {\n        center := (a + b) / 2;\n    }\n    \n    method CalculateWindowCenter(\n        windowDim: Dimension, \n        screenDim: Dimension\n    ) returns (position: Point)\n    requires windowDim.width >= 0 && windowDim.height >= 0\n    requires screenDim.width >= 0 && screenDim.height >= 0\n    requires screenDim.width >= windowDim.width\n    requires screenDim.height >= windowDim.height\n    ensures position.x >= 0 && position.x <= screenDim.width - windowDim.width\n    ensures position.y >= 0 && position.y <= screenDim.height - windowDim.height\n    {\n        var x := (screenDim.width - windowDim.width) / 2;\n        var y := (screenDim.height - windowDim.height) / 2;\n        position := Point(x, y);\n    }\n}\nclass GridHelper {\n    \n    method CalculateColumnWeights(numColumns: nat, defaultWeight: nat) returns (weights: seq<nat>)\n    requires numColumns > 0\n    requires defaultWeight > 0\n    ensures |weights| == numColumns\n    ensures forall i :: 0 <= i < |weights| ==> weights[i] == defaultWeight\n    {\n        weights := [];\n        var i := 0;\n        while i < numColumns\n        invariant 0 <= i <= numColumns\n        invariant |weights| == i\n        invariant forall k :: 0 <= k < |weights| ==> weights[k] == defaultWeight\n        {\n            weights := weights + [defaultWeight];\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_11", "id": 11}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "const maxPopSize: int := 10000\nconst maxNumPopulations: int := 100\nconst minPitch: int := 21  \nconst maxPitch: int := 109\nconst minDuration: int := 7 \nconst maxDuration: int := 50\nclass Note {\n  var timestamp: real\n  var duration: real\n  var pitch: real\n  var velocity: real\n  constructor(t: real, d: real, p: real, v: real)\n  {\n    timestamp := t;\n    duration := d;\n    pitch := p;\n    velocity := v;\n  }\n}\ntype Population = seq<Note>\nmethod RandomReal(min: real, max: real) returns (r: real)\n{\n  \n  r := min + (max - min) / 2.0; \n}\nmethod RandomInt(min: int, max: int) returns (r: int)\n{\n  \n  r := min + (max - min) / 2; \n}\nmethod GenRandPopulation(baseTimeDif: real) returns (population: Population)\n{\n  var currTimeStamp: real := 0.0;\n  population := [];\n  var i := 0;\n  while i < maxPopSize\n  {\n    var duration := RandomReal(0.7, 5.0);  \n    var pitch := RandomInt(minPitch, maxPitch);\n    var velocity := RandomReal(0.0, 1.0);\n    \n    var timestamp := if i == 0 then 0.0 else baseTimeDif + currTimeStamp;\n    var note := new Note(timestamp, duration, (pitch as real), velocity);\n    \n    population := population + [note];\n    currTimeStamp := currTimeStamp + baseTimeDif;\n    i := i + 1;\n  }\n}\nmethod Breed(parentPop: Population) returns (childPop: Population)\n{\n  childPop := [];\n  var i := 0;\n  \n  while i < |parentPop|\n  {\n    var nextIndex := if i + 1 < |parentPop| then i + 1 else 0;\n    var curr := parentPop[i];\n    var next := parentPop[nextIndex];\n    \n    var childNote := new Note(\n      (curr.timestamp + next.timestamp) / 2.0,\n      (curr.duration + next.duration) / 2.0,\n      (curr.pitch + next.pitch) / 2.0,\n      (curr.velocity + next.velocity) / 2.0\n    );\n    \n    childPop := childPop + [childNote];\n    i := i + 1;\n  }\n}\nmethod GenCenter_direct(population: Population) returns (center: Note)\n{\n  var sumTimestamp: real := 0.0;\n  var sumDuration: real := 0.0;\n  var sumPitch: real := 0.0;\n  var sumVelocity: real := 0.0;\n  \n  var i := 0;\n  while i < |population|\n  {\n    sumTimestamp := sumTimestamp + population[i].timestamp;\n    sumDuration := sumDuration + population[i].duration;\n    sumPitch := sumPitch + population[i].pitch;\n    sumVelocity := sumVelocity + population[i].velocity;\n    i := i + 1;\n  }\n  \n  var len := |population| as real;\n  center := new Note(\n    sumTimestamp / len,\n    sumDuration / len,\n    sumPitch / len,\n    sumVelocity / len\n  );\n}\nmethod GenAllRandPopulations(numPops: int) returns (populations: seq<Population>)\n{\n  populations := [];\n  var i := 0;\n  while i < numPops\n  {\n    var pop := GenRandPopulation(15.0);\n    populations := populations + [pop];\n    i := i + 1;\n  }\n}", "output": "const maxPopSize: int := 10000\nconst maxNumPopulations: int := 100\nconst minPitch: int := 21  \nconst maxPitch: int := 109\nconst minDuration: int := 7 \nconst maxDuration: int := 50\nclass Note {\n  var timestamp: real\n  var duration: real\n  var pitch: real\n  var velocity: real\n  constructor(t: real, d: real, p: real, v: real)\n    ensures timestamp == t && duration == d && pitch == p && velocity == v\n  {\n    timestamp := t;\n    duration := d;\n    pitch := p;\n    velocity := v;\n  }\n}\ntype Population = seq<Note>\nmethod RandomReal(min: real, max: real) returns (r: real)\n  requires min <= max\n  ensures min <= r <= max\n{\n  \n  r := min + (max - min) / 2.0; \n}\nmethod RandomInt(min: int, max: int) returns (r: int)\n  requires min <= max\n  ensures min <= r <= max\n{\n  \n  r := min + (max - min) / 2; \n}\nmethod GenRandPopulation(baseTimeDif: real) returns (population: Population)\n  requires baseTimeDif > 0.0\n  ensures |population| == maxPopSize\n{\n  var currTimeStamp: real := 0.0;\n  population := [];\n  var i := 0;\n  while i < maxPopSize\n    invariant 0 <= i <= maxPopSize\n    invariant |population| == i\n  {\n    var duration := RandomReal(0.7, 5.0);  \n    var pitch := RandomInt(minPitch, maxPitch);\n    var velocity := RandomReal(0.0, 1.0);\n    \n    var timestamp := if i == 0 then 0.0 else baseTimeDif + currTimeStamp;\n    var note := new Note(timestamp, duration, (pitch as real), velocity);\n    \n    population := population + [note];\n    currTimeStamp := currTimeStamp + baseTimeDif;\n    i := i + 1;\n  }\n}\nmethod Breed(parentPop: Population) returns (childPop: Population)\n  requires |parentPop| > 0\n  ensures |childPop| == |parentPop|\n{\n  childPop := [];\n  var i := 0;\n  \n  while i < |parentPop|\n    invariant 0 <= i <= |parentPop|\n    invariant |childPop| == i\n  {\n    var nextIndex := if i + 1 < |parentPop| then i + 1 else 0;\n    var curr := parentPop[i];\n    var next := parentPop[nextIndex];\n    \n    var childNote := new Note(\n      (curr.timestamp + next.timestamp) / 2.0,\n      (curr.duration + next.duration) / 2.0,\n      (curr.pitch + next.pitch) / 2.0,\n      (curr.velocity + next.velocity) / 2.0\n    );\n    \n    childPop := childPop + [childNote];\n    i := i + 1;\n  }\n}\nmethod GenCenter_direct(population: Population) returns (center: Note)\n  requires |population| > 0\n{\n  var sumTimestamp: real := 0.0;\n  var sumDuration: real := 0.0;\n  var sumPitch: real := 0.0;\n  var sumVelocity: real := 0.0;\n  \n  var i := 0;\n  while i < |population|\n    invariant 0 <= i <= |population|\n  {\n    sumTimestamp := sumTimestamp + population[i].timestamp;\n    sumDuration := sumDuration + population[i].duration;\n    sumPitch := sumPitch + population[i].pitch;\n    sumVelocity := sumVelocity + population[i].velocity;\n    i := i + 1;\n  }\n  \n  var len := |population| as real;\n  center := new Note(\n    sumTimestamp / len,\n    sumDuration / len,\n    sumPitch / len,\n    sumVelocity / len\n  );\n}\nmethod GenAllRandPopulations(numPops: int) returns (populations: seq<Population>)\n  requires 0 < numPops <= maxNumPopulations\n  ensures |populations| == numPops\n  ensures forall i :: 0 <= i < |populations| ==> |populations[i]| == maxPopSize\n{\n  populations := [];\n  var i := 0;\n  while i < numPops\n    invariant 0 <= i <= numPops\n    invariant |populations| == i\n    invariant forall k :: 0 <= k < i ==> |populations[k]| == maxPopSize\n  {\n    var pop := GenRandPopulation(15.0);\n    populations := populations + [pop];\n    i := i + 1;\n  }\n}", "name": "py2dfy_7", "id": 7}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Levenshtein {\n  var s1: string\n  var s2: string\n  constructor(str1: string, str2: string)\n  {\n    s1 := str1;\n    s2 := str2;\n  }\n  function Min3(a: int, b: int, c: int): int \n  {\n    if a <= b && a <= c then a\n    else if b <= a && b <= c then b\n    else c\n  }\n  method Distance() returns (dist: int)\n  {\n    var m := new int[|s2| + 1, |s1| + 1];\n    \n    var i := 0;\n    while i <= |s1|\n    {\n      m[0,i] := i;\n      i := i + 1;\n    }\n    var j := 0;\n    while j <= |s2|\n    {\n      m[j,0] := j;\n      j := j + 1;\n    }\n    j := 1;\n    while j <= |s2|\n    {\n      i := 1;\n      while i <= |s1|\n      {\n        var cost := if s1[i-1] == s2[j-1] then 0 else 1;\n        m[j,i] := Min3(\n          m[j-1,i-1] + cost,\n          m[j-1,i] + 1,\n          m[j,i-1] + 1\n        );\n        i := i + 1;\n      }\n      j := j + 1;\n    }\n    dist := m[|s2|,|s1|];\n  }\n}", "output": "class Levenshtein {\n  var s1: string\n  var s2: string\n  constructor(str1: string, str2: string)\n    ensures s1 == str1 && s2 == str2\n  {\n    s1 := str1;\n    s2 := str2;\n  }\n  function Min3(a: int, b: int, c: int): int \n  {\n    if a <= b && a <= c then a\n    else if b <= a && b <= c then b\n    else c\n  }\n  method Distance() returns (dist: int)\n    ensures dist >= 0\n    ensures |s1| == 0 ==> dist == |s2|\n    ensures |s2| == 0 ==> dist == |s1|\n    ensures dist <= |s1| + |s2|\n  {\n    var m := new int[|s2| + 1, |s1| + 1];\n    \n    var i := 0;\n    while i <= |s1|\n      invariant 0 <= i <= |s1| + 1\n      invariant forall k :: 0 <= k < i ==> m[0,k] == k\n    {\n      m[0,i] := i;\n      i := i + 1;\n    }\n    var j := 0;\n    while j <= |s2|\n      invariant 0 <= j <= |s2| + 1\n      invariant forall k :: 0 <= k < j ==> m[k,0] == k\n      invariant forall k :: 0 <= k <= |s1| ==> m[0,k] == k\n    {\n      m[j,0] := j;\n      j := j + 1;\n    }\n    j := 1;\n    while j <= |s2|\n      invariant 1 <= j <= |s2| + 1\n      invariant forall k :: 0 <= k <= |s1| ==> m[0,k] == k\n      invariant forall k :: 0 <= k <= |s2| ==> m[k,0] == k\n      invariant forall x,y :: 0 <= x < j && 0 <= y <= |s1| ==> 0 <= m[x,y] <= x + y\n    {\n      i := 1;\n      while i <= |s1|\n        invariant 1 <= i <= |s1| + 1\n        invariant forall k :: 0 <= k <= |s1| ==> m[0,k] == k\n        invariant forall k :: 0 <= k <= |s2| ==> m[k,0] == k\n        invariant forall x,y :: 0 <= x < j && 0 <= y <= |s1| ==> 0 <= m[x,y] <= x + y\n        invariant forall x,y :: x == j && 0 <= y < i ==> 0 <= m[x,y] <= x + y\n      {\n        var cost := if s1[i-1] == s2[j-1] then 0 else 1;\n        m[j,i] := Min3(\n          m[j-1,i-1] + cost,\n          m[j-1,i] + 1,\n          m[j,i-1] + 1\n        );\n        i := i + 1;\n      }\n      j := j + 1;\n    }\n    dist := m[|s2|,|s1|];\n  }\n}", "name": "py2dfy_42", "id": 42}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = Some(value: T) | None\ndatatype Message = Message(body: seq<bv8>, msgType: int, uid: Option<int>)\ndatatype ConnectionStatus = Connected | Disconnected\nclass {:autocontracts} NetTunnel {\n    \n    var isConnected: ConnectionStatus\n    var messageQueue: seq<Message>\n    var host: string\n    var port: int\n    var Repr: set<object>\n    \n    const MAGICCODE: int := 0xEA \n    const PINGDELAY: int := 30   \n    const TIMEOUT: int := 60     \n    predicate Valid()\n    {\n        && this in Repr\n        && (isConnected == Connected || isConnected == Disconnected)\n    }\n    constructor()\n    {\n        isConnected := Disconnected;\n        messageQueue := [];\n        host := \"\";\n        port := 0;\n        Repr := {this};\n        new;\n    }\n    \n    method Connect(hostAddr: string, portNum: int) returns (success: bool)\n    {\n        host := hostAddr;\n        port := portNum;\n        \n        \n        success := true; \n        if success {\n            isConnected := Connected;\n        }\n        return success;\n    }\n    \n    method Send(msg: Message) returns (success: bool)\n    {\n        if isConnected == Connected {\n            messageQueue := messageQueue + [msg];\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    \n    method Receive() returns (msg: Option<Message>)\n    {\n        if |messageQueue| > 0 {\n            msg := Some(messageQueue[0]);\n            messageQueue := messageQueue[1..];\n        } else {\n            msg := None;\n        }\n    }\n    \n    method PackMessage(msg: Message) returns (packed: seq<bv8>)\n    {\n        \n        packed := [MAGICCODE as bv8] + [0 as bv8, 0 as bv8, 0 as bv8];  \n    }\n    \n    method CheckMagicCode(data: seq<bv8>) returns (valid: bool)\n    {\n        valid := data[0] as int == MAGICCODE;\n    }\n    \n    method Stop()\n    {\n        isConnected := Disconnected;\n        messageQueue := [];\n    }\n}", "output": "datatype Option<T> = Some(value: T) | None\ndatatype Message = Message(body: seq<bv8>, msgType: int, uid: Option<int>)\ndatatype ConnectionStatus = Connected | Disconnected\nclass {:autocontracts} NetTunnel {\n    \n    var isConnected: ConnectionStatus\n    var messageQueue: seq<Message>\n    var host: string\n    var port: int\n    var Repr: set<object>\n    \n    const MAGICCODE: int := 0xEA \n    const PINGDELAY: int := 30   \n    const TIMEOUT: int := 60     \n    predicate Valid()\n    {\n        && this in Repr\n        && (isConnected == Connected || isConnected == Disconnected)\n    }\n    constructor()\n    ensures isConnected == Disconnected\n    ensures messageQueue == []\n    {\n        isConnected := Disconnected;\n        messageQueue := [];\n        host := \"\";\n        port := 0;\n        Repr := {this};\n        new;\n    }\n    \n    method Connect(hostAddr: string, portNum: int) returns (success: bool)\n    requires hostAddr != \"\"\n    requires portNum > 0 && portNum < 65536\n    ensures old(isConnected) == Disconnected ==> isConnected == (if success then Connected else Disconnected)\n    ensures success ==> host == hostAddr && port == portNum\n    {\n        host := hostAddr;\n        port := portNum;\n        \n        \n        success := true; \n        if success {\n            isConnected := Connected;\n        }\n        return success;\n    }\n    \n    method Send(msg: Message) returns (success: bool)\n    requires isConnected == Connected\n    ensures success ==> messageQueue == old(messageQueue) + [msg]\n    ensures !success ==> messageQueue == old(messageQueue)\n    {\n        if isConnected == Connected {\n            messageQueue := messageQueue + [msg];\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    \n    method Receive() returns (msg: Option<Message>)\n    requires isConnected == Connected\n    ensures old(|messageQueue|) > 0 ==> msg.Some?\n    ensures old(|messageQueue|) == 0 ==> msg.None?\n    ensures msg.Some? ==> old(|messageQueue|) > 0 && msg.value == old(messageQueue[0])\n    ensures msg.Some? ==> messageQueue == old(messageQueue[1..])\n    {\n        if |messageQueue| > 0 {\n            msg := Some(messageQueue[0]);\n            messageQueue := messageQueue[1..];\n        } else {\n            msg := None;\n        }\n    }\n    \n    method PackMessage(msg: Message) returns (packed: seq<bv8>)\n    ensures |packed| >= 4  \n    {\n        \n        packed := [MAGICCODE as bv8] + [0 as bv8, 0 as bv8, 0 as bv8];  \n    }\n    \n    method CheckMagicCode(data: seq<bv8>) returns (valid: bool)\n    requires |data| >= 1\n    ensures valid <==> data[0] as int == MAGICCODE\n    {\n        valid := data[0] as int == MAGICCODE;\n    }\n    \n    method Stop()\n    ensures isConnected == Disconnected\n    {\n        isConnected := Disconnected;\n        messageQueue := [];\n    }\n}", "name": "py2dfy_58", "id": 58}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype DataSource = DataSource(driver: Option<string>, mimeType: string)\ndatatype MetaColumn = MetaColumn(dataSource: DataSource, reflectedColumnIdf: string)\ndatatype Identifier = Identifier(value: string)\ndatatype Identifiers = Identifiers(list: seq<Identifier>)\ndatatype DataProvider = DatabaseProvider | JsonProvider | CsvProvider | NoProvider\nclass DataProviderFactory {\n    var metaColumns: seq<MetaColumn>\n    constructor(metaColumns: seq<MetaColumn>)\n    {\n        this.metaColumns := metaColumns;\n    }\n    method FindProvider() returns (provider: DataProvider)\n    {\n        var dataSource := SingleDataSource();\n        var identifiers := MakeIdentifiers();\n        provider := CreateDataProvider(dataSource, identifiers);\n    }\n    method CreateDataProvider(dataSource: DataSource, identifiers: Identifiers) returns (provider: DataProvider)\n    {\n        if dataSource.driver.Some?\n        {\n            return DatabaseProvider;\n        }\n        else if dataSource.mimeType == \"application/json\"\n        {\n            return JsonProvider;\n        }\n        else\n        {\n            \n            return CsvProvider;\n        }\n    }\n    method SingleDataSource() returns (dataSource: DataSource)\n    {\n        dataSource := metaColumns[0].dataSource;\n        \n        var i := 1;\n        while i < |metaColumns|\n        {\n            if metaColumns[i].dataSource != dataSource {\n                \n                \n                return dataSource;\n            }\n            i := i + 1;\n        }\n        \n        return dataSource;\n    }\n    method MakeIdentifiers() returns (identifiers: Identifiers)\n                identifiers.list[i] == Identifier(metaColumns[i].reflectedColumnIdf)\n    {\n        var idList: seq<Identifier> := [];\n        \n        var i := 0;\n        while i < |metaColumns|\n        {\n            idList := idList + [Identifier(metaColumns[i].reflectedColumnIdf)];\n            i := i + 1;\n        }\n        \n        identifiers := Identifiers(idList);\n    }\n}", "output": "datatype Option<T> = None | Some(value: T)\ndatatype DataSource = DataSource(driver: Option<string>, mimeType: string)\ndatatype MetaColumn = MetaColumn(dataSource: DataSource, reflectedColumnIdf: string)\ndatatype Identifier = Identifier(value: string)\ndatatype Identifiers = Identifiers(list: seq<Identifier>)\ndatatype DataProvider = DatabaseProvider | JsonProvider | CsvProvider | NoProvider\nclass DataProviderFactory {\n    var metaColumns: seq<MetaColumn>\n    constructor(metaColumns: seq<MetaColumn>)\n    requires |metaColumns| > 0\n    ensures this.metaColumns == metaColumns\n    {\n        this.metaColumns := metaColumns;\n    }\n    method FindProvider() returns (provider: DataProvider)\n    requires |metaColumns| > 0\n    ensures provider != NoProvider\n    {\n        var dataSource := SingleDataSource();\n        var identifiers := MakeIdentifiers();\n        provider := CreateDataProvider(dataSource, identifiers);\n    }\n    method CreateDataProvider(dataSource: DataSource, identifiers: Identifiers) returns (provider: DataProvider)\n    ensures provider != NoProvider\n    {\n        if dataSource.driver.Some?\n        {\n            return DatabaseProvider;\n        }\n        else if dataSource.mimeType == \"application/json\"\n        {\n            return JsonProvider;\n        }\n        else\n        {\n            \n            return CsvProvider;\n        }\n    }\n    method SingleDataSource() returns (dataSource: DataSource)\n    requires |metaColumns| > 0\n    ensures dataSource == metaColumns[0].dataSource\n    {\n        dataSource := metaColumns[0].dataSource;\n        \n        var i := 1;\n        while i < |metaColumns|\n        invariant 1 <= i <= |metaColumns|\n        {\n            if metaColumns[i].dataSource != dataSource {\n                \n                \n                return dataSource;\n            }\n            i := i + 1;\n        }\n        \n        return dataSource;\n    }\n    method MakeIdentifiers() returns (identifiers: Identifiers)\n    ensures |identifiers.list| == |metaColumns|\n    ensures forall i :: 0 <= i < |metaColumns| ==> \n                identifiers.list[i] == Identifier(metaColumns[i].reflectedColumnIdf)\n    {\n        var idList: seq<Identifier> := [];\n        \n        var i := 0;\n        while i < |metaColumns|\n        invariant 0 <= i <= |metaColumns|\n        invariant |idList| == i\n        invariant forall j :: 0 <= j < i ==> idList[j] == Identifier(metaColumns[j].reflectedColumnIdf)\n        {\n            idList := idList + [Identifier(metaColumns[i].reflectedColumnIdf)];\n            i := i + 1;\n        }\n        \n        identifiers := Identifiers(idList);\n    }\n}", "name": "py2dfy_43", "id": 43}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module CCTV {\n  \n  function {:axiom} GetTable(x: real, y: real): seq<bool>\n  \n  method {:axiom} Update()\n  \n  function {:axiom} GetAddr(): seq<string>\n  \n  function {:axiom} GetData(): seq<bool>\n}\nmodule Classifier {\n  \n  method {:axiom} Train()\n}\nclass Application {\n  \n  method GetTable(x: real, y: real) returns (result: seq<bool>)\n  {\n    result := CCTV.GetTable(x, y);\n  }\n  \n  method Update()\n  {\n    CCTV.Update();\n  }\n  \n  method Train()\n  {\n    Classifier.Train();\n  }\n  \n  method Index() returns (addr: seq<string>, data: seq<bool>)\n  {\n    addr := CCTV.GetAddr();\n    data := CCTV.GetData();\n  }\n  \n  method Run()\n  {\n    var running := true;\n    while running\n    {\n      \n      var choice :| 0 <= choice < 5;  \n      if choice == 0 {\n        var x := GetRandomReal();\n        var y := GetRandomReal(); \n        var tableData := GetTable(x, y);\n      } else if choice == 1 {\n        Update();\n      } else if choice == 2 {\n        Train();\n      } else if choice == 3 {\n        var addr, data := Index();\n      } else {\n        running := false;  \n      }\n    }\n  }\n  \n  method GetRandomReal() returns (r: real)\n}", "output": "module CCTV {\n  \n  function {:axiom} GetTable(x: real, y: real): seq<bool>\n    ensures |GetTable(x, y)| > 0  \n  \n  method {:axiom} Update()\n  \n  function {:axiom} GetAddr(): seq<string>\n    ensures |GetAddr()| > 0  \n  \n  function {:axiom} GetData(): seq<bool>\n    ensures |GetData()| > 0  \n}\nmodule Classifier {\n  \n  method {:axiom} Train()\n}\nclass Application {\n  \n  method GetTable(x: real, y: real) returns (result: seq<bool>)\n    ensures |result| > 0\n  {\n    result := CCTV.GetTable(x, y);\n  }\n  \n  method Update()\n  {\n    CCTV.Update();\n  }\n  \n  method Train()\n  {\n    Classifier.Train();\n  }\n  \n  method Index() returns (addr: seq<string>, data: seq<bool>)\n    ensures |addr| > 0 && |data| > 0\n  {\n    addr := CCTV.GetAddr();\n    data := CCTV.GetData();\n  }\n  \n  method Run()\n    decreases *\n  {\n    var running := true;\n    while running\n      decreases *\n    {\n      \n      var choice :| 0 <= choice < 5;  \n      if choice == 0 {\n        var x := GetRandomReal();\n        var y := GetRandomReal(); \n        var tableData := GetTable(x, y);\n        assert |tableData| > 0;\n      } else if choice == 1 {\n        Update();\n      } else if choice == 2 {\n        Train();\n      } else if choice == 3 {\n        var addr, data := Index();\n        assert |addr| > 0 && |data| > 0;\n      } else {\n        running := false;  \n      }\n    }\n  }\n  \n  method GetRandomReal() returns (r: real)\n}", "name": "py2dfy_87", "id": 87}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module FileIO {\n    class File {\n        var isOpen: bool\n        var contents: seq<char>\n        \n        constructor()\n        {\n            isOpen := false;\n            contents := [];\n        }\n    }\n    method OpenWrite(filename: string) returns (f: File)\n    {\n        f := new File();\n        f.isOpen := true;\n    }\n    method WriteToFile(f: File, content: string)\n    {\n        f.contents := f.contents + content;\n    }\n    method CloseFile(f: File)\n    {\n        f.isOpen := false;\n    }\n}\nmethod Main() \n{\n    var filename := \"output.txt\";\n    var padding := RepeatChar('A', 10);\n    \n    var f := FileIO.OpenWrite(filename);\n    FileIO.WriteToFile(f, padding);\n    FileIO.CloseFile(f);\n}\nmethod RepeatChar(c: char, count: nat) returns (result: string)\n{\n    result := [];\n    var i := 0;\n    while i < count\n    {\n        result := result + [c];\n        i := i + 1;\n    }\n}", "output": "module FileIO {\n    class File {\n        var isOpen: bool\n        var contents: seq<char>\n        \n        constructor()\n        ensures isOpen == false\n        ensures contents == []\n        {\n            isOpen := false;\n            contents := [];\n        }\n    }\n    method OpenWrite(filename: string) returns (f: File)\n    requires |filename| > 0  \n    ensures fresh(f)         \n    ensures f.isOpen        \n    {\n        f := new File();\n        f.isOpen := true;\n    }\n    method WriteToFile(f: File, content: string)\n    requires f.isOpen\n    modifies f\n    ensures f.isOpen  \n    ensures f.contents == old(f.contents) + content\n    {\n        f.contents := f.contents + content;\n    }\n    method CloseFile(f: File)\n    requires f.isOpen\n    modifies f\n    ensures !f.isOpen\n    {\n        f.isOpen := false;\n    }\n}\nmethod Main() \n{\n    var filename := \"output.txt\";\n    var padding := RepeatChar('A', 10);\n    \n    var f := FileIO.OpenWrite(filename);\n    FileIO.WriteToFile(f, padding);\n    FileIO.CloseFile(f);\n}\nmethod RepeatChar(c: char, count: nat) returns (result: string)\nrequires count >= 0\nensures |result| == count\nensures forall i :: 0 <= i < |result| ==> result[i] == c\n{\n    result := [];\n    var i := 0;\n    while i < count\n    invariant 0 <= i <= count\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == c\n    {\n        result := result + [c];\n        i := i + 1;\n    }\n}", "name": "py2dfy_16", "id": 16}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype HistogramData = HistogramData(\n  head: seq<string>,\n  values: map<string, seq<real>>\n)\ndatatype Result<T> = Success(value: T) | Error(msg: string)\nclass {:autocontracts} HistogramProcessor {\n  \n  method ReadHistogram(filename: string) returns (result: Result<HistogramData>)\n      |row| == |result.value.head|\n  {\n    var head := [\"col1\", \"col2\"];\n    var values := map[\"row1\" := [1.0, 2.0]];\n    return Success(HistogramData(head, values));\n  }\n  \n  method NormalizeValues(values: seq<real>) returns (normalized: seq<real>)\n  {\n    var sum := 0.0;\n    var i := 0;\n    var nonnegValues := [];\n    \n    \n    while i < |values|\n    {\n      var val := if values[i] < 0.0 then 0.0 else values[i];\n      nonnegValues := nonnegValues + [val];\n      sum := sum + val;\n      i := i + 1;\n    }\n    \n    if sum == 0.0 {\n      normalized := [];\n      i := 0;\n      while i < |values|\n      {\n        normalized := normalized + [0.0];\n        i := i + 1;\n      }\n      return normalized;\n    }\n    \n    normalized := [];\n    i := 0;\n    while i < |values|\n    {\n      var normalizedValue := nonnegValues[i] / sum;\n      normalized := normalized + [normalizedValue];\n      i := i + 1;\n    }\n  }\n  \n  method CalculateHistogramDifference(\n    hist1: map<string, real>,\n    hist2: map<string, real>,\n    threshold: real\n  ) returns (result: map<string, real>)\n      (k in hist1 && k in hist2 ==> result[k] == hist1[k] - hist2[k]) ||\n      (k in hist1 && k !in hist2 ==> result[k] == hist1[k]) ||\n      (k !in hist1 && k in hist2 ==> result[k] == -hist2[k])\n  {\n    result := map[];\n    \n    \n    var keys1 := set k | k in hist1;\n    var iter := keys1;\n    while iter != {}\n        k in result && result[k] == hist1[k] - (if k in hist2 then hist2[k] else 0.0)\n    {\n      var k :| k in iter;\n      var diff := hist1[k];\n      if k in hist2 {\n        diff := diff - hist2[k];\n      }\n      result := result[k := diff];\n      iter := iter - {k};\n    }\n    \n    var keys2 := set k | k in hist2;\n    iter := keys2 - keys1;\n    while iter != {}\n        (k in hist1 ==> result[k] == hist1[k] - (if k in hist2 then hist2[k] else 0.0)) &&\n        (k !in hist1 && k in hist2 ==> result[k] == -hist2[k])\n    {\n      var k :| k in iter;\n      result := result[k := -hist2[k]];\n      iter := iter - {k};\n    }\n  }\n}", "output": "datatype HistogramData = HistogramData(\n  head: seq<string>,\n  values: map<string, seq<real>>\n)\ndatatype Result<T> = Success(value: T) | Error(msg: string)\nclass {:autocontracts} HistogramProcessor {\n  \n  method ReadHistogram(filename: string) returns (result: Result<HistogramData>)\n    requires filename != \"\"\n    ensures result.Success? ==> |result.value.head| > 0\n    ensures result.Success? ==> forall row :: row in result.value.values.Values ==>\n      |row| == |result.value.head|\n  {\n    var head := [\"col1\", \"col2\"];\n    var values := map[\"row1\" := [1.0, 2.0]];\n    assert |head| > 0;\n    assert forall row :: row in values.Values ==> |row| == |head|;\n    return Success(HistogramData(head, values));\n  }\n  \n  method NormalizeValues(values: seq<real>) returns (normalized: seq<real>)\n    requires |values| > 0\n    ensures |normalized| == |values|\n    ensures forall i :: 0 <= i < |values| ==> 0.0 <= normalized[i] <= 1.0\n  {\n    var sum := 0.0;\n    var i := 0;\n    var nonnegValues := [];\n    \n    \n    while i < |values|\n      invariant 0 <= i <= |values|\n      invariant |nonnegValues| == i\n      invariant forall k :: 0 <= k < i ==> nonnegValues[k] >= 0.0\n      invariant sum >= 0.0\n      invariant forall k :: 0 <= k < i ==> nonnegValues[k] <= sum\n    {\n      var val := if values[i] < 0.0 then 0.0 else values[i];\n      nonnegValues := nonnegValues + [val];\n      sum := sum + val;\n      i := i + 1;\n    }\n    \n    if sum == 0.0 {\n      normalized := [];\n      i := 0;\n      while i < |values|\n        invariant 0 <= i <= |values|\n        invariant |normalized| == i\n        invariant forall k :: 0 <= k < i ==> normalized[k] == 0.0\n      {\n        normalized := normalized + [0.0];\n        i := i + 1;\n      }\n      return normalized;\n    }\n    \n    normalized := [];\n    i := 0;\n    while i < |values|\n      invariant 0 <= i <= |values|\n      invariant |normalized| == i\n      invariant forall k :: 0 <= k < i ==> 0.0 <= normalized[k] <= 1.0\n      invariant sum > 0.0\n      invariant forall k :: 0 <= k < i ==> nonnegValues[k] >= 0.0\n      invariant forall k :: 0 <= k < i ==> nonnegValues[k] <= sum\n    {\n      assert nonnegValues[i] >= 0.0;  \n      assert nonnegValues[i] <= sum;  \n      var normalizedValue := nonnegValues[i] / sum;\n      assert nonnegValues[i] >= 0.0 && sum > 0.0 ==> normalizedValue >= 0.0;\n      assert 0.0 <= nonnegValues[i] && nonnegValues[i] <= sum && sum > 0.0;  \n      assert normalizedValue <= 1.0;  \n      normalized := normalized + [normalizedValue];\n      i := i + 1;\n    }\n  }\n  \n  method CalculateHistogramDifference(\n    hist1: map<string, real>,\n    hist2: map<string, real>,\n    threshold: real\n  ) returns (result: map<string, real>)\n    requires threshold > 0.0\n    requires forall k :: k in hist1 ==> -1.0 <= hist1[k] <= 1.0\n    requires forall k :: k in hist2 ==> -1.0 <= hist2[k] <= 1.0\n    ensures forall k :: k in result ==> \n      (k in hist1 && k in hist2 ==> result[k] == hist1[k] - hist2[k]) ||\n      (k in hist1 && k !in hist2 ==> result[k] == hist1[k]) ||\n      (k !in hist1 && k in hist2 ==> result[k] == -hist2[k])\n  {\n    result := map[];\n    \n    \n    var keys1 := set k | k in hist1;\n    var iter := keys1;\n    while iter != {}\n      invariant iter <= keys1\n      invariant forall k :: k in (keys1 - iter) ==>\n        k in result && result[k] == hist1[k] - (if k in hist2 then hist2[k] else 0.0)\n      invariant forall k :: k in result ==> k in (keys1 - iter)\n    {\n      var k :| k in iter;\n      var diff := hist1[k];\n      if k in hist2 {\n        diff := diff - hist2[k];\n      }\n      result := result[k := diff];\n      iter := iter - {k};\n    }\n    \n    var keys2 := set k | k in hist2;\n    iter := keys2 - keys1;\n    while iter != {}\n      invariant iter <= keys2 - keys1\n      invariant forall k :: k in result ==>\n        (k in hist1 ==> result[k] == hist1[k] - (if k in hist2 then hist2[k] else 0.0)) &&\n        (k !in hist1 && k in hist2 ==> result[k] == -hist2[k])\n      invariant forall k :: k in (keys2 - keys1 - iter) ==> k in result && result[k] == -hist2[k]\n      invariant forall k :: k in result && k !in hist1 ==> k in (keys2 - iter)\n    {\n      var k :| k in iter;\n      result := result[k := -hist2[k]];\n      iter := iter - {k};\n    }\n  }\n}", "name": "py2dfy_70", "id": 70}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function SumArray(arr: seq<int>): int\n{\n  if |arr| == 0 then \n    0 \n  else \n    arr[0] + SumArray(arr[1..])\n}\nfunction Fibonacci(n: nat): nat\n{\n  if n <= 1 then \n    n \n  else \n    Fibonacci(n-1) + Fibonacci(n-2)\n}\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then \n    1 \n  else \n    n * Factorial(n-1)\n}\nfunction Reverse(s: string): string\n{\n  if |s| == 0 then \n    s \n  else \n    Reverse(s[1..]) + s[..1]\n}", "output": "function SumArray(arr: seq<int>): int\n  decreases arr  \n  ensures arr == [] ==> SumArray(arr) == 0  \n  ensures |arr| > 0 ==> SumArray(arr) == arr[0] + SumArray(arr[1..])  \n{\n  if |arr| == 0 then \n    0 \n  else \n    arr[0] + SumArray(arr[1..])\n}\nfunction Fibonacci(n: nat): nat\n  requires n >= 0  \n  decreases n  \n  ensures n <= 1 ==> Fibonacci(n) == n  \n  ensures n > 1 ==> Fibonacci(n) == Fibonacci(n-1) + Fibonacci(n-2)  \n{\n  if n <= 1 then \n    n \n  else \n    Fibonacci(n-1) + Fibonacci(n-2)\n}\nfunction Factorial(n: nat): nat\n  requires n >= 0  \n  decreases n  \n  ensures n == 0 ==> Factorial(n) == 1  \n  ensures n > 0 ==> Factorial(n) == n * Factorial(n-1)  \n{\n  if n == 0 then \n    1 \n  else \n    n * Factorial(n-1)\n}\nfunction Reverse(s: string): string\n  decreases |s|  \n  ensures |s| == 0 ==> Reverse(s) == s  \n  ensures |s| > 0 ==> Reverse(s) == Reverse(s[1..]) + s[..1]  \n  ensures |Reverse(s)| == |s|  \n{\n  if |s| == 0 then \n    s \n  else \n    Reverse(s[1..]) + s[..1]\n}", "name": "py2dfy_32", "id": 32}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype IpInfo = IpInfo(ip: string)\ndatatype GeoMetadata = GeoMetadata(\n  location: string,\n  organization: Option<string>, \n  region: string,\n  country: string,\n  city: string\n)\ndatatype Result<T> = Success(value: T) | Failure(error: string)\nclass Validator {\n  var host: string\n  var port: int  \n  var usingHttps: bool\n  var successRate: real\n  var latency: real\n  var anonymous: bool\n  var valid: bool\n  var meta: Option<GeoMetadata>\n  \n  predicate Valid()\n  {\n    0.0 <= successRate <= 1.0 &&  \n    latency >= 0.0 &&             \n    port > 0 && port < 65536      \n  }\n  \n  constructor(hostAddr: string, portNum: int, useHttps: bool)\n  {\n    host := hostAddr;\n    port := portNum;\n    usingHttps := useHttps;\n    successRate := 0.0;\n    latency := 1000000.0; \n    anonymous := false;\n    valid := false;\n    meta := None;\n  }\n  \n  method ValidateLatency() returns (success: bool)\n  {\n    var pingResult := PingHost(host, port);\n    match pingResult {\n      case Success(result) =>\n        latency := result.0;\n        successRate := result.1;\n        success := successRate > 0.0;\n      case Failure(_) =>\n        success := false;\n    }\n  }\n  \n  method ValidateProxy() returns (success: bool)\n  {\n    var currentIpResult := GetCurrentIp();\n    var proxyIpResult := CheckProxyIp(host, port, usingHttps);\n    \n    match currentIpResult {\n      case Failure(_) => \n        success := false;\n        return;\n      case Success(currentIp) =>\n        match proxyIpResult {\n          case Failure(_) =>\n            success := false;\n            return;\n          case Success(proxyIp) =>\n            if proxyIp != currentIp {\n              anonymous := true;\n            }\n            valid := true;\n            \n            var geoDataResult := GetGeoData(proxyIp);\n            match geoDataResult {\n              case Success(geoData) =>\n                meta := Some(geoData);\n              case Failure(_) =>\n                \n            }\n            success := true;\n        }\n    }\n  }\n  \n  method Validate() returns (success: bool)\n  {\n    var latencySuccess := ValidateLatency();\n    if !latencySuccess {\n      return false;\n    }\n    \n    success := ValidateProxy();\n  }\n}\nmethod {:axiom} PingHost(host: string, port: int) returns (result: Result<(real, real)>)\nmethod {:axiom} GetCurrentIp() returns (result: Result<string>)\nmethod {:axiom} CheckProxyIp(host: string, port: int, useHttps: bool) returns (result: Result<string>)\nmethod {:axiom} GetGeoData(ip: string) returns (result: Result<GeoMetadata>)", "output": "datatype Option<T> = None | Some(value: T)\ndatatype IpInfo = IpInfo(ip: string)\ndatatype GeoMetadata = GeoMetadata(\n  location: string,\n  organization: Option<string>, \n  region: string,\n  country: string,\n  city: string\n)\ndatatype Result<T> = Success(value: T) | Failure(error: string)\nclass Validator {\n  var host: string\n  var port: int  \n  var usingHttps: bool\n  var successRate: real\n  var latency: real\n  var anonymous: bool\n  var valid: bool\n  var meta: Option<GeoMetadata>\n  \n  predicate Valid()\n    reads this\n  {\n    0.0 <= successRate <= 1.0 &&  \n    latency >= 0.0 &&             \n    port > 0 && port < 65536      \n  }\n  \n  constructor(hostAddr: string, portNum: int, useHttps: bool)\n    requires portNum > 0 && portNum < 65536\n    ensures Valid()\n    ensures host == hostAddr\n    ensures port == portNum \n    ensures usingHttps == useHttps\n    ensures fresh(this)\n  {\n    host := hostAddr;\n    port := portNum;\n    usingHttps := useHttps;\n    successRate := 0.0;\n    latency := 1000000.0; \n    anonymous := false;\n    valid := false;\n    meta := None;\n  }\n  \n  method ValidateLatency() returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures old(this.host) == this.host \n    ensures old(this.port) == this.port \n  {\n    var pingResult := PingHost(host, port);\n    match pingResult {\n      case Success(result) =>\n        latency := result.0;\n        successRate := result.1;\n        success := successRate > 0.0;\n      case Failure(_) =>\n        success := false;\n    }\n  }\n  \n  method ValidateProxy() returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures old(this.host) == this.host\n    ensures old(this.port) == this.port\n  {\n    var currentIpResult := GetCurrentIp();\n    var proxyIpResult := CheckProxyIp(host, port, usingHttps);\n    \n    match currentIpResult {\n      case Failure(_) => \n        success := false;\n        return;\n      case Success(currentIp) =>\n        match proxyIpResult {\n          case Failure(_) =>\n            success := false;\n            return;\n          case Success(proxyIp) =>\n            if proxyIp != currentIp {\n              anonymous := true;\n            }\n            valid := true;\n            \n            var geoDataResult := GetGeoData(proxyIp);\n            match geoDataResult {\n              case Success(geoData) =>\n                meta := Some(geoData);\n              case Failure(_) =>\n                \n            }\n            success := true;\n        }\n    }\n  }\n  \n  method Validate() returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures old(this.host) == this.host\n    ensures old(this.port) == this.port\n  {\n    var latencySuccess := ValidateLatency();\n    if !latencySuccess {\n      return false;\n    }\n    \n    success := ValidateProxy();\n  }\n}\nmethod {:axiom} PingHost(host: string, port: int) returns (result: Result<(real, real)>)\n  requires port > 0 && port < 65536\n  ensures result.Success? ==> result.value.0 >= 0.0  \n  ensures result.Success? ==> 0.0 <= result.value.1 <= 1.0  \nmethod {:axiom} GetCurrentIp() returns (result: Result<string>)\n  ensures result.Success? ==> |result.value| > 0  \nmethod {:axiom} CheckProxyIp(host: string, port: int, useHttps: bool) returns (result: Result<string>)\n  requires port > 0 && port < 65536\n  ensures result.Success? ==> |result.value| > 0\nmethod {:axiom} GetGeoData(ip: string) returns (result: Result<GeoMetadata>)\n  requires |ip| > 0", "name": "py2dfy_5", "id": 5}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module Math {\n  const PI: real := 3.141592653589793\n  \n  function {:axiom} Sqrt(x: real): real \n  function {:axiom} Cos(x: real): real \n  function {:axiom} Sin(x: real): real \n}\nclass Matrix {\n  var rows: nat\n  var cols: nat\n  var data: array2<real>\n  constructor(r: nat, c: nat)\n  {\n    rows := r;\n    cols := c;\n    data := new real[r, c];\n  }\n  method RandomUniform(min: real, max: real) returns (result: Matrix)\n  {\n    result := new Matrix(rows, cols);\n    \n  }\n}\nclass Generator {\n  var z_dim: nat\n  var x_dim: nat\n  var h_dim: nat\n  \n  constructor(zd: nat, xd: nat, hd: nat)\n  {\n    z_dim := zd;\n    x_dim := xd;\n    h_dim := hd;\n  }\n  method Forward(input: Matrix) returns (output: Matrix)\n  {\n    \n    var h1 := new Matrix(input.rows, h_dim);\n    output := new Matrix(input.rows, x_dim);\n    \n  }\n}\nmethod TrainGAN(iterations: nat, batch_size: nat, lambda: real)\n{\n  var generator := new Generator(2, 2, 500);\n  \n  \n  var i := 0;\n  while i < iterations\n  {\n    \n    var real_circle := GenerateCircleSamples(batch_size);\n    var real_square := GenerateSquareSamples(batch_size);\n    \n    \n    var z := GenerateLatentSamples(batch_size, generator.z_dim);\n    var fake_samples := generator.Forward(z);\n    \n    \n    \n    UpdateNetworks(real_circle, real_square, fake_samples, lambda);\n    \n    i := i + 1;\n  }\n}\nmethod GenerateCircleSamples(batch_size: nat) returns (samples: Matrix)\n{\n  samples := new Matrix(batch_size, 2);\n  \n}\nmethod GenerateSquareSamples(batch_size: nat) returns (samples: Matrix)\n{\n  samples := new Matrix(batch_size, 2);\n  \n}\nmethod GenerateLatentSamples(batch_size: nat, z_dim: nat) returns (samples: Matrix)\n{\n  samples := new Matrix(batch_size, z_dim);\n  \n}\nmethod UpdateNetworks(real_circle: Matrix, real_square: Matrix, fake_samples: Matrix, lambda: real)\n{\n  \n}", "output": "module Math {\n  const PI: real := 3.141592653589793\n  \n  function {:axiom} Sqrt(x: real): real \n    requires x >= 0.0\n    ensures Sqrt(x) >= 0.0\n    ensures Sqrt(x) * Sqrt(x) == x\n  function {:axiom} Cos(x: real): real \n    ensures -1.0 <= Cos(x) <= 1.0\n  function {:axiom} Sin(x: real): real \n    ensures -1.0 <= Sin(x) <= 1.0\n}\nclass Matrix {\n  var rows: nat\n  var cols: nat\n  var data: array2<real>\n  constructor(r: nat, c: nat)\n    requires r > 0 && c > 0\n    ensures rows == r && cols == c\n    ensures fresh(data)\n    ensures data.Length0 == rows && data.Length1 == cols\n  {\n    rows := r;\n    cols := c;\n    data := new real[r, c];\n  }\n  method RandomUniform(min: real, max: real) returns (result: Matrix)\n    requires min < max\n    requires rows > 0 && cols > 0\n    ensures fresh(result)\n    ensures result.rows == rows && result.cols == cols\n  {\n    result := new Matrix(rows, cols);\n    \n  }\n}\nclass Generator {\n  var z_dim: nat\n  var x_dim: nat\n  var h_dim: nat\n  \n  constructor(zd: nat, xd: nat, hd: nat)\n    requires zd > 0 && xd > 0 && hd > 0\n    ensures z_dim == zd && x_dim == xd && h_dim == hd\n  {\n    z_dim := zd;\n    x_dim := xd;\n    h_dim := hd;\n  }\n  method Forward(input: Matrix) returns (output: Matrix)\n    requires input.rows > 0 && input.cols == z_dim\n    requires h_dim > 0 && x_dim > 0\n    ensures fresh(output)\n    ensures output.rows == input.rows && output.cols == x_dim\n  {\n    \n    var h1 := new Matrix(input.rows, h_dim);\n    output := new Matrix(input.rows, x_dim);\n    \n  }\n}\nmethod TrainGAN(iterations: nat, batch_size: nat, lambda: real)\n  requires batch_size > 0\n  requires lambda > 0.0\n{\n  var generator := new Generator(2, 2, 500);\n  \n  \n  var i := 0;\n  while i < iterations\n    invariant 0 <= i <= iterations\n    invariant generator.z_dim > 0 && generator.x_dim > 0 && generator.h_dim > 0\n    invariant generator.x_dim == 2  \n    decreases iterations - i\n  {\n    \n    var real_circle := GenerateCircleSamples(batch_size);\n    var real_square := GenerateSquareSamples(batch_size);\n    \n    \n    var z := GenerateLatentSamples(batch_size, generator.z_dim);\n    var fake_samples := generator.Forward(z);\n    \n    assert fake_samples.rows == batch_size;\n    assert fake_samples.cols == generator.x_dim == 2;\n    \n    \n    UpdateNetworks(real_circle, real_square, fake_samples, lambda);\n    \n    i := i + 1;\n  }\n}\nmethod GenerateCircleSamples(batch_size: nat) returns (samples: Matrix)\n  requires batch_size > 0\n  ensures fresh(samples)\n  ensures samples.rows == batch_size && samples.cols == 2\n{\n  samples := new Matrix(batch_size, 2);\n  \n}\nmethod GenerateSquareSamples(batch_size: nat) returns (samples: Matrix)\n  requires batch_size > 0\n  ensures fresh(samples)\n  ensures samples.rows == batch_size && samples.cols == 2\n{\n  samples := new Matrix(batch_size, 2);\n  \n}\nmethod GenerateLatentSamples(batch_size: nat, z_dim: nat) returns (samples: Matrix)\n  requires batch_size > 0\n  requires z_dim > 0\n  ensures fresh(samples)\n  ensures samples.rows == batch_size && samples.cols == z_dim\n{\n  samples := new Matrix(batch_size, z_dim);\n  \n}\nmethod UpdateNetworks(real_circle: Matrix, real_square: Matrix, fake_samples: Matrix, lambda: real)\n  requires real_circle.rows > 0 && real_circle.cols == 2\n  requires real_square.rows > 0 && real_square.cols == 2\n  requires fake_samples.rows > 0 && fake_samples.cols == 2\n  requires lambda > 0.0\n{\n  \n}", "name": "py2dfy_92", "id": 92}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype DateTime = DateTime(\n  year: int,\n  month: int,\n  day: int,\n  hour: int,\n  minute: int,\n  second: int,\n  microsecond: int,\n  timezone: Option<TimeZone>\n)\ndatatype TimeZone = FixedTimeZone(hours: int, minutes: int)\ndatatype TimeDelta = TimeDelta(hours: int, minutes: int)\nclass DateTimeUtil {\n  \n  method FromHoursMinutes(hours: int, minutes: int) returns (tz: TimeZone)\n  {\n    tz := FixedTimeZone(hours, minutes);\n  }\n  \n  method ParseIsoDateString(value: string) returns (result: Option<DateTime>)\n      (var d := result.value;\n       1 <= d.month <= 12 &&\n       1 <= d.day <= 31 &&\n       1 <= d.year <= 9999)\n  {\n    if !IsValidDateFormat(value) {\n      return None;\n    }\n    \n    var year := ParseInt(value[0..4]);\n    var month := ParseInt(value[5..7]);\n    var day := ParseInt(value[8..10]);\n    \n    if year.Some? && month.Some? && day.Some? &&\n       IsValidDate(year.value, month.value, day.value)\n    {\n      return Some(DateTime(year.value, month.value, day.value, 0, 0, 0, 0, None));\n    }\n    return None;\n  }\n  \n  predicate IsValidDateFormat(s: string)\n  {\n    && s[4] == '-'\n    && s[7] == '-'\n    && (forall i :: 0 <= i < 4 ==> '0' <= s[i] <= '9')\n    && (forall i :: 5 <= i < 7 ==> '0' <= s[i] <= '9')\n    && (forall i :: 8 <= i < 10 ==> '0' <= s[i] <= '9')\n  }\n  \n  predicate IsValidDate(year: int, month: int, day: int)\n  {\n    && 1 <= year <= 9999\n    && 1 <= month <= 12\n    && 1 <= day <= DaysInMonth(year, month)\n  }\n  \n  function DaysInMonth(year: int, month: int): int\n  {\n    if month in {4, 6, 9, 11} then 30\n    else if month == 2 then\n      if IsLeapYear(year) then 29 else 28\n    else 31\n  }\n  \n  predicate IsLeapYear(year: int)\n  {\n    && (year % 4 == 0)\n    && (year % 100 != 0 || year % 400 == 0)\n  }\n  \n  method ParseInt(s: string) returns (result: Option<int>)\n  {\n    \n    result := None; \n  }\n}", "output": "datatype Option<T> = None | Some(value: T)\ndatatype DateTime = DateTime(\n  year: int,\n  month: int,\n  day: int,\n  hour: int,\n  minute: int,\n  second: int,\n  microsecond: int,\n  timezone: Option<TimeZone>\n)\ndatatype TimeZone = FixedTimeZone(hours: int, minutes: int)\ndatatype TimeDelta = TimeDelta(hours: int, minutes: int)\nclass DateTimeUtil {\n  \n  method FromHoursMinutes(hours: int, minutes: int) returns (tz: TimeZone)\n    requires -23 <= hours <= 23  \n    requires -59 <= minutes <= 59  \n    ensures tz.hours == hours\n    ensures tz.minutes == minutes\n  {\n    tz := FixedTimeZone(hours, minutes);\n  }\n  \n  method ParseIsoDateString(value: string) returns (result: Option<DateTime>)\n    requires |value| >= 10  \n    ensures result.Some? ==> \n      (var d := result.value;\n       1 <= d.month <= 12 &&\n       1 <= d.day <= 31 &&\n       1 <= d.year <= 9999)\n  {\n    if !IsValidDateFormat(value) {\n      return None;\n    }\n    \n    var year := ParseInt(value[0..4]);\n    var month := ParseInt(value[5..7]);\n    var day := ParseInt(value[8..10]);\n    \n    if year.Some? && month.Some? && day.Some? &&\n       IsValidDate(year.value, month.value, day.value)\n    {\n      return Some(DateTime(year.value, month.value, day.value, 0, 0, 0, 0, None));\n    }\n    return None;\n  }\n  \n  predicate IsValidDateFormat(s: string)\n    requires |s| >= 10\n  {\n    && s[4] == '-'\n    && s[7] == '-'\n    && (forall i :: 0 <= i < 4 ==> '0' <= s[i] <= '9')\n    && (forall i :: 5 <= i < 7 ==> '0' <= s[i] <= '9')\n    && (forall i :: 8 <= i < 10 ==> '0' <= s[i] <= '9')\n  }\n  \n  predicate IsValidDate(year: int, month: int, day: int)\n  {\n    && 1 <= year <= 9999\n    && 1 <= month <= 12\n    && 1 <= day <= DaysInMonth(year, month)\n  }\n  \n  function DaysInMonth(year: int, month: int): int\n    requires 1 <= month <= 12\n  {\n    if month in {4, 6, 9, 11} then 30\n    else if month == 2 then\n      if IsLeapYear(year) then 29 else 28\n    else 31\n  }\n  \n  predicate IsLeapYear(year: int)\n  {\n    && (year % 4 == 0)\n    && (year % 100 != 0 || year % 400 == 0)\n  }\n  \n  method ParseInt(s: string) returns (result: Option<int>)\n  {\n    \n    result := None; \n  }\n}", "name": "py2dfy_97", "id": 97}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Image {\n  var width: nat\n  var height: nat\n  var pixels: array2<int>\n  constructor(w: nat, h: nat)\n  {\n    width := w;\n    height := h;\n    var h', w' := h, w;\n    pixels := new int[h', w'];\n  }\n}\ndatatype Face = Face(x: int, y: int, width: int, height: int)\nclass MQTTClient {\n  \n  method PublishFace(face: Face, imageData: array?<int>)\n  {\n    \n  }\n}\nclass FaceDetector {\n  \n  var cascade: array?<int>\n  constructor()\n  {\n    cascade := new int[1];  \n  }\n  \n  method DetectFaces(img: Image?) returns (faces: seq<Face>)\n      0 <= f.x < img.width &&\n      0 <= f.y < img.height &&\n      f.width > 0 && f.height > 0\n  {\n    var result: seq<Face> := [];\n    var y := 0;\n    \n    while y < img.height - 24\n        0 <= f.x < img.width &&\n        0 <= f.y < y &&\n        f.width > 0 && f.height > 0\n    {\n      var x := 0;\n      \n      while x < img.width - 24\n          0 <= f.x < img.width &&\n          0 <= f.y < y + 1 &&\n          f.width > 0 && f.height > 0\n      {\n        if IsFaceAtPosition(img, x, y)\n        {\n          var face := Face(x, y, 24, 24);\n          result := result + [face];\n        }\n        x := x + 4;\n      }\n      y := y + 4;\n    }\n    return result;\n  }\n  \n  predicate IsFaceAtPosition(img: Image?, x: int, y: int)\n  {\n    true  \n  }\n}\nmethod ProcessVideoStream(detector: FaceDetector?, mqtt: MQTTClient?)\n{\n  while true\n  {\n    var frame := GetNextFrame();\n    if frame != null && frame.width > 0 && frame.height > 0 {\n      var faces := detector.DetectFaces(frame);\n      \n      var i := 0;\n      while i < |faces|\n          0 <= f.x < frame.width &&\n          0 <= f.y < frame.height &&\n          f.width > 0 && f.height > 0\n      {\n        var face := faces[i];\n        var faceData := ExtractFaceData(frame, face);\n        mqtt.PublishFace(face, faceData);\n        i := i + 1;\n      }\n    }\n  }\n}\nmethod GetNextFrame() returns (img: Image?)\n{\n  var image := new Image(640, 480);\n  return image;\n}\nmethod ExtractFaceData(img: Image?, face: Face) returns (data: array?<int>)\n{\n  data := new int[1];  \n  return data;\n}", "output": "class Image {\n  var width: nat\n  var height: nat\n  var pixels: array2<int>\n  constructor(w: nat, h: nat)\n    ensures width == w && height == h\n    ensures pixels.Length0 == height && pixels.Length1 == width \n    ensures fresh(pixels)\n  {\n    width := w;\n    height := h;\n    var h', w' := h, w;\n    pixels := new int[h', w'];\n  }\n}\ndatatype Face = Face(x: int, y: int, width: int, height: int)\nclass MQTTClient {\n  \n  method PublishFace(face: Face, imageData: array?<int>)\n    requires imageData != null\n  {\n    \n  }\n}\nclass FaceDetector {\n  \n  var cascade: array?<int>\n  constructor()\n    ensures cascade != null\n    ensures fresh(cascade)\n  {\n    cascade := new int[1];  \n  }\n  \n  method DetectFaces(img: Image?) returns (faces: seq<Face>)\n    requires img != null\n    requires img.width > 0 && img.height > 0\n    ensures |faces| >= 0\n    ensures forall f :: f in faces ==>\n      0 <= f.x < img.width &&\n      0 <= f.y < img.height &&\n      f.width > 0 && f.height > 0\n  {\n    var result: seq<Face> := [];\n    var y := 0;\n    \n    while y < img.height - 24\n      invariant 0 <= y <= img.height\n      invariant forall f :: f in result ==>\n        0 <= f.x < img.width &&\n        0 <= f.y < y &&\n        f.width > 0 && f.height > 0\n    {\n      var x := 0;\n      \n      while x < img.width - 24\n        invariant 0 <= x <= img.width\n        invariant forall f :: f in result ==>\n          0 <= f.x < img.width &&\n          0 <= f.y < y + 1 &&\n          f.width > 0 && f.height > 0\n      {\n        if IsFaceAtPosition(img, x, y)\n        {\n          var face := Face(x, y, 24, 24);\n          result := result + [face];\n        }\n        x := x + 4;\n      }\n      y := y + 4;\n    }\n    return result;\n  }\n  \n  predicate IsFaceAtPosition(img: Image?, x: int, y: int)\n    requires img != null\n    requires 0 <= x < img.width\n    requires 0 <= y < img.height\n    reads img, img.pixels\n  {\n    true  \n  }\n}\nmethod ProcessVideoStream(detector: FaceDetector?, mqtt: MQTTClient?)\n  requires detector != null\n  requires mqtt != null\n  decreases *\n{\n  while true\n    decreases *\n  {\n    var frame := GetNextFrame();\n    if frame != null && frame.width > 0 && frame.height > 0 {\n      var faces := detector.DetectFaces(frame);\n      \n      var i := 0;\n      while i < |faces|\n        invariant 0 <= i <= |faces|\n        invariant forall f :: f in faces ==>\n          0 <= f.x < frame.width &&\n          0 <= f.y < frame.height &&\n          f.width > 0 && f.height > 0\n      {\n        var face := faces[i];\n        var faceData := ExtractFaceData(frame, face);\n        mqtt.PublishFace(face, faceData);\n        i := i + 1;\n      }\n    }\n  }\n}\nmethod GetNextFrame() returns (img: Image?)\n{\n  var image := new Image(640, 480);\n  return image;\n}\nmethod ExtractFaceData(img: Image?, face: Face) returns (data: array?<int>)\n  requires img != null\n  requires 0 <= face.x < img.width\n  requires 0 <= face.y < img.height\n  ensures data != null\n{\n  data := new int[1];  \n  return data;\n}", "name": "py2dfy_28", "id": 28}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype ExamStatus = Available | Submitted | NotAvailable\nclass ExamTicket {\n  var score: Option<real>\n}\nclass ExamSession {\n  var startTime: int\n  var duration: int \n  var tickets: seq<ExamTicket>\n  var status: ExamStatus\n  var finishedAt: Option<int>\n  \n  constructor(start: int, dur: int, examTickets: seq<ExamTicket>)\n  {\n    startTime := start;\n    duration := dur;\n    tickets := examTickets;\n    status := Available;\n    finishedAt := None;\n  }\n  method GetTotalScore() returns (total: Option<real>)\n  {\n    var sum := 0.0;\n    var allScored := true;\n    var i := 0;\n    \n    while i < |tickets|\n    {\n      if tickets[i].score == None {\n        allScored := false;\n        return None;\n      }\n      sum := sum + tickets[i].score.value;\n      i := i + 1;\n    }\n    \n    return Some(sum);\n  }\n  \n  function SumScoresHelper(ticketSeq: seq<ExamTicket>, upTo: int): real\n  {\n    if upTo == 0 then 0.0\n    else SumScoresHelper(ticketSeq, upTo-1) + ticketSeq[upTo-1].score.value\n  }\n  \n  method Submit(currentTime: int) returns (success: bool)\n  {\n    if status == Available {\n      status := Submitted;\n      finishedAt := Some(currentTime);\n      return true;\n    }\n    return false;\n  }\n}", "output": "datatype Option<T> = None | Some(value: T)\ndatatype ExamStatus = Available | Submitted | NotAvailable\nclass ExamTicket {\n  var score: Option<real>\n}\nclass ExamSession {\n  var startTime: int\n  var duration: int \n  var tickets: seq<ExamTicket>\n  var status: ExamStatus\n  var finishedAt: Option<int>\n  \n  constructor(start: int, dur: int, examTickets: seq<ExamTicket>)\n    requires start >= 0\n    requires dur > 0 \n    ensures startTime == start\n    ensures duration == dur\n    ensures tickets == examTickets\n    ensures status == Available\n    ensures finishedAt == None\n  {\n    startTime := start;\n    duration := dur;\n    tickets := examTickets;\n    status := Available;\n    finishedAt := None;\n  }\n  method GetTotalScore() returns (total: Option<real>)\n    ensures total == None ==> exists t :: t in tickets && t.score == None\n    ensures total != None ==> forall t :: t in tickets ==> t.score != None\n    ensures total != None ==> total.value == SumScoresHelper(tickets, |tickets|)\n    ensures total != None ==> forall i :: 0 <= i < |tickets| ==> tickets[i].score != None\n  {\n    var sum := 0.0;\n    var allScored := true;\n    var i := 0;\n    \n    while i < |tickets|\n      invariant 0 <= i <= |tickets|\n      invariant allScored ==> forall j :: 0 <= j < i ==> tickets[j].score != None\n      invariant sum == (if i > 0 then SumScoresHelper(tickets, i) else 0.0)\n      invariant allScored ==> forall j :: 0 <= j < i ==> tickets[j].score != None\n      decreases |tickets| - i\n    {\n      if tickets[i].score == None {\n        allScored := false;\n        return None;\n      }\n      sum := sum + tickets[i].score.value;\n      i := i + 1;\n    }\n    \n    return Some(sum);\n  }\n  \n  function SumScoresHelper(ticketSeq: seq<ExamTicket>, upTo: int): real\n    requires 0 <= upTo <= |ticketSeq|\n    requires forall i :: 0 <= i < upTo ==> ticketSeq[i].score != None\n    reads ticketSeq, set t | t in ticketSeq[..upTo] :: t`score\n  {\n    if upTo == 0 then 0.0\n    else SumScoresHelper(ticketSeq, upTo-1) + ticketSeq[upTo-1].score.value\n  }\n  \n  method Submit(currentTime: int) returns (success: bool)\n    requires currentTime >= startTime\n    modifies this\n    ensures old(status) == Available ==> status == Submitted && finishedAt == Some(currentTime)\n    ensures old(status) != Available ==> status == old(status) && finishedAt == old(finishedAt)\n    ensures success <==> old(status) == Available\n  {\n    if status == Available {\n      status := Submitted;\n      finishedAt := Some(currentTime);\n      return true;\n    }\n    return false;\n  }\n}", "name": "py2dfy_99", "id": 99}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module CryptoExchangeInterfaces {\n  trait ExchangeInterface {\n    predicate Valid()\n    {\n      true \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n  }\n  class Ticker {\n    var price: real\n    var volume: real\n    predicate Valid()\n    {\n      price >= 0.0 && volume >= 0.0\n    }\n    constructor(p: real, v: real)\n    {\n      price := p;\n      volume := v;\n    }\n  }\n  class Bitfinex extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 100.0;\n      var volume := 1000.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Bittrex extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 101.0;\n      var volume := 1001.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Poloniex extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 102.0;\n      var volume := 1002.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Bithumb extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 103.0;\n      var volume := 1003.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Coinone extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 104.0;\n      var volume := 1004.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Korbit extends ExchangeInterface {\n    constructor()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    {\n      \n      var price := 105.0;\n      var volume := 1005.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  method Main() {\n    var bitfinex := new Bitfinex();\n    var bittrex := new Bittrex();\n    var poloniex := new Poloniex();\n    var bithumb := new Bithumb();\n    var coinone := new Coinone();\n    var korbit := new Korbit();\n    \n  }\n}", "output": "module CryptoExchangeInterfaces {\n  trait ExchangeInterface {\n    predicate Valid()\n    reads this\n    {\n      true \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n  }\n  class Ticker {\n    var price: real\n    var volume: real\n    predicate Valid()\n    reads this\n    {\n      price >= 0.0 && volume >= 0.0\n    }\n    constructor(p: real, v: real)\n    requires p >= 0.0 && v >= 0.0\n    ensures Valid() && price == p && volume == v\n    {\n      price := p;\n      volume := v;\n    }\n  }\n  class Bitfinex extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 100.0;\n      var volume := 1000.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Bittrex extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 101.0;\n      var volume := 1001.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Poloniex extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 102.0;\n      var volume := 1002.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Bithumb extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 103.0;\n      var volume := 1003.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Coinone extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 104.0;\n      var volume := 1004.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  class Korbit extends ExchangeInterface {\n    constructor()\n    ensures Valid()\n    {\n      \n    }\n    method GetTicker(symbol: string) returns (ticker: Ticker?)\n    requires Valid()\n    ensures Valid()\n    ensures ticker != null ==> ticker.Valid()\n    {\n      \n      var price := 105.0;\n      var volume := 1005.0;\n      ticker := new Ticker(price, volume);\n    }\n  }\n  method Main() {\n    var bitfinex := new Bitfinex();\n    var bittrex := new Bittrex();\n    var poloniex := new Poloniex();\n    var bithumb := new Bithumb();\n    var coinone := new Coinone();\n    var korbit := new Korbit();\n    \n  }\n}", "name": "py2dfy_79", "id": 79}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Frequency = Daily | Weekly | Monthly\nclass Tag {\n  var name: string\n  var slug: string  \n  var createdAt: int  \n  var updatedAt: int\n  \n  \n  predicate Valid()\n  {\n    |name| <= 100 &&      \n    |slug| <= 150 &&\n    createdAt >= 0 &&     \n    updatedAt >= createdAt\n  }\n  constructor(name_: string)\n  {\n    var currentTime := GetCurrentTime();\n    name := name_;\n    slug := Slugify(name_);\n    createdAt := currentTime;\n    updatedAt := currentTime;\n  }\n  \n  static function Slugify(s: string): string\n  {\n    \n    s\n  }\n  \n  static method GetCurrentTime() returns (time: int)\n  {\n    \n    time := 0;\n  }\n}\nclass Newsletter {\n  var name: string\n  var description: string\n  var target: int\n  var frequency: Frequency\n  var createdAt: int\n  var updatedAt: int\n  var author: string  \n  var tags: seq<Tag?>  \n  \n  predicate Valid()\n  {\n    |name| <= 200 &&\n    |description| <= 10000 &&\n    target >= 0 &&\n    createdAt >= 0 &&\n    updatedAt >= createdAt &&\n    forall t :: t in tags ==> t != null && t.Valid()\n  }\n  constructor(name_: string, desc: string, target_: int)\n  {\n    var currentTime := Tag.GetCurrentTime();\n    name := name_;\n    description := desc;\n    target := target_;\n    frequency := Monthly;\n    createdAt := currentTime;\n    updatedAt := currentTime;\n    author := \"\";\n    tags := [];\n  }\n  \n  function GetSubscriberCount(): int\n  {\n    10  \n  }\n  \n  method AddTag(tag: Tag?)\n  {\n    tags := tags + [tag];\n  }\n}", "output": "datatype Frequency = Daily | Weekly | Monthly\nclass Tag {\n  var name: string\n  var slug: string  \n  var createdAt: int  \n  var updatedAt: int\n  \n  \n  predicate Valid()\n  reads this\n  {\n    |name| <= 100 &&      \n    |slug| <= 150 &&\n    createdAt >= 0 &&     \n    updatedAt >= createdAt\n  }\n  constructor(name_: string)\n  requires |name_| <= 100\n  ensures Valid()\n  ensures name == name_\n  ensures createdAt == updatedAt\n  {\n    var currentTime := GetCurrentTime();\n    name := name_;\n    slug := Slugify(name_);\n    createdAt := currentTime;\n    updatedAt := currentTime;\n  }\n  \n  static function Slugify(s: string): string\n  ensures |Slugify(s)| <= |s|  \n  {\n    \n    s\n  }\n  \n  static method GetCurrentTime() returns (time: int)\n  ensures time >= 0\n  {\n    \n    time := 0;\n  }\n}\nclass Newsletter {\n  var name: string\n  var description: string\n  var target: int\n  var frequency: Frequency\n  var createdAt: int\n  var updatedAt: int\n  var author: string  \n  var tags: seq<Tag?>  \n  \n  predicate Valid()\n  reads this, tags\n  {\n    |name| <= 200 &&\n    |description| <= 10000 &&\n    target >= 0 &&\n    createdAt >= 0 &&\n    updatedAt >= createdAt &&\n    forall t :: t in tags ==> t != null && t.Valid()\n  }\n  constructor(name_: string, desc: string, target_: int)\n  requires |name_| <= 200\n  requires |desc| <= 10000\n  requires target_ >= 0\n  ensures Valid()\n  ensures name == name_\n  ensures description == desc\n  ensures target == target_\n  ensures frequency == Monthly  \n  ensures fresh(tags)\n  {\n    var currentTime := Tag.GetCurrentTime();\n    name := name_;\n    description := desc;\n    target := target_;\n    frequency := Monthly;\n    createdAt := currentTime;\n    updatedAt := currentTime;\n    author := \"\";\n    tags := [];\n  }\n  \n  function GetSubscriberCount(): int\n  reads this\n  ensures GetSubscriberCount() >= 0\n  {\n    10  \n  }\n  \n  method AddTag(tag: Tag?)\n  requires tag != null\n  requires tag.Valid()\n  requires Valid()\n  modifies this`tags\n  ensures Valid()\n  ensures tag in tags\n  ensures forall t :: t in old(tags) ==> t in tags\n  ensures |tags| == |old(tags)| + 1\n  {\n    tags := tags + [tag];\n  }\n}", "name": "py2dfy_98", "id": 98}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module BirthdayDictionary {\n    \n    type Dictionary = seq<(string, string)>\n    \n    function Contains(dict: Dictionary, key: string): bool\n    {\n        exists i :: 0 <= i < |dict| && dict[i].0 == key\n    }\n    \n    function Get(dict: Dictionary, key: string): string\n    {\n        \n        if |dict| == 0 then \"\"  \n        else if dict[0].0 == key then dict[0].1\n        else Get(dict[1..], key)\n    }\n    \n    method PrintNames(dict: Dictionary)\n    {\n        print \"Welcome to the birthday dictionary. We know the birthdays of:\\n\";\n        var i := 0;\n        while i < |dict|\n        {\n            print dict[i].0, \"\\n\";\n            i := i + 1;\n        }\n    }\n    \n    method Main()\n    {\n        var birthdays: Dictionary := [\n            (\"Albert Einstein\", \"03/14/1879\"),\n            (\"Benjamin Franklin\", \"01/17/1706\"),\n            (\"Ada Lovelace\", \"12/10/1815\")\n        ];\n        PrintNames(birthdays);\n        print \"Who's birthday do you want to look up?\\n\";\n        var name := ReadLine();\n        if Contains(birthdays, name) {\n            var birthday := Get(birthdays, name);\n            print name, \"'s birthday is \", birthday, \".\\n\";\n        } else {\n            print \"Sorry, we don't have birthday information for \", name, \".\\n\";\n        }\n    }\n    \n    method {:extern} ReadLine() returns (s: string)\n}", "output": "module BirthdayDictionary {\n    \n    type Dictionary = seq<(string, string)>\n    \n    function Contains(dict: Dictionary, key: string): bool\n    {\n        exists i :: 0 <= i < |dict| && dict[i].0 == key\n    }\n    \n    function Get(dict: Dictionary, key: string): string\n    requires Contains(dict, key)\n    {\n        \n        if |dict| == 0 then \"\"  \n        else if dict[0].0 == key then dict[0].1\n        else Get(dict[1..], key)\n    }\n    \n    method PrintNames(dict: Dictionary)\n    {\n        print \"Welcome to the birthday dictionary. We know the birthdays of:\\n\";\n        var i := 0;\n        while i < |dict|\n        invariant 0 <= i <= |dict|\n        {\n            print dict[i].0, \"\\n\";\n            i := i + 1;\n        }\n    }\n    \n    method Main()\n    {\n        var birthdays: Dictionary := [\n            (\"Albert Einstein\", \"03/14/1879\"),\n            (\"Benjamin Franklin\", \"01/17/1706\"),\n            (\"Ada Lovelace\", \"12/10/1815\")\n        ];\n        PrintNames(birthdays);\n        print \"Who's birthday do you want to look up?\\n\";\n        var name := ReadLine();\n        if Contains(birthdays, name) {\n            var birthday := Get(birthdays, name);\n            print name, \"'s birthday is \", birthday, \".\\n\";\n        } else {\n            print \"Sorry, we don't have birthday information for \", name, \".\\n\";\n        }\n    }\n    \n    method {:extern} ReadLine() returns (s: string)\n}", "name": "py2dfy_102", "id": 102}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype NestedList = Atom(value: string) | List(elements: seq<NestedList>)\nclass Comparator {\n    function TupleToString(tuptup: NestedList): (result: string)\n    {\n        if tuptup.Atom? then\n            tuptup.value\n        else\n            \"|\" + JoinWithSeparator(tuptup.elements, \";\")\n    }\n    function JoinWithSeparator(elements: seq<NestedList>, separator: string): string\n    {\n        if |elements| == 0 then\n            \"\"\n        else if |elements| == 1 then\n            TupleToString(elements[0])\n        else\n            TupleToString(elements[0]) + separator + JoinWithSeparator(elements[1..], separator)\n    }\n    function EqualityCompare(objA: NestedList, objB: NestedList): bool\n    {\n        TupleToString(objA) == TupleToString(objB)\n    }\n    function NVCCompare(objA: NestedList, objB: NestedList): bool\n    {\n        (TupleToString(objA) == \"NVC\") == (TupleToString(objB) == \"NVC\")\n    }\n}", "output": "datatype NestedList = Atom(value: string) | List(elements: seq<NestedList>)\nclass Comparator {\n    function TupleToString(tuptup: NestedList): (result: string)\n        ensures tuptup.Atom? ==> result == tuptup.value\n    {\n        if tuptup.Atom? then\n            tuptup.value\n        else\n            \"|\" + JoinWithSeparator(tuptup.elements, \";\")\n    }\n    function JoinWithSeparator(elements: seq<NestedList>, separator: string): string\n    {\n        if |elements| == 0 then\n            \"\"\n        else if |elements| == 1 then\n            TupleToString(elements[0])\n        else\n            TupleToString(elements[0]) + separator + JoinWithSeparator(elements[1..], separator)\n    }\n    function EqualityCompare(objA: NestedList, objB: NestedList): bool\n    {\n        TupleToString(objA) == TupleToString(objB)\n    }\n    function NVCCompare(objA: NestedList, objB: NestedList): bool\n    {\n        (TupleToString(objA) == \"NVC\") == (TupleToString(objB) == \"NVC\")\n    }\n}", "name": "py2dfy_113", "id": 113}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Socket {\n  var isConnected: bool\n  var buffer: seq<char>\n  constructor()\n  {\n    isConnected := false;\n    buffer := [];\n  }\n  method Connect(host: string, port: int) returns (success: bool)\n  {\n    \n    success := true;\n    if success {\n      isConnected := true;\n    }\n  }\n  method Send(data: seq<char>)\n  {\n    buffer := buffer + data;\n  }\n  method Receive() returns (data: seq<char>)\n  {\n    if |buffer| > 0 {\n      data := buffer[..];\n      buffer := [];\n    } else {\n      data := [];\n    }\n  }\n  method Close()\n  {\n    isConnected := false;\n    buffer := [];\n  }\n}\nmethod Main()\n{\n  var socket := new Socket();\n  var connected := socket.Connect(\"127.0.0.1\", 8282);\n  \n  if connected {\n    print \"Connected successfully\\n\";\n    \n    var keepRunning := true;\n    var count := 5; \n    \n    while keepRunning && count > 0\n    {\n      print \"Enter a sentence: \";\n      var input := ReadLine();\n      if |input| > 0 {\n        socket.Send(input + ['<', 'E', 'n', 'd', '>']);\n        var response := socket.Receive();\n        print \"\\n\";\n      }\n      count := count - 1;\n      if count == 0 {\n        keepRunning := false;\n      }\n    }\n    \n    socket.Close();\n  } else {\n    print \"Connection failed\\n\";\n  }\n}\nmethod ReadLine() returns (line: seq<char>)\n{\n  \n  line := ['S', 'a', 'm', 'p', 'l', 'e', ' ', 'i', 'n', 'p', 'u', 't'];\n}", "output": "class Socket {\n  var isConnected: bool\n  var buffer: seq<char>\n  constructor()\n    ensures isConnected == false\n    ensures buffer == []\n  {\n    isConnected := false;\n    buffer := [];\n  }\n  method Connect(host: string, port: int) returns (success: bool)\n    modifies this\n    ensures success ==> isConnected\n    ensures !success ==> !isConnected\n    ensures old(buffer) == buffer\n  {\n    \n    success := true;\n    if success {\n      isConnected := true;\n    }\n  }\n  method Send(data: seq<char>)\n    requires isConnected\n    modifies this\n    ensures isConnected  \n    ensures |buffer| == |old(buffer)| + |data|\n    ensures buffer[..|old(buffer)|] == old(buffer)\n    ensures buffer[|old(buffer)|..] == data\n  {\n    buffer := buffer + data;\n  }\n  method Receive() returns (data: seq<char>)\n    requires isConnected\n    modifies this\n    ensures isConnected  \n    ensures |data| <= |old(buffer)|\n    ensures old(buffer) == data + buffer\n  {\n    if |buffer| > 0 {\n      data := buffer[..];\n      buffer := [];\n    } else {\n      data := [];\n    }\n  }\n  method Close()\n    modifies this\n    ensures !isConnected\n    ensures buffer == []\n  {\n    isConnected := false;\n    buffer := [];\n  }\n}\nmethod Main()\n{\n  var socket := new Socket();\n  var connected := socket.Connect(\"127.0.0.1\", 8282);\n  \n  if connected {\n    print \"Connected successfully\\n\";\n    \n    var keepRunning := true;\n    var count := 5; \n    \n    while keepRunning && count > 0\n      invariant socket.isConnected\n      invariant count >= 0\n      decreases count\n      modifies socket\n    {\n      print \"Enter a sentence: \";\n      var input := ReadLine();\n      if |input| > 0 {\n        socket.Send(input + ['<', 'E', 'n', 'd', '>']);\n        var response := socket.Receive();\n        print \"\\n\";\n      }\n      count := count - 1;\n      if count == 0 {\n        keepRunning := false;\n      }\n    }\n    \n    socket.Close();\n  } else {\n    print \"Connection failed\\n\";\n  }\n}\nmethod ReadLine() returns (line: seq<char>)\n  ensures |line| >= 0\n{\n  \n  line := ['S', 'a', 'm', 'p', 'l', 'e', ' ', 'i', 'n', 'p', 'u', 't'];\n}", "name": "py2dfy_104", "id": 104}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ConfidenceInterval = CI(lower: real, upper: real)\nmethod ConfidenceIntervalBounds(avg: real, standardError: real) returns (ci: ConfidenceInterval)\n    \n    \n    \n    \n    \n{\n    \n    var lower := avg - 2.0 * standardError;\n    var upper := avg + 2.0 * standardError;\n    \n    \n    ci := CI(lower, upper);\n}\nmethod Main()\n{\n    var ci := ConfidenceIntervalBounds(40.0, 2.71);\n    print \"Confidence Interval: [\", ci.lower, \", \", ci.upper, \"]\\n\";\n}", "output": "datatype ConfidenceInterval = CI(lower: real, upper: real)\nmethod ConfidenceIntervalBounds(avg: real, standardError: real) returns (ci: ConfidenceInterval)\n    \n    requires standardError > 0.0\n    \n    ensures ci.upper > ci.lower\n    \n    ensures ci.upper - avg == avg - ci.lower\n    \n    ensures ci.upper - ci.lower == 4.0 * standardError\n    \n    ensures avg == (ci.lower + ci.upper) / 2.0\n{\n    \n    var lower := avg - 2.0 * standardError;\n    var upper := avg + 2.0 * standardError;\n    \n    \n    ci := CI(lower, upper);\n}\nmethod Main()\n{\n    var ci := ConfidenceIntervalBounds(40.0, 2.71);\n    print \"Confidence Interval: [\", ci.lower, \", \", ci.upper, \"]\\n\";\n}", "name": "py2dfy_107", "id": 107}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function Sum(\n  ghost remaining: nat,\n  n: nat\n): (p: nat -> nat)\n{\n  (pos: nat) =>\n    var x: nat := if n == 0 then 0 else Sum(remaining - 1, n - 1)(pos+1) + pos;\n    x\n}\nmethod Main() {\n  print Sum(5, 5)(10);\n}", "output": "function Sum(\n  ghost remaining: nat,\n  n: nat\n): (p: nat -> nat)\n  decreases remaining\n  requires remaining == n\n{\n  (pos: nat) =>\n    var x: nat := if n == 0 then 0 else Sum(remaining - 1, n - 1)(pos+1) + pos;\n    x\n}\nmethod Main() {\n  print Sum(5, 5)(10);\n}", "name": "py2dfy_142", "id": 142}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait AppConfig {\n    \n    var name: string\n    \n    predicate Valid()\n    {\n        name != \"\"  \n    }\n    \n    \n    method GetName() returns (result: string)\n    {\n        result := name;\n    }\n}\nclass AbstractbaseclassesConfig extends AppConfig {\n    constructor()\n    {\n        name := \"abstractbaseclasses\";\n    }\n}", "output": "trait AppConfig {\n    \n    var name: string\n    \n    predicate Valid()\n        reads this\n    {\n        name != \"\"  \n    }\n    \n    \n    method GetName() returns (result: string)\n        requires Valid()  \n        ensures result == name  \n        ensures result != \"\"    \n    {\n        result := name;\n    }\n}\nclass AbstractbaseclassesConfig extends AppConfig {\n    constructor()\n        ensures name == \"abstractbaseclasses\"  \n        ensures Valid()                        \n    {\n        name := \"abstractbaseclasses\";\n    }\n}", "name": "py2dfy_148", "id": 148}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DatabaseConfig {\n  var hostname: string\n  var username: string  \n  var password: string\n  var database: string\n  ghost var isConnected: bool\n  ghost var hasCursor: bool\n  constructor(host: string, user: string, pass: string, db: string)\n  {\n    hostname := host;\n    username := user;\n    password := pass;\n    database := db;\n    isConnected := false;\n    hasCursor := false;\n  }\n  method Connect() returns (success: bool)\n  {\n    success := true;\n    if success {\n      isConnected := true;\n    }\n  }\n  method GetCursor() returns (success: bool)\n  {\n    success := true;\n    if success {\n      hasCursor := true;\n    }\n  }\n  method ExecuteQuery(queryType: string, sql: string) returns (result: seq<seq<string>>)\n  {\n    if queryType == \"SELECT\" {\n      var row := [\"dummy_data\"];\n      result := [row];\n    } else {\n      result := [];\n    }\n  }\n  method Query(queryType: string, sql: string) returns (result: seq<seq<string>>)\n  {\n    var connectSuccess := Connect();\n    if !connectSuccess {\n      return [];\n    }\n    \n    var cursorSuccess := GetCursor();\n    if !cursorSuccess {\n      return [];\n    }\n    \n    result := ExecuteQuery(queryType, sql);\n  }\n}", "output": "class DatabaseConfig {\n  var hostname: string\n  var username: string  \n  var password: string\n  var database: string\n  ghost var isConnected: bool\n  ghost var hasCursor: bool\n  constructor(host: string, user: string, pass: string, db: string)\n    ensures hostname == host\n    ensures username == user \n    ensures password == pass\n    ensures database == db\n    ensures !isConnected && !hasCursor\n  {\n    hostname := host;\n    username := user;\n    password := pass;\n    database := db;\n    isConnected := false;\n    hasCursor := false;\n  }\n  method Connect() returns (success: bool)\n    modifies this\n    ensures old(isConnected) ==> isConnected\n    ensures success ==> isConnected\n    ensures !success ==> !isConnected\n    ensures success ==> isConnected == true\n  {\n    success := true;\n    if success {\n      isConnected := true;\n    }\n  }\n  method GetCursor() returns (success: bool)\n    requires isConnected\n    modifies this\n    ensures old(hasCursor) ==> hasCursor\n    ensures success ==> hasCursor\n    ensures !success ==> !hasCursor\n    ensures isConnected == old(isConnected)\n  {\n    success := true;\n    if success {\n      hasCursor := true;\n    }\n  }\n  method ExecuteQuery(queryType: string, sql: string) returns (result: seq<seq<string>>)\n    requires isConnected && hasCursor\n    requires queryType in {\"SELECT\", \"INSERT\", \"UPDATE\", \"DELETE\"}\n    modifies this\n    ensures queryType == \"SELECT\" ==> |result| >= 0\n    ensures queryType != \"SELECT\" ==> |result| == 0\n    ensures isConnected == old(isConnected)\n    ensures hasCursor == old(hasCursor)\n  {\n    if queryType == \"SELECT\" {\n      var row := [\"dummy_data\"];\n      result := [row];\n    } else {\n      result := [];\n    }\n  }\n  method Query(queryType: string, sql: string) returns (result: seq<seq<string>>)\n    requires queryType in {\"SELECT\", \"INSERT\", \"UPDATE\", \"DELETE\"}\n    modifies this\n    ensures queryType == \"SELECT\" ==> |result| >= 0\n    ensures queryType != \"SELECT\" ==> |result| == 0\n  {\n    var connectSuccess := Connect();\n    if !connectSuccess {\n      return [];\n    }\n    \n    var cursorSuccess := GetCursor();\n    if !cursorSuccess {\n      return [];\n    }\n    \n    result := ExecuteQuery(queryType, sql);\n  }\n}", "name": "py2dfy_105", "id": 105}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CalculatePayment(horast: int, tarifa: int, descu: int) returns (payment: int)\n          (horast <= 40 ==> payment == horast * tarifa)\n{\n  var resp0 := horast - descu;\n  var resp1 := (resp0 * tarifa) / 2;\n  var resp2 := (horast * tarifa) + resp1;\n  var resp3 := resp2 - descu;\n  var resp4 := horast * tarifa;\n  if horast >= 41 {\n    payment := resp3;\n  } else {\n    payment := resp4;\n  }\n}", "output": "method CalculatePayment(horast: int, tarifa: int, descu: int) returns (payment: int)\n  requires horast >= 0 && tarifa >= 0 && descu >= 0\n  ensures (horast >= 41 ==> payment == ((horast - descu) * tarifa) / 2 + (horast * tarifa) - descu) &&\n          (horast <= 40 ==> payment == horast * tarifa)\n{\n  var resp0 := horast - descu;\n  var resp1 := (resp0 * tarifa) / 2;\n  var resp2 := (horast * tarifa) + resp1;\n  var resp3 := resp2 - descu;\n  var resp4 := horast * tarifa;\n  if horast >= 41 {\n    payment := resp3;\n  } else {\n    payment := resp4;\n  }\n}", "name": "py2dfy_114", "id": 114}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class CriteriaForm {\n    var query: string\n    constructor()\n    {\n        query := \"\";\n    }\n    method SetQuery(input: string) \n    {\n        query := input;\n    }\n    method GetQuery() returns (result: string)\n    {\n        return query;\n    }\n    method IsValid() returns (valid: bool)\n    {\n        valid := |query| > 0;\n    }\n}", "output": "class CriteriaForm {\n    var query: string\n    constructor()\n    ensures query == \"\"  \n    {\n        query := \"\";\n    }\n    method SetQuery(input: string) \n        modifies this\n        ensures query == input\n        ensures |query| == |input|\n    {\n        query := input;\n    }\n    method GetQuery() returns (result: string)\n        ensures result == query\n    {\n        return query;\n    }\n    method IsValid() returns (valid: bool)\n        ensures valid <==> |query| > 0\n        ensures valid ==> query != \"\"\n    {\n        valid := |query| > 0;\n    }\n}", "name": "py2dfy_108", "id": 108}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ServiceCommand = ServiceCommand(\n  service: string,\n  command: string,\n  payload: seq<char>\n)\ndatatype CommandResult = \n  | Success(response: string)\n  | Error(message: string)\n  | NoResponse\nclass NetworkConnection {\n  \n  var isConnected: bool\n  var host: string  \n  var port: int\n  \n  constructor(host: string, port: int)\n  {\n    this.host := host;\n    this.port := port;\n    this.isConnected := false;\n  }\n  method Connect() returns (success: bool)\n  {\n    \n    if !isConnected {\n      \n      success := true;  \n      if success {\n        isConnected := true;\n      }\n    } else {\n      success := true;\n    }\n  }\n  method SendCommand(cmd: ServiceCommand) returns (result: CommandResult)\n  {\n    \n    var message := BuildCommandMessage(cmd);\n    \n    \n    if cmd.command == \"stop_all\" {\n      return NoResponse;\n    }\n    \n    \n    var response := SimulateResponse(message);\n    if response.Success? {\n      return Success(response.response);\n    } else {\n      return Error(\"Failed to receive response\");\n    }\n  }\n  method BuildCommandMessage(cmd: ServiceCommand) returns (message: string)\n  {\n    if |cmd.payload| > 0 {\n      message := \"{\\\"service\\\":\\\"\" + cmd.service + \n                 \"\\\",\\\"command\\\":\\\"\" + cmd.command +\n                 \"\\\",\\\"payload\\\":\\\"\" + seq_to_string(cmd.payload) + \"\\\"}\";\n    } else {\n      message := \"{\\\"service\\\":\\\"\" + cmd.service + \n                 \"\\\",\\\"command\\\":\\\"\" + cmd.command + \"\\\"}\";\n    }\n  }\n  function seq_to_string(s: seq<char>): string {\n    if |s| == 0 then \"\"\n    else string_of_char(s[0]) + seq_to_string(s[1..])\n  }\n  function string_of_char(c: char): string {\n    [c]\n  }\n  \n  method SimulateResponse(message: string) returns (result: CommandResult)\n  {\n    \n    return Success(\"OK\");\n  }\n}\nmethod ExecuteCommand(\n  service: string, \n  command: string, \n  payload: seq<char>, \n  host: string, \n  port: int\n) returns (result: CommandResult)\n{\n  var conn := new NetworkConnection(host, port);\n  var connected := conn.Connect();\n  \n  if !connected {\n    return Error(\"Failed to connect to host\");  \n  }\n  \n  var cmd := ServiceCommand(service, command, payload);\n  result := conn.SendCommand(cmd);\n  if result.Error? {\n    \n    if |result.message| == 0 {\n      result := Error(\"Unknown error occurred\");\n    }\n  }\n}", "output": "datatype ServiceCommand = ServiceCommand(\n  service: string,\n  command: string,\n  payload: seq<char>\n)\ndatatype CommandResult = \n  | Success(response: string)\n  | Error(message: string)\n  | NoResponse\nclass NetworkConnection {\n  \n  var isConnected: bool\n  var host: string  \n  var port: int\n  \n  constructor(host: string, port: int)\n    requires port > 0 && port < 65536  \n    ensures this.host == host\n    ensures this.port == port\n    ensures !isConnected\n  {\n    this.host := host;\n    this.port := port;\n    this.isConnected := false;\n  }\n  method Connect() returns (success: bool)\n    modifies this\n    ensures old(isConnected) ==> isConnected == old(isConnected)\n    ensures success ==> isConnected\n    ensures !success ==> !isConnected\n  {\n    \n    if !isConnected {\n      \n      success := true;  \n      if success {\n        isConnected := true;\n      }\n    } else {\n      success := true;\n    }\n  }\n  method SendCommand(cmd: ServiceCommand) returns (result: CommandResult)\n    requires isConnected\n    modifies this\n    ensures isConnected  \n  {\n    \n    var message := BuildCommandMessage(cmd);\n    \n    \n    if cmd.command == \"stop_all\" {\n      return NoResponse;\n    }\n    \n    \n    var response := SimulateResponse(message);\n    if response.Success? {\n      return Success(response.response);\n    } else {\n      return Error(\"Failed to receive response\");\n    }\n  }\n  method BuildCommandMessage(cmd: ServiceCommand) returns (message: string)\n    ensures |message| > 0\n  {\n    if |cmd.payload| > 0 {\n      message := \"{\\\"service\\\":\\\"\" + cmd.service + \n                 \"\\\",\\\"command\\\":\\\"\" + cmd.command +\n                 \"\\\",\\\"payload\\\":\\\"\" + seq_to_string(cmd.payload) + \"\\\"}\";\n    } else {\n      message := \"{\\\"service\\\":\\\"\" + cmd.service + \n                 \"\\\",\\\"command\\\":\\\"\" + cmd.command + \"\\\"}\";\n    }\n  }\n  function seq_to_string(s: seq<char>): string {\n    if |s| == 0 then \"\"\n    else string_of_char(s[0]) + seq_to_string(s[1..])\n  }\n  function string_of_char(c: char): string {\n    [c]\n  }\n  \n  method SimulateResponse(message: string) returns (result: CommandResult)\n    requires |message| > 0\n    ensures result.Success? ==> |result.response| > 0\n  {\n    \n    return Success(\"OK\");\n  }\n}\nmethod ExecuteCommand(\n  service: string, \n  command: string, \n  payload: seq<char>, \n  host: string, \n  port: int\n) returns (result: CommandResult)\n  requires port > 0 && port < 65536\n  requires |service| > 0\n  requires |command| > 0\n  requires |host| > 0\n  ensures result.Error? ==> |result.message| > 0\n{\n  var conn := new NetworkConnection(host, port);\n  var connected := conn.Connect();\n  \n  if !connected {\n    return Error(\"Failed to connect to host\");  \n  }\n  \n  var cmd := ServiceCommand(service, command, payload);\n  result := conn.SendCommand(cmd);\n  if result.Error? {\n    \n    if |result.message| == 0 {\n      result := Error(\"Unknown error occurred\");\n    }\n  }\n}", "name": "py2dfy_106", "id": 106}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main()\n{\n    \n    print \"Hello world\\n\";\n    \n    BasicMath();\n    \n    VariableOps();\n    \n    DataTypes();\n    \n    TypeConversion();\n    \n    BasicFunctions();\n    \n    ObjectComparison();\n}\nmethod BasicMath()\n{\n    print 1 + 1, \"\\n\";\n    print 2 - 3, \"\\n\";\n    print 3 % 2, \"\\n\";  \n    print 3 / 2, \"\\n\";  \n    print 3.0 / 2.0, \"\\n\";  \n    print 3 * 2, \"\\n\";\n    print 3 * 3, \"\\n\";  \n}\nmethod VariableOps()\n{\n    var x := 10;\n    x := x + 3;\n    print x, \"\\n\";\n    x := x * 3;\n    print x, \"\\n\";\n    x := x % 2;\n    print x, \"\\n\";\n}\nmethod DataTypes()\n{\n    \n    print 2, \" \", 3, \" \", -5, \" \", 0, \"\\n\";\n    \n    \n    print 1.0, \" \", -3.4, \" \", 0.5, \"\\n\";\n    \n    \n    print \"Adam\", \" \", \"Ala\", \"\\n\";\n}\nmethod TypeConversion()\n{\n    var a, b, c := 4, \"ala\", 3.4;\n    print a, \" \", b, \" \", c, \"\\n\";\n    \n    \n    var a_str := IntToString(a);\n    var c_str := RealToString(c);\n    print a_str, \", \", b, \", \", c_str, \"\\n\";\n    print a_str + b + c_str, \"\\n\";\n    \n    var a_real := 4.0;\n    var c_int := 3;\n    print a_real, \" \", c_int, \"\\n\";\n}\nmethod BasicFunctions()\n{\n    var word := \"Hello world\";\n    print word, \"\\n\";\n    \n    \n    var word2 := \"simulated input\";\n    print word2, \"\\n\";\n    \n    print |word2|, \"\\n\";  \n}\nmethod ObjectComparison()\n{\n    \n    var object_one: seq<int> := [];\n    var object_two: seq<int> := [];\n    var object_three := object_one;\n    var object_four := object_two;\n    \n    \n    \n    if object_one == object_two {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n    \n    if object_one == object_three {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n    \n    if object_two == object_four {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n}\nmethod IntToString(i: int) returns (s: string)\n{\n    \n    s := \"0\";  \n}\nmethod RealToString(r: real) returns (s: string)\n{\n    \n    s := \"0.0\";  \n}", "output": "method Main()\n{\n    \n    print \"Hello world\\n\";\n    \n    BasicMath();\n    \n    VariableOps();\n    \n    DataTypes();\n    \n    TypeConversion();\n    \n    BasicFunctions();\n    \n    ObjectComparison();\n}\nmethod BasicMath()\n{\n    print 1 + 1, \"\\n\";\n    print 2 - 3, \"\\n\";\n    print 3 % 2, \"\\n\";  \n    print 3 / 2, \"\\n\";  \n    print 3.0 / 2.0, \"\\n\";  \n    print 3 * 2, \"\\n\";\n    print 3 * 3, \"\\n\";  \n}\nmethod VariableOps()\n{\n    var x := 10;\n    x := x + 3;\n    print x, \"\\n\";\n    x := x * 3;\n    print x, \"\\n\";\n    x := x % 2;\n    print x, \"\\n\";\n}\nmethod DataTypes()\n{\n    \n    print 2, \" \", 3, \" \", -5, \" \", 0, \"\\n\";\n    \n    \n    print 1.0, \" \", -3.4, \" \", 0.5, \"\\n\";\n    \n    \n    print \"Adam\", \" \", \"Ala\", \"\\n\";\n}\nmethod TypeConversion()\n{\n    var a, b, c := 4, \"ala\", 3.4;\n    print a, \" \", b, \" \", c, \"\\n\";\n    \n    \n    var a_str := IntToString(a);\n    var c_str := RealToString(c);\n    print a_str, \", \", b, \", \", c_str, \"\\n\";\n    print a_str + b + c_str, \"\\n\";\n    \n    var a_real := 4.0;\n    var c_int := 3;\n    print a_real, \" \", c_int, \"\\n\";\n}\nmethod BasicFunctions()\n{\n    var word := \"Hello world\";\n    print word, \"\\n\";\n    \n    \n    var word2 := \"simulated input\";\n    print word2, \"\\n\";\n    \n    print |word2|, \"\\n\";  \n}\nmethod ObjectComparison()\n{\n    \n    var object_one: seq<int> := [];\n    var object_two: seq<int> := [];\n    var object_three := object_one;\n    var object_four := object_two;\n    \n    \n    \n    if object_one == object_two {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n    \n    if object_one == object_three {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n    \n    if object_two == object_four {\n        print \"True\\n\";\n    } else {\n        print \"False\\n\";\n    }\n}\nmethod IntToString(i: int) returns (s: string)\nensures |s| > 0  \n{\n    \n    s := \"0\";  \n}\nmethod RealToString(r: real) returns (s: string)\nensures |s| > 0  \n{\n    \n    s := \"0.0\";  \n}", "name": "py2dfy_126", "id": 126}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function fact(n: nat): nat \n{\n    if n == 0 then 1 else n * fact(n - 1)\n}\nmethod factorial(n: nat) returns (res: nat)\n{\n    var i := 1;\n    res := 1;\n    while i < n + 1 \n    {\n        res := i * res;\n        i := i + 1;\n    }\n}", "output": "function fact(n: nat): nat \n    ensures fact(n) >= 1\n{\n    if n == 0 then 1 else n * fact(n - 1)\n}\nmethod factorial(n: nat) returns (res: nat)\n    ensures res == fact(n)\n{\n    var i := 1;\n    res := 1;\n    while i < n + 1 \n        invariant 0 < i <= n + 1\n        invariant res == fact(i - 1) \n    {\n        res := i * res;\n        i := i + 1;\n    }\n}", "name": "py2dfy_160", "id": 160}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype PhysData = PhysData(count: nat)\nmethod fromSbdbQuerySingle(name: string) returns (physData: PhysData)\n  \n  \n{\n  \n  physData := PhysData(1);\n}\nmethod fromSbdbQueryMultiple(names: seq<string>) returns (physData: PhysData)\n  \n  \n{\n  var count := 0;\n  var tempPhysData := PhysData(0);\n  \n  \n  while count < |names|\n  {\n    count := count + 1;\n    tempPhysData := PhysData(count);\n  }\n  \n  physData := tempPhysData;\n}\nmethod testFromSbdbSingle()\n{\n  var data := fromSbdbQuerySingle(\"Ceres\");\n}\nmethod testFromSbdbMultiple()\n{\n  var data := fromSbdbQueryMultiple([\"1\", \"2\", \"3\", \"4\", \"5\"]);\n}", "output": "datatype PhysData = PhysData(count: nat)\nmethod fromSbdbQuerySingle(name: string) returns (physData: PhysData)\n  \n  requires name != \"\"\n  \n  ensures physData.count == 1\n{\n  \n  physData := PhysData(1);\n}\nmethod fromSbdbQueryMultiple(names: seq<string>) returns (physData: PhysData)\n  \n  requires |names| > 0\n  requires forall n :: 0 <= n < |names| ==> names[n] != \"\"\n  \n  ensures physData.count == |names|\n{\n  var count := 0;\n  var tempPhysData := PhysData(0);\n  \n  \n  while count < |names|\n    invariant 0 <= count <= |names|\n    invariant tempPhysData.count == count\n  {\n    count := count + 1;\n    tempPhysData := PhysData(count);\n  }\n  \n  physData := tempPhysData;\n}\nmethod testFromSbdbSingle()\n  ensures true\n{\n  var data := fromSbdbQuerySingle(\"Ceres\");\n  assert data.count == 1;\n}\nmethod testFromSbdbMultiple()\n  ensures true\n{\n  var data := fromSbdbQueryMultiple([\"1\", \"2\", \"3\", \"4\", \"5\"]);\n  assert data.count == 5;\n}", "name": "py2dfy_133", "id": 133}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ModelType = Art | TheUser\nclass AdminRegistry {\n  \n  var registeredModels: set<ModelType>\n  \n  constructor()\n  {\n    registeredModels := {};\n  }\n  \n  method Register(model: ModelType)\n    \n    \n    \n  {\n    registeredModels := registeredModels + {model};\n  }\n  \n  method IsRegistered(model: ModelType) returns (registered: bool)\n    \n  {\n    registered := model in registeredModels;\n  }\n  \n  method GetRegisteredCount() returns (count: nat)\n  {\n    count := |registeredModels|;\n  }\n}\nmethod Main()\n{\n  var registry := new AdminRegistry();\n  \n  \n  registry.Register(Art);\n  registry.Register(TheUser);\n  \n  var artRegistered := registry.IsRegistered(Art);\n  var userRegistered := registry.IsRegistered(TheUser);\n  var count := registry.GetRegisteredCount();\n  \n}", "output": "datatype ModelType = Art | TheUser\nclass AdminRegistry {\n  \n  var registeredModels: set<ModelType>\n  \n  constructor()\n    ensures registeredModels == {}  \n  {\n    registeredModels := {};\n  }\n  \n  method Register(model: ModelType)\n    \n    modifies this\n    \n    requires model !in registeredModels\n    \n    ensures registeredModels == old(registeredModels) + {model}  \n    ensures |registeredModels| == |old(registeredModels)| + 1    \n  {\n    registeredModels := registeredModels + {model};\n  }\n  \n  method IsRegistered(model: ModelType) returns (registered: bool)\n    \n    ensures registered <==> model in registeredModels  \n  {\n    registered := model in registeredModels;\n  }\n  \n  method GetRegisteredCount() returns (count: nat)\n    ensures count == |registeredModels|  \n  {\n    count := |registeredModels|;\n  }\n}\nmethod Main()\n{\n  var registry := new AdminRegistry();\n  \n  \n  registry.Register(Art);\n  registry.Register(TheUser);\n  \n  var artRegistered := registry.IsRegistered(Art);\n  var userRegistered := registry.IsRegistered(TheUser);\n  var count := registry.GetRegisteredCount();\n  \n  assert artRegistered;\n  assert userRegistered;\n  assert count == 2;\n}", "name": "py2dfy_147", "id": 147}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Unit = K | M | G | T\nconst FACTORS: map<Unit, nat> := map[\n  K := 1024,\n  M := 1048576, \n  G := 1073741827,\n  T := 1099511627776\n]\nfunction UnitToChar(u: Unit): char\n{\n  match u\n  case K => 'K'\n  case M => 'M'\n  case G => 'G'\n  case T => 'T'\n}\npredicate IsDigitString(s: string)\n{\n  forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\nfunction StringToNat(s: string): nat\n{\n  if |s| == 1 then \n    (s[0] as int - '0' as int) as nat\n  else\n    10 * StringToNat(s[..|s|-1]) + (s[|s|-1] as int - '0' as int) as nat\n}\nmethod HumanToBytes(human: string) returns (bytes: nat)\n{\n  if IsDigitString(human) {\n    return StringToNat(human);\n  }\n  \n  var modifier := human[|human|-1];\n  var numPart := human[..|human|-1];\n  \n  if |numPart| == 0 || !IsDigitString(numPart) {\n    return 0;\n  }\n  \n  var num := StringToNat(numPart);\n  \n  match modifier {\n    case 'K' => bytes := num * FACTORS[K];\n    case 'M' => bytes := num * FACTORS[M];\n    case 'G' => bytes := num * FACTORS[G];\n    case 'T' => bytes := num * FACTORS[T];\n    case _ => bytes := 0; \n  }\n}", "output": "datatype Unit = K | M | G | T\nconst FACTORS: map<Unit, nat> := map[\n  K := 1024,\n  M := 1048576, \n  G := 1073741827,\n  T := 1099511627776\n]\nfunction UnitToChar(u: Unit): char\n{\n  match u\n  case K => 'K'\n  case M => 'M'\n  case G => 'G'\n  case T => 'T'\n}\npredicate IsDigitString(s: string)\n{\n  forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\nfunction StringToNat(s: string): nat\n  requires IsDigitString(s)\n  requires |s| > 0\n  ensures StringToNat(s) >= 0\n{\n  if |s| == 1 then \n    (s[0] as int - '0' as int) as nat\n  else\n    10 * StringToNat(s[..|s|-1]) + (s[|s|-1] as int - '0' as int) as nat\n}\nmethod HumanToBytes(human: string) returns (bytes: nat)\n  requires |human| > 0\n  ensures bytes >= 0\n{\n  if IsDigitString(human) {\n    return StringToNat(human);\n  }\n  \n  var modifier := human[|human|-1];\n  var numPart := human[..|human|-1];\n  \n  if |numPart| == 0 || !IsDigitString(numPart) {\n    return 0;\n  }\n  \n  var num := StringToNat(numPart);\n  \n  match modifier {\n    case 'K' => bytes := num * FACTORS[K];\n    case 'M' => bytes := num * FACTORS[M];\n    case 'G' => bytes := num * FACTORS[G];\n    case 'T' => bytes := num * FACTORS[T];\n    case _ => bytes := 0; \n  }\n}", "name": "py2dfy_135", "id": 135}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype OID = OID(value: string)\ndatatype SNMPDevice = SNMPDevice(ip: string, port: int)\ndatatype SNMPUser = SNMPUser(username: string, authKey: string, encryptKey: string)\ndatatype Protocol = SHA | DES | AES128\ndatatype SNMPResult = Success(value: string) | Error(message: string)\nclass SNMPHelper {\n  predicate IsValidPort(port: int)\n  {\n    0 <= port <= 65535\n  }\n  predicate IsValidIP(ip: string)\n  {\n    |ip| > 0\n  }\n  predicate IsValidCredentials(user: SNMPUser)\n  {\n    |user.username| > 0 && \n    |user.authKey| > 0 && \n    |user.encryptKey| > 0\n  }\n  method SNMPGetOIDv3(\n    device: SNMPDevice, \n    user: SNMPUser, \n    oid: OID, \n    authProto: Protocol, \n    encryptProto: Protocol\n  ) returns (result: SNMPResult)\n  {\n    if device.port == 161 && authProto == SHA && encryptProto == DES {\n      result := Success(\"simulated_snmp_response\");\n    } else {\n      result := Error(\"SNMP operation failed\");\n    }\n  }\n  method SNMPExtract(data: SNMPResult) returns (output: string)\n  {\n    match data {\n      case Success(v) => output := v;\n      case Error(_) => output := \"\";\n    }\n  }\n  method Main() returns (result: string)\n  {\n    var ip := \"10.1.10.100\";\n    var port := 161;\n    var device := SNMPDevice(ip, port);\n    \n    var username := \"cisco\";\n    var authKey := \"cisco123\";\n    var encryptKey := \"cisco123\";\n    var user := SNMPUser(username, authKey, encryptKey);\n    var ifName := OID(\"1.3.6.1.2.1.31.1.1.1.1.1\");\n    \n    var snmpData := SNMPGetOIDv3(device, user, ifName, SHA, DES);\n    result := SNMPExtract(snmpData);\n    if |result| == 0 {\n      result := \"Error: SNMP operation failed\";\n    }\n  }\n}", "output": "datatype OID = OID(value: string)\ndatatype SNMPDevice = SNMPDevice(ip: string, port: int)\ndatatype SNMPUser = SNMPUser(username: string, authKey: string, encryptKey: string)\ndatatype Protocol = SHA | DES | AES128\ndatatype SNMPResult = Success(value: string) | Error(message: string)\nclass SNMPHelper {\n  predicate IsValidPort(port: int)\n  {\n    0 <= port <= 65535\n  }\n  predicate IsValidIP(ip: string)\n  {\n    |ip| > 0\n  }\n  predicate IsValidCredentials(user: SNMPUser)\n  {\n    |user.username| > 0 && \n    |user.authKey| > 0 && \n    |user.encryptKey| > 0\n  }\n  method SNMPGetOIDv3(\n    device: SNMPDevice, \n    user: SNMPUser, \n    oid: OID, \n    authProto: Protocol, \n    encryptProto: Protocol\n  ) returns (result: SNMPResult)\n    requires IsValidIP(device.ip)\n    requires IsValidPort(device.port)\n    requires IsValidCredentials(user)\n    ensures result.Success? ==> |result.value| > 0\n  {\n    if device.port == 161 && authProto == SHA && encryptProto == DES {\n      result := Success(\"simulated_snmp_response\");\n    } else {\n      result := Error(\"SNMP operation failed\");\n    }\n  }\n  method SNMPExtract(data: SNMPResult) returns (output: string)\n    ensures data.Success? ==> output == data.value\n    ensures data.Error? ==> output == \"\"\n  {\n    match data {\n      case Success(v) => output := v;\n      case Error(_) => output := \"\";\n    }\n  }\n  method Main() returns (result: string)\n    ensures |result| > 0\n  {\n    var ip := \"10.1.10.100\";\n    var port := 161;\n    var device := SNMPDevice(ip, port);\n    \n    var username := \"cisco\";\n    var authKey := \"cisco123\";\n    var encryptKey := \"cisco123\";\n    var user := SNMPUser(username, authKey, encryptKey);\n    var ifName := OID(\"1.3.6.1.2.1.31.1.1.1.1.1\");\n    \n    var snmpData := SNMPGetOIDv3(device, user, ifName, SHA, DES);\n    result := SNMPExtract(snmpData);\n    if |result| == 0 {\n      result := \"Error: SNMP operation failed\";\n    }\n  }\n}", "name": "py2dfy_154", "id": 154}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ValidationLevel = Min | Med | Max\ntrait FileFormat {\n  \n  var path: string\n  \n  \n  var mode: string\n  \n  method Init(p: string)\n  {\n    path := p;\n    mode := \"r\";\n  }\n  \n  method Validate(level: ValidationLevel) returns (success: bool, error: string)\n  \n  \n  method IsFile() returns (fileExists: bool)\n  \n  \n  method ValidateFormat(level: ValidationLevel) returns (success: bool, error: string)\n}\nclass TextFileFormat extends FileFormat {\n  constructor()\n  {\n    path := \"\";\n    mode := \"r\";\n  }\n  \n  method Validate(level: ValidationLevel) returns (success: bool, error: string)\n  {\n    var fileExists := IsFile();\n    if !fileExists {\n      return false, \"File does not exist: \" + path;\n    }\n    var formatValid, formatError := ValidateFormat(level);\n    if !formatValid {\n      return false, \"Invalid text file format: \" + formatError;\n    }\n    return true, \"\";\n  }\n  \n  method ValidateFormat(level: ValidationLevel) returns (success: bool, error: string)\n  {\n    \n    \n    return true, \"\";\n  }\n  \n  method IsFile() returns (fileExists: bool)\n  {\n    \n    fileExists := path != \"\";\n    return fileExists;\n  }\n  \n  method Open() returns (success: bool, error: string)\n  {\n    var encoding := if mode == \"r\" then \"utf-8-sig\" else \"utf-8\";\n    \n    \n    return true, \"\";\n  }\n}", "output": "datatype ValidationLevel = Min | Med | Max\ntrait FileFormat {\n  \n  var path: string\n  \n  \n  var mode: string\n  \n  method Init(p: string)\n    requires p != \"\"  \n    modifies this\n    ensures path == p\n    ensures mode == \"r\"  \n  {\n    path := p;\n    mode := \"r\";\n  }\n  \n  method Validate(level: ValidationLevel) returns (success: bool, error: string)\n    requires level in {Min, Med, Max}\n    ensures success ==> error == \"\"  \n    ensures !success ==> error != \"\" \n  \n  \n  method IsFile() returns (fileExists: bool)\n    ensures fileExists ==> path != \"\"\n  \n  \n  method ValidateFormat(level: ValidationLevel) returns (success: bool, error: string)\n    requires level in {Min, Med, Max}\n    ensures success ==> error == \"\"\n    ensures !success ==> error != \"\"\n}\nclass TextFileFormat extends FileFormat {\n  constructor()\n  {\n    path := \"\";\n    mode := \"r\";\n  }\n  \n  method Validate(level: ValidationLevel) returns (success: bool, error: string)\n    requires level in {Min, Med, Max}\n    ensures success ==> error == \"\"\n    ensures !success ==> error != \"\"\n  {\n    var fileExists := IsFile();\n    if !fileExists {\n      return false, \"File does not exist: \" + path;\n    }\n    var formatValid, formatError := ValidateFormat(level);\n    if !formatValid {\n      return false, \"Invalid text file format: \" + formatError;\n    }\n    return true, \"\";\n  }\n  \n  method ValidateFormat(level: ValidationLevel) returns (success: bool, error: string)\n    requires level in {Min, Med, Max}\n    ensures success ==> error == \"\"\n    ensures !success ==> error != \"\"\n  {\n    \n    \n    return true, \"\";\n  }\n  \n  method IsFile() returns (fileExists: bool)\n    ensures fileExists ==> path != \"\"\n  {\n    \n    fileExists := path != \"\";\n    return fileExists;\n  }\n  \n  method Open() returns (success: bool, error: string)\n    requires path != \"\"\n    ensures success ==> error == \"\"\n    ensures !success ==> error != \"\"\n  {\n    var encoding := if mode == \"r\" then \"utf-8-sig\" else \"utf-8\";\n    \n    \n    return true, \"\";\n  }\n}", "name": "py2dfy_153", "id": 153}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype FirePitType = Square | Round\ndatatype StructureType = Attached | Freestanding\nmethod GetFirePitPreferences() returns (pit: FirePitType, structure: StructureType)\n{\n  var response: string;\n  \n  \n  print \"What kind of fire pit would you like, your options are A) Square B) Round? : \";\n  response := \"A\"; \n  \n  if response == \"A\" {\n    pit := Square;\n    print \"you selected Square Firepit\\n\";\n  } else {\n    pit := Round;\n    print \"you selected Round Firepit\\n\";\n  }\n  \n  \n  print \"Do you want a structure built into the house or seperate, your options are A) Yes B) No: \";\n  response := \"A\"; \n  \n  if response == \"A\" {\n    structure := Attached;\n    print \"You selected attached structure.\\n\";\n  } else {\n    structure := Freestanding;\n    print \"You selected freestanding patio.\\n\";\n  }\n}\nmethod Main()\n{\n  var pitType, structureType := GetFirePitPreferences();\n}", "output": "datatype FirePitType = Square | Round\ndatatype StructureType = Attached | Freestanding\nmethod GetFirePitPreferences() returns (pit: FirePitType, structure: StructureType)\n  ensures pit == Square || pit == Round  \n  ensures structure == Attached || structure == Freestanding  \n{\n  var response: string;\n  \n  \n  print \"What kind of fire pit would you like, your options are A) Square B) Round? : \";\n  response := \"A\"; \n  \n  if response == \"A\" {\n    pit := Square;\n    print \"you selected Square Firepit\\n\";\n  } else {\n    pit := Round;\n    print \"you selected Round Firepit\\n\";\n  }\n  \n  \n  print \"Do you want a structure built into the house or seperate, your options are A) Yes B) No: \";\n  response := \"A\"; \n  \n  if response == \"A\" {\n    structure := Attached;\n    print \"You selected attached structure.\\n\";\n  } else {\n    structure := Freestanding;\n    print \"You selected freestanding patio.\\n\";\n  }\n}\nmethod Main()\n{\n  var pitType, structureType := GetFirePitPreferences();\n}", "name": "py2dfy_179", "id": 179}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype BackendDependencies = SPARK | AWS | AWS_GLUE\nclass IntegrationTestFixture {\n  var name: string\n  var userFlowScript: string\n  var backendDependencies: seq<BackendDependencies>\n  constructor (name: string, userFlowScript: string, backendDependencies: seq<BackendDependencies>)\n  {\n    this.name := name;\n    this.userFlowScript := userFlowScript;\n    this.backendDependencies := backendDependencies;\n  }\n}\nmethod CreateAwsGlueIntegrationTests() returns (awsGlueIntegrationTests: seq<IntegrationTestFixture>)\n{\n  awsGlueIntegrationTests := [];\n  var deploymentPatterns := new IntegrationTestFixture(\n      \"how_to_use_great_expectations_in_aws_glue\",\n      \"tests/integration/docusaurus/deployment_patterns/aws_glue_deployment_patterns.py\",\n      [BackendDependencies.SPARK, BackendDependencies.AWS, BackendDependencies.AWS_GLUE]\n  );\n  awsGlueIntegrationTests := [deploymentPatterns];\n}", "output": "datatype BackendDependencies = SPARK | AWS | AWS_GLUE\nclass IntegrationTestFixture {\n  var name: string\n  var userFlowScript: string\n  var backendDependencies: seq<BackendDependencies>\n  constructor (name: string, userFlowScript: string, backendDependencies: seq<BackendDependencies>)\n    requires name != \"\" && userFlowScript != \"\"\n    ensures this.name == name\n    ensures this.userFlowScript == userFlowScript\n    ensures this.backendDependencies == backendDependencies\n  {\n    this.name := name;\n    this.userFlowScript := userFlowScript;\n    this.backendDependencies := backendDependencies;\n  }\n}\nmethod CreateAwsGlueIntegrationTests() returns (awsGlueIntegrationTests: seq<IntegrationTestFixture>)\n  ensures |awsGlueIntegrationTests| == 1\n  ensures awsGlueIntegrationTests[0].name == \"how_to_use_great_expectations_in_aws_glue\"\n  ensures awsGlueIntegrationTests[0].userFlowScript == \"tests/integration/docusaurus/deployment_patterns/aws_glue_deployment_patterns.py\"\n  ensures awsGlueIntegrationTests[0].backendDependencies == [BackendDependencies.SPARK, BackendDependencies.AWS, BackendDependencies.AWS_GLUE]\n{\n  awsGlueIntegrationTests := [];\n  var deploymentPatterns := new IntegrationTestFixture(\n      \"how_to_use_great_expectations_in_aws_glue\",\n      \"tests/integration/docusaurus/deployment_patterns/aws_glue_deployment_patterns.py\",\n      [BackendDependencies.SPARK, BackendDependencies.AWS, BackendDependencies.AWS_GLUE]\n  );\n  awsGlueIntegrationTests := [deploymentPatterns];\n}", "name": "py2dfy_141", "id": 141}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class GuiController {\n    \n    var isInitialized: bool\n    \n    \n    constructor()\n    {\n        isInitialized := true;\n    }\n    \n    method IsReady() returns (ready: bool)\n    {\n        return true;\n    }\n    \n    method HandleEvent(eventType: int) returns (success: bool)\n    {\n        if (0 <= eventType <= 100) {\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\nmethod Main()\n{\n    var controller := new GuiController();\n    var ready := controller.IsReady();\n}", "output": "class GuiController {\n    \n    var isInitialized: bool\n    \n    \n    constructor()\n        ensures isInitialized == true  \n        ensures fresh(this)  \n    {\n        isInitialized := true;\n    }\n    \n    method IsReady() returns (ready: bool)\n        requires isInitialized  \n        ensures ready == true  \n    {\n        return true;\n    }\n    \n    method HandleEvent(eventType: int) returns (success: bool)\n        requires isInitialized\n        requires 0 <= eventType <= 100  \n        ensures success ==> isInitialized  \n        ensures eventType < 0 || eventType > 100 ==> !success  \n    {\n        if (0 <= eventType <= 100) {\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\nmethod Main()\n{\n    var controller := new GuiController();\n    var ready := controller.IsReady();\n    assert ready == true;  \n}", "name": "py2dfy_157", "id": 157}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class BoundedString {\n  var value: string\n  const maxLength: nat\n  \n  predicate Valid()\n  {\n    |value| <= maxLength\n  }\n  \n  constructor(initialValue: string, max: nat)\n  {\n    value := initialValue;\n    maxLength := max;\n  }\n  \n  method GetValue() returns (result: string)\n  {\n    return value;\n  }\n  \n  method SetValue(newValue: string) returns (success: bool)\n  {\n    if |newValue| <= maxLength {\n      value := newValue;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass Document {\n  var category: BoundedString?\n  var content: string\n  var url: string\n  \n  predicate Valid()\n  {\n    category != null && category.Valid()\n  }\n  \n  constructor(cat: string, cont: string, urlStr: string)\n  {\n    category := new BoundedString(cat, 20);\n    content := cont;\n    url := urlStr;\n  }\n  \n  method GetContent() returns (result: string)\n  {\n    return content;\n  }\n  \n  method ToString() returns (result: string)\n  {\n    return content;\n  }\n}\nclass Category {\n  var categoryName: BoundedString?\n  \n  predicate Valid()\n  {\n    categoryName != null && categoryName.Valid()\n  }\n  \n  constructor(name: string)\n  {\n    categoryName := new BoundedString(name, 20);\n  }\n  \n  method GetCategoryName() returns (result: string)\n  {\n    return categoryName.value;\n  }\n  \n  method ToString() returns (result: string)\n  {\n    return categoryName.value;\n  }\n}", "output": "class BoundedString {\n  var value: string\n  const maxLength: nat\n  \n  predicate Valid()\n    reads this\n  {\n    |value| <= maxLength\n  }\n  \n  constructor(initialValue: string, max: nat)\n    requires |initialValue| <= max\n    ensures Valid()\n    ensures value == initialValue\n    ensures maxLength == max\n  {\n    value := initialValue;\n    maxLength := max;\n  }\n  \n  method GetValue() returns (result: string)\n    ensures result == value\n  {\n    return value;\n  }\n  \n  method SetValue(newValue: string) returns (success: bool)\n    requires Valid()\n    ensures Valid()\n    ensures success ==> value == newValue\n    ensures !success ==> value == old(value)\n    ensures success <==> |newValue| <= maxLength\n    modifies this\n  {\n    if |newValue| <= maxLength {\n      value := newValue;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass Document {\n  var category: BoundedString?\n  var content: string\n  var url: string\n  \n  predicate Valid()\n    reads this, category\n  {\n    category != null && category.Valid()\n  }\n  \n  constructor(cat: string, cont: string, urlStr: string)\n    requires |cat| <= 20  \n    ensures Valid()\n  {\n    category := new BoundedString(cat, 20);\n    content := cont;\n    url := urlStr;\n  }\n  \n  method GetContent() returns (result: string)\n    requires Valid()\n    ensures result == content\n  {\n    return content;\n  }\n  \n  method ToString() returns (result: string)\n    requires Valid()\n    ensures result == content  \n  {\n    return content;\n  }\n}\nclass Category {\n  var categoryName: BoundedString?\n  \n  predicate Valid()\n    reads this, categoryName\n  {\n    categoryName != null && categoryName.Valid()\n  }\n  \n  constructor(name: string)\n    requires |name| <= 20  \n    ensures Valid()\n  {\n    categoryName := new BoundedString(name, 20);\n  }\n  \n  method GetCategoryName() returns (result: string)\n    requires Valid()\n    ensures result == categoryName.value\n  {\n    return categoryName.value;\n  }\n  \n  method ToString() returns (result: string)\n    requires Valid()\n    ensures result == categoryName.value  \n  {\n    return categoryName.value;\n  }\n}", "name": "py2dfy_118", "id": 118}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CalculatePay(hours: real, rate: real) returns (pay: real)\n{\n  pay := hours * rate;\n}\nmethod Main()\n{\n  \n  \n  var hours: real := 40.0;  \n  var rate: real := 10.0;   \n  \n  var pay := CalculatePay(hours, rate);\n  print \"Pay: \", pay, \"\\n\";\n}", "output": "method CalculatePay(hours: real, rate: real) returns (pay: real)\n  requires hours >= 0.0  \n  requires rate >= 0.0   \n  ensures pay == hours * rate  \n{\n  pay := hours * rate;\n}\nmethod Main()\n{\n  \n  \n  var hours: real := 40.0;  \n  var rate: real := 10.0;   \n  \n  var pay := CalculatePay(hours, rate);\n  print \"Pay: \", pay, \"\\n\";\n}", "name": "py2dfy_138", "id": 138}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Path = \n  | Absolute(components: seq<string>)\n  | Relative(components: seq<string>)\ndatatype OSType = Windows | Unix | Other\nclass FileSystem {\n  \n  var files: set<Path>\n  var directories: set<Path>\n  \n  predicate Valid()\n  {\n    (forall p :: p in files ==> p !in directories) &&\n    (forall p :: p in directories ==> p !in files)\n  }\n  constructor()\n  {\n    files := {};\n    directories := {};\n  }\n  \n  \n  method MakeDirectory(path: Path) returns (success: bool)\n  {\n    if path in files || path in directories {\n      success := false;\n    } else {\n      directories := directories + {path};\n      success := true;\n    }\n  }\n  \n  method RemoveDirectory(path: Path) returns (success: bool)\n  {\n    if path !in directories {\n      success := false;\n      return;\n    }\n    \n    \n    var isEmpty := true;\n    success := false;\n    \n    if isEmpty {\n      directories := directories - {path};\n      success := true;\n    }\n  }\n}", "output": "datatype Path = \n  | Absolute(components: seq<string>)\n  | Relative(components: seq<string>)\ndatatype OSType = Windows | Unix | Other\nclass FileSystem {\n  \n  var files: set<Path>\n  var directories: set<Path>\n  \n  predicate Valid()\n    reads this\n  {\n    (forall p :: p in files ==> p !in directories) &&\n    (forall p :: p in directories ==> p !in files)\n  }\n  constructor()\n    ensures Valid()\n  {\n    files := {};\n    directories := {};\n  }\n  \n  \n  method MakeDirectory(path: Path) returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures success ==> path in directories\n    ensures !success ==> directories == old(directories)\n    ensures files == old(files)\n  {\n    if path in files || path in directories {\n      success := false;\n    } else {\n      directories := directories + {path};\n      success := true;\n    }\n  }\n  \n  method RemoveDirectory(path: Path) returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures success ==> path !in directories\n    ensures !success ==> directories == old(directories)\n    ensures files == old(files)\n  {\n    if path !in directories {\n      success := false;\n      return;\n    }\n    \n    \n    var isEmpty := true;\n    success := false;\n    \n    if isEmpty {\n      directories := directories - {path};\n      success := true;\n    }\n  }\n}", "name": "py2dfy_117", "id": 117}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class {:autocontracts} DataSet {\n    var single: seq<real>\n    var double: seq<real>\n    \n    constructor(s: seq<real>, d: seq<real>)\n    {\n        single := s;\n        double := d;\n    }\n}\nclass {:autocontracts} DataProcessor {\n    \n    method NormalizeSequence(data: seq<real>) returns (result: seq<real>)\n    {\n        result := [];\n        var lambda0 := data[0];\n        var i := 0;\n        \n        while i < |data|\n        {\n            result := result + [data[i] / lambda0];\n            i := i + 1;\n        }\n    }\n    \n    method ProcessDataSet(dataset: DataSet) returns (normalizedSingle: seq<real>, normalizedDouble: seq<real>)\n    {\n        normalizedSingle := NormalizeSequence(dataset.single);\n        normalizedDouble := NormalizeSequence(dataset.double);\n    }\n    \n    method Linspace(start: real, stop: real, num: nat) returns (result: seq<real>)\n    {\n        result := [];\n        var step: real := (stop - start) / (num - 1) as real;\n        var i := 0;\n        \n        while i < num\n        {\n            result := result + [start + (i as real) * step];\n            i := i + 1;\n        }\n    }\n}", "output": "class {:autocontracts} DataSet {\n    var single: seq<real>\n    var double: seq<real>\n    \n    constructor(s: seq<real>, d: seq<real>)\n    requires |s| > 0 && |d| > 0\n    requires |s| == |d|\n    ensures single == s && double == d\n    {\n        single := s;\n        double := d;\n    }\n}\nclass {:autocontracts} DataProcessor {\n    \n    method NormalizeSequence(data: seq<real>) returns (result: seq<real>)\n    requires |data| > 0\n    requires data[0] != 0.0\n    ensures |result| == |data|\n    ensures result[0] == data[0]/data[0]\n    ensures forall i :: 0 <= i < |data| ==> result[i] == data[i] / data[0]\n    {\n        result := [];\n        var lambda0 := data[0];\n        var i := 0;\n        \n        while i < |data|\n        invariant 0 <= i <= |data|\n        invariant |result| == i\n        invariant forall k :: 0 <= k < i ==> result[k] == data[k] / lambda0\n        {\n            result := result + [data[i] / lambda0];\n            i := i + 1;\n        }\n    }\n    \n    method ProcessDataSet(dataset: DataSet) returns (normalizedSingle: seq<real>, normalizedDouble: seq<real>)\n    requires |dataset.single| > 0 && |dataset.double| > 0\n    requires dataset.single[0] != 0.0\n    requires dataset.double[0] != 0.0\n    ensures |normalizedSingle| == |dataset.single|\n    ensures |normalizedDouble| == |dataset.double|\n    {\n        normalizedSingle := NormalizeSequence(dataset.single);\n        normalizedDouble := NormalizeSequence(dataset.double);\n    }\n    \n    method Linspace(start: real, stop: real, num: nat) returns (result: seq<real>)\n    requires num > 1\n    requires stop >= start\n    ensures |result| == num\n    ensures result[0] == start\n    ensures result[num-1] == stop\n    {\n        result := [];\n        var step: real := (stop - start) / (num - 1) as real;\n        var i := 0;\n        \n        while i < num\n        invariant 0 <= i <= num\n        invariant |result| == i\n        invariant forall k :: 0 <= k < i ==> result[k] == start + (k as real) * step\n        {\n            result := result + [start + (i as real) * step];\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_111", "id": 111}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main() {\n  print F(), \" \", G(802.11), \"\\n\";  \n}\nfunction F(): int {\n  var rx := false;\n    var u := 5.0;  \n  }\n  12\n}\nfunction G<T>(t: T): int {\n  var rx := false;\n    var u: T := t;  \n    {\n      var v: T := u;\n      v := t;\n    }\n  }\n  15\n}", "output": "method Main() {\n  print F(), \" \", G(802.11), \"\\n\";  \n}\nfunction F(): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u := 5.0;  \n    assert u < 6.0;\n  }\n  12\n}\nfunction G<T>(t: T): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u: T := t;  \n    {\n      var v: T := u;\n      assert t == v;\n      v := t;\n      assert t == u;\n    }\n    assert u == t;\n  }\n  15\n}", "name": "py2dfy_155", "id": 155}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Result = Success | Error(msg: string)\ndatatype IPAddress = IPv4(value: int) | IPv6(value: int)\ndatatype DateTime = DateTime(timestamp: int)\ndatatype StorageRecord = StorageRecord(\n  startTime: DateTime,\n  byteCount: int,\n  bucket: string, \n  source: string\n)\ndatatype SessionRecord = SessionRecord(\n  ip: string,\n  ipInt: int,\n  acc: string,\n  agent: string,\n  domain: string,\n  responseCode: int,\n  startTime: DateTime,\n  endTime: DateTime,\n  byteCount: int,\n  count: int,\n  source: string\n)\nclass Database {\n  var isConnected: bool\n  constructor()\n  {\n    isConnected := false;\n  }\n  method Connect(host: string, dbname: string, user: string, password: string) returns (success: bool)\n  {\n    if !isConnected {\n      isConnected := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass DataProcessor {\n  var db: Database\n  constructor()\n  {\n    db := new Database();\n  }\n  method ParseStorageLine(line: seq<char>) returns (r: Result, record: StorageRecord)\n  {\n    \n    r := Success;\n    record := StorageRecord(DateTime(0), 0, \"\", \"\");\n  }\n  method ParseSessionLine(line: seq<char>) returns (r: Result, record: SessionRecord)\n  {\n    \n    r := Success;\n    record := SessionRecord(\"\", 0, \"\", \"\", \"\", 0, DateTime(0), DateTime(0), 0, 0, \"\");\n  }\n  method ParseIPAddress(ip: string) returns (r: Result, addr: IPAddress)\n  {\n    \n    r := Success;\n    addr := IPv4(0);\n  }\n  method ParseDateTime(timestamp: string) returns (r: Result, dt: DateTime)\n  {\n    \n    r := Success;\n    dt := DateTime(0);\n  }\n  method SplitString(s: string, delimiter: char) returns (result: seq<string>)\n  {\n    \n    result := [\"\"];\n  }\n  predicate ValidStorageRecord(record: StorageRecord)\n  {\n    record.byteCount >= 0\n  }\n  predicate ValidSessionRecord(record: SessionRecord) \n  {\n    && record.ipInt >= 0\n    && record.responseCode >= 0\n    && record.byteCount >= 0\n    && record.count >= 0\n  }\n}", "output": "datatype Result = Success | Error(msg: string)\ndatatype IPAddress = IPv4(value: int) | IPv6(value: int)\ndatatype DateTime = DateTime(timestamp: int)\ndatatype StorageRecord = StorageRecord(\n  startTime: DateTime,\n  byteCount: int,\n  bucket: string, \n  source: string\n)\ndatatype SessionRecord = SessionRecord(\n  ip: string,\n  ipInt: int,\n  acc: string,\n  agent: string,\n  domain: string,\n  responseCode: int,\n  startTime: DateTime,\n  endTime: DateTime,\n  byteCount: int,\n  count: int,\n  source: string\n)\nclass Database {\n  var isConnected: bool\n  constructor()\n    ensures !isConnected\n  {\n    isConnected := false;\n  }\n  method Connect(host: string, dbname: string, user: string, password: string) returns (success: bool)\n    modifies this\n    ensures old(isConnected) == false ==> isConnected == success\n    ensures old(isConnected) == true ==> isConnected == old(isConnected)\n  {\n    if !isConnected {\n      isConnected := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass DataProcessor {\n  var db: Database\n  constructor()\n    ensures fresh(db)\n  {\n    db := new Database();\n  }\n  method ParseStorageLine(line: seq<char>) returns (r: Result, record: StorageRecord)\n    requires |line| > 0\n  {\n    \n    r := Success;\n    record := StorageRecord(DateTime(0), 0, \"\", \"\");\n  }\n  method ParseSessionLine(line: seq<char>) returns (r: Result, record: SessionRecord)\n    requires |line| > 0\n  {\n    \n    r := Success;\n    record := SessionRecord(\"\", 0, \"\", \"\", \"\", 0, DateTime(0), DateTime(0), 0, 0, \"\");\n  }\n  method ParseIPAddress(ip: string) returns (r: Result, addr: IPAddress)\n    requires |ip| > 0\n  {\n    \n    r := Success;\n    addr := IPv4(0);\n  }\n  method ParseDateTime(timestamp: string) returns (r: Result, dt: DateTime)\n    requires |timestamp| > 0\n  {\n    \n    r := Success;\n    dt := DateTime(0);\n  }\n  method SplitString(s: string, delimiter: char) returns (result: seq<string>)\n    requires |s| > 0\n    ensures |result| > 0\n  {\n    \n    result := [\"\"];\n  }\n  predicate ValidStorageRecord(record: StorageRecord)\n  {\n    record.byteCount >= 0\n  }\n  predicate ValidSessionRecord(record: SessionRecord) \n  {\n    && record.ipInt >= 0\n    && record.responseCode >= 0\n    && record.byteCount >= 0\n    && record.count >= 0\n  }\n}", "name": "py2dfy_144", "id": 144}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Evaluation = Zero | Plus | Minus\nclass Citation {\n  var words: seq<string>\n  var eval: Evaluation\n  constructor(ws: seq<string>, e: Evaluation)\n  {\n    words := ws;\n    eval := e;\n  }\n}\nmethod Tokenize(text: string) returns (tokens: seq<string>)\n{\n  var result: seq<string> := [];\n  var currentWord: string := \"\";\n  var i := 0;\n  while i < |text|\n  {\n    var c := text[i];\n    if c == ' ' {\n      if |currentWord| > 0 {\n        result := result + [currentWord];\n        currentWord := \"\";\n      }\n    } else {\n      currentWord := currentWord + [c];\n    }\n    i := i + 1;\n  }\n  \n  if |currentWord| > 0 {\n    result := result + [currentWord];\n  }\n  \n  return result;\n}\nmethod ParseXML(content: seq<string>, evaluations: seq<Evaluation>) returns (citations: seq<Citation>)\n{\n  citations := [];\n  var i := 0;\n  while i < |content|\n  {\n    var tokens := Tokenize(content[i]);\n    var citation := new Citation(tokens, evaluations[i]);\n    citations := citations + [citation];\n    i := i + 1;\n  }\n}\nmethod VectorizeCorpus(trainCitations: seq<Citation>, testCitations: seq<Citation>) \n  returns (xTrain: seq<seq<real>>, yTrain: seq<Evaluation>, \n          xTest: seq<seq<real>>, yTest: seq<Evaluation>)\n{\n  yTrain := [];\n  yTest := [];\n  xTrain := [];\n  xTest := [];\n  \n  var i := 0;\n  while i < |trainCitations|\n  {\n    var citation := trainCitations[i];\n    var features := ComputeFeatures(citation.words);\n    xTrain := xTrain + [features];\n    yTrain := yTrain + [citation.eval];\n    i := i + 1;\n  }\n  i := 0;\n  while i < |testCitations|\n  {\n    var citation := testCitations[i];\n    var features := ComputeFeatures(citation.words);\n    xTest := xTest + [features];\n    yTest := yTest + [citation.eval];\n    i := i + 1;\n  }\n}\nmethod ComputeFeatures(words: seq<string>) returns (features: seq<real>)\n{\n  features := [1.0];  \n}", "output": "datatype Evaluation = Zero | Plus | Minus\nclass Citation {\n  var words: seq<string>\n  var eval: Evaluation\n  constructor(ws: seq<string>, e: Evaluation)\n    ensures words == ws && eval == e\n  {\n    words := ws;\n    eval := e;\n  }\n}\nmethod Tokenize(text: string) returns (tokens: seq<string>)\n  ensures |tokens| <= |text|  \n  ensures forall i :: 0 <= i < |tokens| ==> |tokens[i]| > 0  \n{\n  var result: seq<string> := [];\n  var currentWord: string := \"\";\n  var i := 0;\n  while i < |text|\n    invariant 0 <= i <= |text|\n    invariant forall j :: 0 <= j < |result| ==> |result[j]| > 0\n    invariant |result| + (if |currentWord| > 0 then 1 else 0) <= i  \n  {\n    var c := text[i];\n    if c == ' ' {\n      if |currentWord| > 0 {\n        result := result + [currentWord];\n        currentWord := \"\";\n      }\n    } else {\n      currentWord := currentWord + [c];\n    }\n    i := i + 1;\n  }\n  \n  if |currentWord| > 0 {\n    result := result + [currentWord];\n  }\n  \n  return result;\n}\nmethod ParseXML(content: seq<string>, evaluations: seq<Evaluation>) returns (citations: seq<Citation>)\n  requires |content| == |evaluations|  \n  ensures |citations| == |content|  \n{\n  citations := [];\n  var i := 0;\n  while i < |content|\n    invariant 0 <= i <= |content|\n    invariant |citations| == i\n  {\n    var tokens := Tokenize(content[i]);\n    var citation := new Citation(tokens, evaluations[i]);\n    citations := citations + [citation];\n    i := i + 1;\n  }\n}\nmethod VectorizeCorpus(trainCitations: seq<Citation>, testCitations: seq<Citation>) \n  returns (xTrain: seq<seq<real>>, yTrain: seq<Evaluation>, \n          xTest: seq<seq<real>>, yTest: seq<Evaluation>)\n  requires |trainCitations| > 0\n  requires |testCitations| > 0\n  ensures |xTrain| == |trainCitations|\n  ensures |yTrain| == |trainCitations|\n  ensures |xTest| == |testCitations|\n  ensures |yTest| == |testCitations|\n{\n  yTrain := [];\n  yTest := [];\n  xTrain := [];\n  xTest := [];\n  \n  var i := 0;\n  while i < |trainCitations|\n    invariant 0 <= i <= |trainCitations|\n    invariant |yTrain| == i\n    invariant |xTrain| == i\n  {\n    var citation := trainCitations[i];\n    var features := ComputeFeatures(citation.words);\n    xTrain := xTrain + [features];\n    yTrain := yTrain + [citation.eval];\n    i := i + 1;\n  }\n  i := 0;\n  while i < |testCitations|\n    invariant 0 <= i <= |testCitations|\n    invariant |yTest| == i\n    invariant |xTest| == i\n  {\n    var citation := testCitations[i];\n    var features := ComputeFeatures(citation.words);\n    xTest := xTest + [features];\n    yTest := yTest + [citation.eval];\n    i := i + 1;\n  }\n}\nmethod ComputeFeatures(words: seq<string>) returns (features: seq<real>)\n  ensures |features| > 0  \n{\n  features := [1.0];  \n}", "name": "py2dfy_115", "id": 115}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Dataset {\n  var features: array2<real>  \n  var targets: array<real>    \n  var numSamples: nat         \n  var numFeatures: nat        \n  predicate Valid()\n  {\n    features.Length0 == numSamples &&\n    features.Length1 == numFeatures &&\n    targets.Length == numSamples &&\n    numSamples > 0\n  }\n  constructor(feat: array2<real>, targ: array<real>)\n  {\n    features := feat;\n    targets := targ;\n    numSamples := feat.Length0;\n    numFeatures := feat.Length1;\n  }\n  method StandardizeFeatures() returns (scaledFeatures: array2<real>)\n  {\n    scaledFeatures := new real[features.Length0, features.Length1];\n    var means := CalculateColumnMeans();\n    var stds := CalculateColumnStds(means);\n    \n    var i := 0;\n    while i < features.Length0\n    {\n      var j := 0;\n      while j < features.Length1\n      {\n        if stds[j] != 0.0 {\n          scaledFeatures[i,j] := (features[i,j] - means[j]) / stds[j];\n        } else {\n          scaledFeatures[i,j] := 0.0;\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  method CalculateColumnMeans() returns (means: array<real>)\n  {\n    means := new real[features.Length1];\n    \n    var j := 0;\n    while j < features.Length1\n    {\n      var sum := 0.0;\n      var i := 0;\n      while i < features.Length0\n      {\n        sum := sum + features[i,j];\n        i := i + 1;\n      }\n      means[j] := sum / (features.Length0 as real);\n      j := j + 1;\n    }\n  }\n  method CalculateColumnStds(means: array<real>) returns (stds: array<real>)\n  {\n    stds := new real[features.Length1];\n    \n    var j := 0;\n    while j < features.Length1\n    {\n      var sumSquares := 0.0;\n      var i := 0;\n      while i < features.Length0\n      {\n        var diff := features[i,j] - means[j];\n        sumSquares := sumSquares + diff * diff;\n        i := i + 1;\n      }\n      var sqrtVal := 0.0;\n      if sumSquares <= 0.0 {\n        sqrtVal := 1.0;\n      } else {\n        var denominator := (features.Length0 as real) - 1.0;\n        if denominator > 0.0 {\n          sqrtVal := NewtonSqrt(sumSquares / denominator);\n        } else {\n          sqrtVal := 1.0;\n        }\n      }\n      stds[j] := sqrtVal;\n      j := j + 1;\n    }\n  }\n  function NewtonSqrt(x: real): real\n  {\n    if x == 0.0 then \n      0.0\n    else\n      NewtonSqrtHelper(x, x/2.0, 10)\n  }\n  function NewtonSqrtHelper(x: real, approx: real, iter: nat): real\n  {\n    if iter == 0 then\n      approx\n    else\n      NewtonSqrtHelper(x, (approx + x/approx)/2.0, iter-1)\n  }\n}", "output": "class Dataset {\n  var features: array2<real>  \n  var targets: array<real>    \n  var numSamples: nat         \n  var numFeatures: nat        \n  predicate Valid()\n    reads this\n  {\n    features.Length0 == numSamples &&\n    features.Length1 == numFeatures &&\n    targets.Length == numSamples &&\n    numSamples > 0\n  }\n  constructor(feat: array2<real>, targ: array<real>)\n    requires feat.Length0 == targ.Length  \n    requires feat.Length1 > 0  \n    requires feat.Length0 > 0\n    ensures Valid()\n    ensures features == feat && targets == targ\n    ensures numSamples == feat.Length0\n    ensures numFeatures == feat.Length1\n  {\n    features := feat;\n    targets := targ;\n    numSamples := feat.Length0;\n    numFeatures := feat.Length1;\n  }\n  method StandardizeFeatures() returns (scaledFeatures: array2<real>)\n    requires Valid()\n    ensures scaledFeatures.Length0 == features.Length0\n    ensures scaledFeatures.Length1 == features.Length1\n  {\n    scaledFeatures := new real[features.Length0, features.Length1];\n    var means := CalculateColumnMeans();\n    var stds := CalculateColumnStds(means);\n    \n    var i := 0;\n    while i < features.Length0\n      invariant 0 <= i <= features.Length0\n      invariant scaledFeatures.Length0 == features.Length0\n      invariant scaledFeatures.Length1 == features.Length1\n    {\n      var j := 0;\n      while j < features.Length1\n        invariant 0 <= j <= features.Length1\n        invariant 0 <= i < features.Length0\n      {\n        if stds[j] != 0.0 {\n          scaledFeatures[i,j] := (features[i,j] - means[j]) / stds[j];\n        } else {\n          scaledFeatures[i,j] := 0.0;\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  method CalculateColumnMeans() returns (means: array<real>)\n    requires Valid() \n    ensures means.Length == features.Length1\n  {\n    means := new real[features.Length1];\n    \n    var j := 0;\n    while j < features.Length1\n      invariant 0 <= j <= features.Length1\n      invariant means.Length == features.Length1\n    {\n      var sum := 0.0;\n      var i := 0;\n      while i < features.Length0\n        invariant 0 <= i <= features.Length0\n        invariant 0 <= j < features.Length1\n      {\n        sum := sum + features[i,j];\n        i := i + 1;\n      }\n      means[j] := sum / (features.Length0 as real);\n      j := j + 1;\n    }\n  }\n  method CalculateColumnStds(means: array<real>) returns (stds: array<real>)\n    requires Valid()\n    requires means.Length == features.Length1\n    ensures stds.Length == features.Length1\n  {\n    stds := new real[features.Length1];\n    \n    var j := 0;\n    while j < features.Length1\n      invariant 0 <= j <= features.Length1\n      invariant stds.Length == features.Length1\n    {\n      var sumSquares := 0.0;\n      var i := 0;\n      while i < features.Length0\n        invariant 0 <= i <= features.Length0\n        invariant 0 <= j < features.Length1\n      {\n        var diff := features[i,j] - means[j];\n        sumSquares := sumSquares + diff * diff;\n        i := i + 1;\n      }\n      var sqrtVal := 0.0;\n      if sumSquares <= 0.0 {\n        sqrtVal := 1.0;\n      } else {\n        var denominator := (features.Length0 as real) - 1.0;\n        if denominator > 0.0 {\n          sqrtVal := NewtonSqrt(sumSquares / denominator);\n        } else {\n          sqrtVal := 1.0;\n        }\n      }\n      stds[j] := sqrtVal;\n      j := j + 1;\n    }\n  }\n  function NewtonSqrt(x: real): real\n    requires x >= 0.0\n    ensures NewtonSqrt(x) >= 0.0\n  {\n    if x == 0.0 then \n      0.0\n    else\n      NewtonSqrtHelper(x, x/2.0, 10)\n  }\n  function NewtonSqrtHelper(x: real, approx: real, iter: nat): real\n    requires x >= 0.0\n    requires approx > 0.0\n    ensures NewtonSqrtHelper(x, approx, iter) >= 0.0\n    decreases iter\n  {\n    if iter == 0 then\n      approx\n    else\n      NewtonSqrtHelper(x, (approx + x/approx)/2.0, iter-1)\n  }\n}", "name": "py2dfy_112", "id": 112}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Request = Request(timestamp: string, requestType: string)\ndatatype Server = Server(pid: int)\ndatatype Machine = Machine(id: int, eeTag: string, name: string, description: string, ip: string, port: int)\ndatatype Result<T,E> = Success(value: T) | Error(error: E)\ndatatype Option<T> = Some(value: T) | None\nclass FlaskServer {\n  \n  var requests: seq<Request>\n  var activeServers: seq<Server>\n  \n  \n  constructor()\n  {\n    requests := [];\n    activeServers := [];\n  }\n  \n  method GetIndexPage() returns (output: string)\n  {\n    var newRequest := Request(\"current_time\", \"INDEX\");\n    requests := [newRequest] + requests;\n    output := \"Welcome to the subserver API\";\n  }\n  \n  method StartServer() returns (result: Result<Server, string>)\n  {\n    var newRequest := Request(\"current_time\", \"START\");\n    requests := [newRequest] + requests;\n    \n    var newServer := Server(fresh_pid());\n    activeServers := [newServer] + activeServers;\n    result := Success(newServer);\n  }\n  \n  method StopServers() returns (message: string)\n  {\n    var newRequest := Request(\"current_time\", \"STOP\");\n    requests := [newRequest] + requests;\n    \n    activeServers := [];\n    return \"Server stopped.\";\n  }\n  \n  function {:axiom} fresh_pid(): int\n}\nclass HomeCallManager {\n  const EE_TAG: string\n  const NAME: string\n  const DESCRIPTION: string\n  const PORT: int\n  \n  constructor(eeTag: string, name: string, description: string, port: int)\n  {\n    EE_TAG := eeTag;\n    NAME := name;\n    DESCRIPTION := description;\n    PORT := port;\n  }\n  method CallHome(knownMachines: seq<Machine>) returns (success: bool)\n  {\n    var ip := GetLocalIP();\n    var matchingId: Option<int> := None;\n    \n    \n    var i := 0;\n    while i < |knownMachines|\n        exists j :: 0 <= j < i && knownMachines[j].eeTag == EE_TAG\n        exists j :: 0 <= j < i && knownMachines[j].id == matchingId.value\n    {\n      if knownMachines[i].eeTag == EE_TAG {\n        matchingId := Some(knownMachines[i].id);\n        break;\n      }\n      i := i + 1;\n    }\n    if matchingId.Some? {\n      success := UpdateMachine(matchingId.value, ip);\n      if success {\n      }\n    } else {\n      success := false; \n    }\n  }\n  \n  method {:axiom} GetLocalIP() returns (ip: string)\n  method {:axiom} UpdateMachine(id: int, ip: string) returns (success: bool)\n  method {:axiom} CreateNewMachine(ip: string) returns (success: bool)\n}", "output": "datatype Request = Request(timestamp: string, requestType: string)\ndatatype Server = Server(pid: int)\ndatatype Machine = Machine(id: int, eeTag: string, name: string, description: string, ip: string, port: int)\ndatatype Result<T,E> = Success(value: T) | Error(error: E)\ndatatype Option<T> = Some(value: T) | None\nclass FlaskServer {\n  \n  var requests: seq<Request>\n  var activeServers: seq<Server>\n  \n  \n  constructor()\n    ensures requests == []\n    ensures activeServers == []\n  {\n    requests := [];\n    activeServers := [];\n  }\n  \n  method GetIndexPage() returns (output: string)\n    modifies this\n    ensures |requests| > 0  \n    ensures requests[0].requestType == \"INDEX\"  \n  {\n    var newRequest := Request(\"current_time\", \"INDEX\");\n    requests := [newRequest] + requests;\n    output := \"Welcome to the subserver API\";\n  }\n  \n  method StartServer() returns (result: Result<Server, string>)\n    modifies this\n    ensures |activeServers| > old(|activeServers|) ==> result.Success?\n    ensures result.Error? ==> activeServers == old(activeServers)\n    ensures |requests| > 0 && requests[0].requestType == \"START\"\n  {\n    var newRequest := Request(\"current_time\", \"START\");\n    requests := [newRequest] + requests;\n    \n    var newServer := Server(fresh_pid());\n    activeServers := [newServer] + activeServers;\n    result := Success(newServer);\n  }\n  \n  method StopServers() returns (message: string)\n    modifies this\n    ensures activeServers == []  \n    ensures |requests| > 0 && requests[0].requestType == \"STOP\"\n  {\n    var newRequest := Request(\"current_time\", \"STOP\");\n    requests := [newRequest] + requests;\n    \n    activeServers := [];\n    return \"Server stopped.\";\n  }\n  \n  function {:axiom} fresh_pid(): int\n    ensures fresh_pid() > 0\n}\nclass HomeCallManager {\n  const EE_TAG: string\n  const NAME: string\n  const DESCRIPTION: string\n  const PORT: int\n  \n  constructor(eeTag: string, name: string, description: string, port: int)\n    requires port > 0\n    ensures EE_TAG == eeTag\n    ensures NAME == name\n    ensures DESCRIPTION == description\n    ensures PORT == port\n  {\n    EE_TAG := eeTag;\n    NAME := name;\n    DESCRIPTION := description;\n    PORT := port;\n  }\n  method CallHome(knownMachines: seq<Machine>) returns (success: bool)\n    requires forall m :: m in knownMachines ==> m.port > 0\n    requires forall m :: m in knownMachines ==> m.id > 0\n    ensures success ==> exists m :: m in knownMachines && m.eeTag == EE_TAG\n  {\n    var ip := GetLocalIP();\n    var matchingId: Option<int> := None;\n    \n    \n    var i := 0;\n    while i < |knownMachines|\n      invariant 0 <= i <= |knownMachines|\n      invariant matchingId.Some? ==> \n        exists j :: 0 <= j < i && knownMachines[j].eeTag == EE_TAG\n      invariant matchingId.Some? ==> \n        exists j :: 0 <= j < i && knownMachines[j].id == matchingId.value\n    {\n      if knownMachines[i].eeTag == EE_TAG {\n        matchingId := Some(knownMachines[i].id);\n        break;\n      }\n      i := i + 1;\n    }\n    if matchingId.Some? {\n      success := UpdateMachine(matchingId.value, ip);\n      if success {\n        assert exists m :: m in knownMachines && m.eeTag == EE_TAG;\n      }\n    } else {\n      success := false; \n    }\n  }\n  \n  method {:axiom} GetLocalIP() returns (ip: string)\n    ensures |ip| > 0\n  method {:axiom} UpdateMachine(id: int, ip: string) returns (success: bool)\n    requires id > 0\n    requires |ip| > 0\n  method {:axiom} CreateNewMachine(ip: string) returns (success: bool)\n    requires |ip| > 0\n}", "name": "py2dfy_120", "id": 120}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type PID = int\nclass ProcessManager {\n  \n  var currentPid: PID\n  \n  var childProcesses: set<PID>\n  \n  \n  predicate Valid()\n  {\n    currentPid > 0 && \n    forall p :: p in childProcesses ==> p > 0 && p != currentPid\n  }\n  constructor()\n  {\n    \n    currentPid := 1;\n    childProcesses := {};\n  }\n  \n  method GetPid() returns (pid: PID)\n  {\n    pid := currentPid;\n  }\n  \n  method CreateProcess() returns (childPid: PID)\n  {\n    \n    childPid := currentPid + |childProcesses| + 1;\n    childProcesses := childProcesses + {childPid};\n  }\n  \n  method ProcessDemo()\n  {\n    var pid := GetPid();\n    print \"Process (\", pid, \") start...\\n\";\n    \n    var childPid := CreateProcess();\n    \n    if childPid == 0 {  \n      var parentPid := GetPid();\n      print \"I'm child process (\", pid, \") and my parent is \", parentPid, \".\\n\";\n    } else {\n      print \"I (\", pid, \") just created a child process (\", childPid, \").\\n\";\n    }\n  }\n}", "output": "type PID = int\nclass ProcessManager {\n  \n  var currentPid: PID\n  \n  var childProcesses: set<PID>\n  \n  \n  predicate Valid()\n    reads this\n  {\n    currentPid > 0 && \n    forall p :: p in childProcesses ==> p > 0 && p != currentPid\n  }\n  constructor()\n    ensures Valid()\n    ensures currentPid > 0\n    ensures childProcesses == {}\n  {\n    \n    currentPid := 1;\n    childProcesses := {};\n  }\n  \n  method GetPid() returns (pid: PID)\n    requires Valid()\n    ensures pid == currentPid\n    ensures Valid()\n  {\n    pid := currentPid;\n  }\n  \n  method CreateProcess() returns (childPid: PID)\n    requires Valid()\n    ensures Valid()\n    ensures childPid > 0\n    ensures childPid != currentPid\n    ensures childProcesses == old(childProcesses) + {childPid}\n    modifies this\n  {\n    \n    childPid := currentPid + |childProcesses| + 1;\n    childProcesses := childProcesses + {childPid};\n  }\n  \n  method ProcessDemo()\n    requires Valid()\n    ensures Valid()\n    modifies this\n  {\n    var pid := GetPid();\n    print \"Process (\", pid, \") start...\\n\";\n    \n    var childPid := CreateProcess();\n    \n    if childPid == 0 {  \n      var parentPid := GetPid();\n      print \"I'm child process (\", pid, \") and my parent is \", parentPid, \".\\n\";\n    } else {\n      print \"I (\", pid, \") just created a child process (\", childPid, \").\\n\";\n    }\n  }\n}", "name": "py2dfy_137", "id": 137}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Dataset = Dataset(\n  chr: seq<int>,\n  studies: seq<string>, \n  snps: map<string, int>  \n)\nclass Service {\n  \n  var dataset: Dataset\n  \n  constructor()\n  {\n    dataset := Dataset([], [], map[]);\n  }\n  \n  method QuerySnp(snp: string, start: int, size: int) returns (result: map<string, seq<int>>)\n      (start < |dataset.chr| ==>\n        result[\"chr\"] == dataset.chr[start..if start + size <= |dataset.chr| then start + size else |dataset.chr|])\n      (start >= |dataset.chr| ==> result[\"chr\"] == [])\n  {\n    if snp !in dataset.snps {\n      return map[];  \n    }\n    \n    var chrValues := dataset.chr;\n    var resultChr: seq<int>;\n    \n    \n    if start < |chrValues| {\n      var end := if start + size <= |chrValues| then start + size else |chrValues|;\n      resultChr := chrValues[start..end];\n    } else {\n      resultChr := [];\n    }\n    result := map[\"chr\" := resultChr];\n  }\n  \n  method GetSnpSize(snp: string) returns (size: int)\n  {\n    if snp !in dataset.snps {\n      return -1;  \n    }\n    \n    return |dataset.studies|;\n  }\n  \n  method LoadStudy(studyId: string, snpId: string, chromosome: int)\n  {\n    dataset := Dataset(\n      dataset.chr + [chromosome],\n      dataset.studies + [studyId],\n      dataset.snps[snpId := chromosome]\n    );\n  }\n}\nmethod TestQueryForSnp()\n{\n  var service := new Service();\n  \n  \n  service.LoadStudy(\"PM001\", \"rs7085086\", 2);\n  service.LoadStudy(\"PM002\", \"rs7085086\", 2);\n  service.LoadStudy(\"PM003\", \"rs7085086\", 2);\n  var result := service.QuerySnp(\"rs7085086\", 0, 20);\n  \n  \n}", "output": "datatype Dataset = Dataset(\n  chr: seq<int>,\n  studies: seq<string>, \n  snps: map<string, int>  \n)\nclass Service {\n  \n  var dataset: Dataset\n  \n  constructor()\n    ensures dataset.snps.Keys == {}\n    ensures dataset.chr == []\n    ensures dataset.studies == []\n  {\n    dataset := Dataset([], [], map[]);\n  }\n  \n  method QuerySnp(snp: string, start: int, size: int) returns (result: map<string, seq<int>>)\n    requires start >= 0\n    requires size > 0\n    requires dataset.snps != map[]  \n    ensures snp in dataset.snps ==> \"chr\" in result.Keys\n    ensures snp !in dataset.snps ==> result == map[]\n    ensures \"chr\" in result.Keys ==> |result[\"chr\"]| <= size\n    ensures snp in dataset.snps ==> \n      (start < |dataset.chr| ==>\n        result[\"chr\"] == dataset.chr[start..if start + size <= |dataset.chr| then start + size else |dataset.chr|])\n    ensures snp in dataset.snps ==>\n      (start >= |dataset.chr| ==> result[\"chr\"] == [])\n  {\n    if snp !in dataset.snps {\n      return map[];  \n    }\n    \n    var chrValues := dataset.chr;\n    var resultChr: seq<int>;\n    \n    \n    if start < |chrValues| {\n      var end := if start + size <= |chrValues| then start + size else |chrValues|;\n      resultChr := chrValues[start..end];\n    } else {\n      resultChr := [];\n    }\n    result := map[\"chr\" := resultChr];\n  }\n  \n  method GetSnpSize(snp: string) returns (size: int)\n    requires dataset.snps != map[]  \n    ensures snp in dataset.snps ==> size >= 0\n    ensures snp !in dataset.snps ==> size == -1  \n  {\n    if snp !in dataset.snps {\n      return -1;  \n    }\n    \n    return |dataset.studies|;\n  }\n  \n  method LoadStudy(studyId: string, snpId: string, chromosome: int)\n    requires studyId != \"\"\n    requires chromosome > 0\n    modifies this\n    ensures old(dataset.studies) + [studyId] == dataset.studies\n    ensures snpId in dataset.snps\n    ensures dataset.snps[snpId] == chromosome\n    ensures dataset.chr == old(dataset.chr) + [chromosome]\n  {\n    dataset := Dataset(\n      dataset.chr + [chromosome],\n      dataset.studies + [studyId],\n      dataset.snps[snpId := chromosome]\n    );\n  }\n}\nmethod TestQueryForSnp()\n{\n  var service := new Service();\n  \n  \n  service.LoadStudy(\"PM001\", \"rs7085086\", 2);\n  service.LoadStudy(\"PM002\", \"rs7085086\", 2);\n  service.LoadStudy(\"PM003\", \"rs7085086\", 2);\n  var result := service.QuerySnp(\"rs7085086\", 0, 20);\n  \n  \n  assert \"chr\" in result.Keys;\n  assert |result[\"chr\"]| == 3;\n  assert forall i :: 0 <= i < |result[\"chr\"]| ==> result[\"chr\"][i] == 2;\n}", "name": "py2dfy_110", "id": 110}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Position = Position(x: real, y: real)\ndatatype CarState = CarState(pos: Position, orientation: real)\ndatatype Action = Action(phi: real, ds: real)\nclass Agent {\n  method BeamSearch(\n    gameState: CarState, \n    numAction: nat, \n    initialState: CarState, \n    beamWidth: nat\n  ) returns (bestState: CarState, bestScore: real)\n  {\n    var currentStates: seq<(CarState, seq<Action>)> := [(gameState, [])];\n    var depth := 0;\n    bestScore := -1000.0;\n    bestState := gameState;\n    \n    while depth < numAction && |currentStates| > 0\n    {\n      var nextStates: seq<(CarState, seq<Action>)> := [];\n      \n      var i := 0;\n      while i < |currentStates| \n      {\n        var (state, actions) := currentStates[i];\n        \n        var legalMoves := GetLegalActions(state);\n        \n        var successors := GenerateSuccessors(state, legalMoves, actions);\n        \n        \n        \n        nextStates := nextStates + successors;\n        \n        i := i + 1;\n      }\n      \n      if |nextStates| > beamWidth {\n        nextStates := SelectTopStates(nextStates, beamWidth);\n      }\n      \n      if |nextStates| > 0 {\n        var currentBest := GetBestScore(nextStates);\n        if currentBest > bestScore {\n          bestScore := currentBest;\n          bestState := GetStateWithScore(nextStates, currentBest);\n        }\n      }\n      \n      currentStates := nextStates;\n      depth := depth + 1;\n    }\n  }\n  method GetLegalActions(state: CarState) returns (actions: seq<Action>)\n  {\n    actions := [Action(0.0, 0.0)];\n  }\n  method GenerateSuccessors(\n    state: CarState, \n    actions: seq<Action>,\n    history: seq<Action>\n  ) returns (successors: seq<(CarState, seq<Action>)>)\n  {\n    successors := [(state, history + [actions[0]])];\n  }\n  method SelectTopStates(\n    states: seq<(CarState, seq<Action>)>,\n    n: nat\n  ) returns (selected: seq<(CarState, seq<Action>)>)\n  {\n    selected := states[..min(n, |states|)];\n  }\n  method GetBestScore(states: seq<(CarState, seq<Action>)>) returns (score: real)\n  {\n    score := -1000.0;\n  }\n  method GetStateWithScore(states: seq<(CarState, seq<Action>)>, score: real) returns (state: CarState)\n  {\n    state := states[0].0;\n  }\n  function min(a: int, b: int): int\n  {\n    if a <= b then a else b\n  }\n}", "output": "datatype Position = Position(x: real, y: real)\ndatatype CarState = CarState(pos: Position, orientation: real)\ndatatype Action = Action(phi: real, ds: real)\nclass Agent {\n  method BeamSearch(\n    gameState: CarState, \n    numAction: nat, \n    initialState: CarState, \n    beamWidth: nat\n  ) returns (bestState: CarState, bestScore: real)\n    requires beamWidth > 0\n    requires numAction > 0\n    ensures bestScore >= -1000.0\n  {\n    var currentStates: seq<(CarState, seq<Action>)> := [(gameState, [])];\n    var depth := 0;\n    bestScore := -1000.0;\n    bestState := gameState;\n    \n    while depth < numAction && |currentStates| > 0\n      invariant forall state :: state in currentStates ==> |state.1| == depth\n      invariant bestScore >= -1000.0\n      decreases numAction - depth\n    {\n      var nextStates: seq<(CarState, seq<Action>)> := [];\n      \n      var i := 0;\n      while i < |currentStates| \n        invariant 0 <= i <= |currentStates|\n        invariant |nextStates| >= 0\n        invariant forall state :: state in nextStates ==> |state.1| == depth + 1\n        decreases |currentStates| - i\n      {\n        var (state, actions) := currentStates[i];\n        \n        var legalMoves := GetLegalActions(state);\n        \n        var successors := GenerateSuccessors(state, legalMoves, actions);\n        \n        \n        assert forall s :: s in successors ==> |s.1| == |actions| + 1;\n        assert forall s :: s in successors ==> |s.1| == depth + 1;\n        \n        nextStates := nextStates + successors;\n        \n        i := i + 1;\n      }\n      \n      if |nextStates| > beamWidth {\n        nextStates := SelectTopStates(nextStates, beamWidth);\n      }\n      \n      if |nextStates| > 0 {\n        var currentBest := GetBestScore(nextStates);\n        if currentBest > bestScore {\n          bestScore := currentBest;\n          bestState := GetStateWithScore(nextStates, currentBest);\n        }\n      }\n      \n      currentStates := nextStates;\n      depth := depth + 1;\n    }\n  }\n  method GetLegalActions(state: CarState) returns (actions: seq<Action>)\n    ensures |actions| > 0\n  {\n    actions := [Action(0.0, 0.0)];\n  }\n  method GenerateSuccessors(\n    state: CarState, \n    actions: seq<Action>,\n    history: seq<Action>\n  ) returns (successors: seq<(CarState, seq<Action>)>)\n    requires |actions| > 0\n    ensures |successors| > 0\n    ensures forall s :: s in successors ==> |s.1| == |history| + 1\n  {\n    successors := [(state, history + [actions[0]])];\n  }\n  method SelectTopStates(\n    states: seq<(CarState, seq<Action>)>,\n    n: nat\n  ) returns (selected: seq<(CarState, seq<Action>)>)\n    requires n > 0\n    requires |states| > 0\n    ensures |selected| <= n\n    ensures |selected| > 0\n    ensures forall i :: 0 <= i < |selected| ==> selected[i] in states\n  {\n    selected := states[..min(n, |states|)];\n  }\n  method GetBestScore(states: seq<(CarState, seq<Action>)>) returns (score: real)\n    requires |states| > 0\n  {\n    score := -1000.0;\n  }\n  method GetStateWithScore(states: seq<(CarState, seq<Action>)>, score: real) returns (state: CarState)\n    requires |states| > 0\n  {\n    state := states[0].0;\n  }\n  function min(a: int, b: int): int\n  {\n    if a <= b then a else b\n  }\n}", "name": "py2dfy_150", "id": 150}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module PushEnvironment {\n  \n  class Position {\n    var x: real\n    var y: real\n    constructor(x_: real, y_: real)\n    {\n      x := x_;\n      y := y_;\n    }\n  }\n  \n  trait PushTask {\n    \n    var robotPos: Position?\n    \n    var objectPos: Position?\n    \n    var goalPos: Position?\n    \n    ghost var Valid: bool\n    \n    method Initialize(robot: Position?, obj: Position?, goal: Position?)\n    {\n      robotPos := robot;\n      objectPos := obj;\n      goalPos := goal;\n      Valid := true;\n    }\n    \n    method IsComplete() returns (complete: bool)\n    {\n      complete := IsAtGoal(objectPos, goalPos);\n    }\n    \n    predicate IsAtGoal(pos1: Position?, pos2: Position?)\n    {\n      (pos1.x - pos2.x) * (pos1.x - pos2.x) + \n      (pos1.y - pos2.y) * (pos1.y - pos2.y) < 0.01\n    }\n  }\n  \n  class SawyerPush extends PushTask {\n    \n    var jointAngles: array<real>\n    constructor()\n    {\n      jointAngles := new real[7];\n      robotPos := null;\n      objectPos := null;\n      goalPos := null;\n      Valid := false;\n    }\n    \n    method MoveToPosition(target: Position?)\n              -3.14 <= jointAngles[i] <= 3.14  \n    {\n      \n      robotPos.x := target.x;\n      robotPos.y := target.y;\n      \n      var i := 0;\n      while i < jointAngles.Length\n                  -3.14 <= jointAngles[k] <= 3.14\n      {\n        \n        jointAngles[i] := 0.0;  \n        i := i + 1;\n      }\n    }\n  }\n}", "output": "module PushEnvironment {\n  \n  class Position {\n    var x: real\n    var y: real\n    constructor(x_: real, y_: real)\n      ensures x == x_ && y == y_\n    {\n      x := x_;\n      y := y_;\n    }\n  }\n  \n  trait PushTask {\n    \n    var robotPos: Position?\n    \n    var objectPos: Position?\n    \n    var goalPos: Position?\n    \n    ghost var Valid: bool\n    \n    method Initialize(robot: Position?, obj: Position?, goal: Position?)\n      requires robot != null && obj != null && goal != null\n      modifies this\n      ensures robotPos == robot && objectPos == obj && goalPos == goal\n      ensures Valid\n    {\n      robotPos := robot;\n      objectPos := obj;\n      goalPos := goal;\n      Valid := true;\n    }\n    \n    method IsComplete() returns (complete: bool)\n      requires Valid\n      requires objectPos != null && goalPos != null\n      ensures complete ==> IsAtGoal(objectPos, goalPos)\n    {\n      complete := IsAtGoal(objectPos, goalPos);\n    }\n    \n    predicate IsAtGoal(pos1: Position?, pos2: Position?)\n      requires pos1 != null && pos2 != null\n      reads pos1, pos2\n    {\n      (pos1.x - pos2.x) * (pos1.x - pos2.x) + \n      (pos1.y - pos2.y) * (pos1.y - pos2.y) < 0.01\n    }\n  }\n  \n  class SawyerPush extends PushTask {\n    \n    var jointAngles: array<real>\n    constructor()\n      ensures fresh(jointAngles)\n      ensures jointAngles.Length == 7  \n      ensures robotPos == null && objectPos == null && goalPos == null\n      ensures !Valid\n    {\n      jointAngles := new real[7];\n      robotPos := null;\n      objectPos := null;\n      goalPos := null;\n      Valid := false;\n    }\n    \n    method MoveToPosition(target: Position?)\n      requires Valid && target != null\n      requires robotPos != null\n      modifies robotPos, jointAngles\n      ensures robotPos.x == target.x && robotPos.y == target.y\n      ensures forall i :: 0 <= i < jointAngles.Length ==> \n              -3.14 <= jointAngles[i] <= 3.14  \n    {\n      \n      robotPos.x := target.x;\n      robotPos.y := target.y;\n      \n      var i := 0;\n      while i < jointAngles.Length\n        invariant 0 <= i <= jointAngles.Length\n        invariant forall k :: 0 <= k < i ==> \n                  -3.14 <= jointAngles[k] <= 3.14\n        invariant robotPos.x == target.x && robotPos.y == target.y\n        decreases jointAngles.Length - i\n      {\n        \n        jointAngles[i] := 0.0;  \n        i := i + 1;\n      }\n    }\n  }\n}", "name": "py2dfy_122", "id": 122}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Level = Easy | Medium | Hard\nclass Stopwatch {\n  \n  var totalMilliseconds: int\n  var acceptCount: int\n  var totalCount: int\n  var score: real\n  var currentLevel: Level\n  \n  predicate Valid()\n  {\n    totalMilliseconds >= 0 &&\n    acceptCount >= 0 &&\n    totalCount >= 0 &&\n    acceptCount <= totalCount &&\n    0.0 <= score <= 100.0\n  }\n  \n  constructor()\n  {\n    totalMilliseconds := 0;\n    acceptCount := 0;\n    totalCount := 0;\n    score := 0.0;\n    currentLevel := Easy;\n  }\n  \n  function FormatTime(): (result: string)\n  {\n    var minutes := totalMilliseconds / 600;  \n    var seconds := (totalMilliseconds / 10) % 60;\n    var decisecond := totalMilliseconds % 10;\n    \n    match currentLevel\n    case Easy => \n      if seconds >= 10 then\n        Itos(minutes) + \":\" + Itos(seconds) + \".\" + Itos(decisecond)\n      else\n        Itos(minutes) + \":0\" + Itos(seconds) + \".\" + Itos(decisecond)\n    case Medium =>\n      if seconds >= 10 then\n        Itos(minutes) + \":\" + Itos(seconds) + \".*\"\n      else\n        Itos(minutes) + \":0\" + Itos(seconds) + \".*\"\n    case Hard =>\n      Itos(minutes) + \":\" + Itos(seconds/10) + \"*.*\"\n  }\n  \n  static function Itos(n: int): string\n  {\n    if n < 10 then [((48 + n) as char)]\n    else Itos(n/10) + [((48 + (n%10)) as char)]\n  }\n  \n  method Update()\n  {\n    totalMilliseconds := totalMilliseconds + 1;\n  }\n  \n  method Judge()\n  {\n    totalCount := totalCount + 1;\n    if totalMilliseconds > 10 && totalMilliseconds % 10 == 0 {\n      acceptCount := acceptCount + 1;\n    }\n    score := (acceptCount as real / totalCount as real) * 100.0;\n  }\n  \n  method Reset()\n  {\n    totalMilliseconds := 0;\n    acceptCount := 0;\n    totalCount := 0;\n    score := 0.0;\n  }\n  \n  method SetLevel(level: Level)\n  {\n    currentLevel := level;\n  }\n}", "output": "datatype Level = Easy | Medium | Hard\nclass Stopwatch {\n  \n  var totalMilliseconds: int\n  var acceptCount: int\n  var totalCount: int\n  var score: real\n  var currentLevel: Level\n  \n  predicate Valid()\n  reads this\n  {\n    totalMilliseconds >= 0 &&\n    acceptCount >= 0 &&\n    totalCount >= 0 &&\n    acceptCount <= totalCount &&\n    0.0 <= score <= 100.0\n  }\n  \n  constructor()\n    ensures Valid()\n    ensures totalMilliseconds == 0\n    ensures acceptCount == 0 && totalCount == 0\n    ensures score == 0.0\n    ensures currentLevel == Easy\n  {\n    totalMilliseconds := 0;\n    acceptCount := 0;\n    totalCount := 0;\n    score := 0.0;\n    currentLevel := Easy;\n  }\n  \n  function FormatTime(): (result: string)\n    requires Valid()\n    reads this\n    ensures result != \"\"\n  {\n    var minutes := totalMilliseconds / 600;  \n    var seconds := (totalMilliseconds / 10) % 60;\n    var decisecond := totalMilliseconds % 10;\n    \n    match currentLevel\n    case Easy => \n      if seconds >= 10 then\n        Itos(minutes) + \":\" + Itos(seconds) + \".\" + Itos(decisecond)\n      else\n        Itos(minutes) + \":0\" + Itos(seconds) + \".\" + Itos(decisecond)\n    case Medium =>\n      if seconds >= 10 then\n        Itos(minutes) + \":\" + Itos(seconds) + \".*\"\n      else\n        Itos(minutes) + \":0\" + Itos(seconds) + \".*\"\n    case Hard =>\n      Itos(minutes) + \":\" + Itos(seconds/10) + \"*.*\"\n  }\n  \n  static function Itos(n: int): string\n    requires n >= 0\n    decreases n\n  {\n    if n < 10 then [((48 + n) as char)]\n    else Itos(n/10) + [((48 + (n%10)) as char)]\n  }\n  \n  method Update()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures totalMilliseconds == old(totalMilliseconds) + 1\n  {\n    totalMilliseconds := totalMilliseconds + 1;\n  }\n  \n  method Judge()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures totalCount == old(totalCount) + 1\n    ensures acceptCount <= old(acceptCount) + 1\n    ensures acceptCount >= old(acceptCount)\n  {\n    totalCount := totalCount + 1;\n    if totalMilliseconds > 10 && totalMilliseconds % 10 == 0 {\n      acceptCount := acceptCount + 1;\n    }\n    score := (acceptCount as real / totalCount as real) * 100.0;\n  }\n  \n  method Reset()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures totalMilliseconds == 0\n    ensures acceptCount == 0 && totalCount == 0\n    ensures score == 0.0\n  {\n    totalMilliseconds := 0;\n    acceptCount := 0;\n    totalCount := 0;\n    score := 0.0;\n  }\n  \n  method SetLevel(level: Level)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures currentLevel == level\n  {\n    currentLevel := level;\n  }\n}", "name": "py2dfy_129", "id": 129}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module Constants {\n  \n  const IMAGENET_MEAN: seq<real> := [0.485, 0.456, 0.406]\n  const IMAGENET_STD: seq<real> := [0.229, 0.224, 0.225]\n  \n  \n  lemma ImageNetConstantsValidation()\n  {\n    \n  }\n  \n  \n  const US_N: real := 49.4\n  const US_S: real := 24.5\n  const US_E: real := -66.93\n  const US_W: real := -124.784\n  \n  \n  lemma USBoundariesValidation()\n  {\n    \n  }\n  \n  \n  const TEST_IMG_PATH: seq<string> := [\".circleci/images/test_image.png\", \".circleci/images/test_image.png\"]\n  \n  \n  lemma TestImagePathValidation()\n  {\n    \n  }\n  \n  \n  method IsWithinUS(lat: real, lng: real) returns (result: bool)\n  {\n    return US_S <= lat <= US_N && US_W <= lng <= US_E;\n  }\n  \n  \n  method NormalizeRGB(rgb: seq<real>) returns (normalized: seq<real>)\n  {\n    normalized := [];\n    var i := 0;\n    \n    \n    while i < |rgb|\n    {\n      var normalizedValue := (rgb[i]/255.0 - IMAGENET_MEAN[i]) / IMAGENET_STD[i];\n      normalized := normalized + [normalizedValue];\n      i := i + 1;\n    }\n  }\n}", "output": "module Constants {\n  \n  const IMAGENET_MEAN: seq<real> := [0.485, 0.456, 0.406]\n  const IMAGENET_STD: seq<real> := [0.229, 0.224, 0.225]\n  \n  \n  lemma ImageNetConstantsValidation()\n    ensures |IMAGENET_MEAN| == 3\n    ensures |IMAGENET_STD| == 3\n    ensures forall i :: 0 <= i < |IMAGENET_MEAN| ==> 0.0 <= IMAGENET_MEAN[i] <= 1.0\n    ensures forall i :: 0 <= i < |IMAGENET_STD| ==> 0.0 <= IMAGENET_STD[i] <= 1.0\n  {\n    \n  }\n  \n  \n  const US_N: real := 49.4\n  const US_S: real := 24.5\n  const US_E: real := -66.93\n  const US_W: real := -124.784\n  \n  \n  lemma USBoundariesValidation()\n    ensures US_N > US_S  \n    ensures US_E > US_W  \n    ensures -90.0 <= US_S && US_N <= 90.0  \n    ensures -180.0 <= US_W && US_E <= 180.0  \n  {\n    \n  }\n  \n  \n  const TEST_IMG_PATH: seq<string> := [\".circleci/images/test_image.png\", \".circleci/images/test_image.png\"]\n  \n  \n  lemma TestImagePathValidation()\n    ensures |TEST_IMG_PATH| == 2\n    ensures forall i :: 0 <= i < |TEST_IMG_PATH| ==> TEST_IMG_PATH[i] == \".circleci/images/test_image.png\"\n  {\n    \n  }\n  \n  \n  method IsWithinUS(lat: real, lng: real) returns (result: bool)\n    ensures result <==> (US_S <= lat <= US_N && US_W <= lng <= US_E)\n  {\n    return US_S <= lat <= US_N && US_W <= lng <= US_E;\n  }\n  \n  \n  method NormalizeRGB(rgb: seq<real>) returns (normalized: seq<real>)\n    requires |rgb| == 3\n    requires forall i :: 0 <= i < |rgb| ==> 0.0 <= rgb[i] <= 255.0\n    ensures |normalized| == 3\n    ensures forall i :: 0 <= i < |normalized| ==> normalized[i] == (rgb[i]/255.0 - IMAGENET_MEAN[i]) / IMAGENET_STD[i]\n  {\n    normalized := [];\n    var i := 0;\n    \n    \n    while i < |rgb|\n      invariant 0 <= i <= |rgb|\n      invariant |normalized| == i\n      invariant forall j :: 0 <= j < i ==> normalized[j] == (rgb[j]/255.0 - IMAGENET_MEAN[j]) / IMAGENET_STD[j]\n    {\n      var normalizedValue := (rgb[i]/255.0 - IMAGENET_MEAN[i]) / IMAGENET_STD[i];\n      normalized := normalized + [normalizedValue];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_170", "id": 170}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype SensorData = SensorData(s1: int, s2: int, s3: int, s4: int)\ndatatype TimeStamp = TimeStamp(date: string, time: string)\ndatatype MonitorData = MonitorData(timestamp: TimeStamp, sensorData: SensorData)\nclass SerialMonitor {\n    \n    const port: string\n    constructor()\n    {\n        port := \"/dev/ttyACM0\";\n    }\n    \n    method ClearData(data: string) returns (cleaned: string)\n    {\n        \n        \n        cleaned := data;\n    }\n    \n    method ReadRawData() returns (raw: string)\n    {\n        \n        raw := \"{}\";  \n    }\n    \n    method ParseSensorData(jsonStr: string) returns (data: SensorData)\n    {\n        \n        data := SensorData(0, 0, 0, 0);\n    }\n    \n    method GetCurrentTimestamp() returns (ts: TimeStamp)\n    {\n        \n        ts := TimeStamp(\"2024-03-19\", \"00:00:00\");\n    }\n    \n    method Read() returns (result: MonitorData)\n    {\n        var rawData := ReadRawData();\n        var cleanData := ClearData(rawData);\n        var sensorData := ParseSensorData(cleanData);\n        var timestamp := GetCurrentTimestamp();\n        result := MonitorData(timestamp, sensorData);\n    }\n}\nmethod Main()\n{\n    var monitor := new SerialMonitor();\n    \n    \n    var i := 0;\n    while i < 5  \n    {\n        var data := monitor.Read();\n        i := i + 1;\n    }\n}", "output": "datatype SensorData = SensorData(s1: int, s2: int, s3: int, s4: int)\ndatatype TimeStamp = TimeStamp(date: string, time: string)\ndatatype MonitorData = MonitorData(timestamp: TimeStamp, sensorData: SensorData)\nclass SerialMonitor {\n    \n    const port: string\n    constructor()\n    ensures port == \"/dev/ttyACM0\"\n    {\n        port := \"/dev/ttyACM0\";\n    }\n    \n    method ClearData(data: string) returns (cleaned: string)\n        ensures |cleaned| <= |data|  \n    {\n        \n        \n        cleaned := data;\n    }\n    \n    method ReadRawData() returns (raw: string)\n    {\n        \n        raw := \"{}\";  \n    }\n    \n    method ParseSensorData(jsonStr: string) returns (data: SensorData)\n        ensures data.s1 >= 0  \n        ensures data.s2 >= 0\n        ensures data.s3 >= 0\n        ensures data.s4 >= 0\n    {\n        \n        data := SensorData(0, 0, 0, 0);\n    }\n    \n    method GetCurrentTimestamp() returns (ts: TimeStamp)\n    {\n        \n        ts := TimeStamp(\"2024-03-19\", \"00:00:00\");\n    }\n    \n    method Read() returns (result: MonitorData)\n        ensures result.sensorData.s1 >= 0\n        ensures result.sensorData.s2 >= 0\n        ensures result.sensorData.s3 >= 0\n        ensures result.sensorData.s4 >= 0\n    {\n        var rawData := ReadRawData();\n        var cleanData := ClearData(rawData);\n        var sensorData := ParseSensorData(cleanData);\n        var timestamp := GetCurrentTimestamp();\n        result := MonitorData(timestamp, sensorData);\n    }\n}\nmethod Main()\n{\n    var monitor := new SerialMonitor();\n    \n    \n    var i := 0;\n    while i < 5  \n        invariant 0 <= i <= 5\n        decreases 5 - i\n    {\n        var data := monitor.Read();\n        i := i + 1;\n    }\n}", "name": "py2dfy_159", "id": 159}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype User = User(id: int, username: string, email: string, isStaff: bool)\ndatatype Game = Game(state: string, player: User)\ndatatype HttpResponse = \n  | Ok(content: string)\n  | Redirect(url: string)\n  | Error(message: string)\ndatatype AuthResult = \n  | Success(user: User)\n  | Failure\nclass ChessSystem {\n  \n  var users: seq<User>\n  var games: seq<Game>\n  \n  \n  constructor()\n  {\n    users := [];\n    games := [];\n  }\n  \n  method authenticate(username: string, password: string) returns (result: AuthResult)\n  {\n    var i := 0;\n    while i < |users|\n    {\n      if users[i].username == username {\n        \n        return Success(users[i]);\n      }\n      i := i + 1;\n    }\n    return Failure;\n  }\n  \n  method register(username: string, email: string, password: string) returns (response: HttpResponse)\n  {\n    \n    var i := 0;\n    while i < |users|\n    {\n      if users[i].username == username {\n        return Error(\"Username already exists\");\n      }\n      i := i + 1;\n    }\n    \n    var newUser := User(|users|, username, email, false);\n    users := users + [newUser];\n    \n    \n    var newGame := Game(\"initial_state\", newUser);\n    games := games + [newGame];\n    \n    return Ok(\"User registered successfully\");\n  }\n  \n  method getGame(user: User) returns (game: Game)\n  {\n    var i := 0;\n    while i < |games|\n    {\n      if games[i].player == user {\n        return games[i];\n      }\n      i := i + 1;\n    }\n    \n    return Game(\"initial_state\", user);\n  }\n}", "output": "datatype User = User(id: int, username: string, email: string, isStaff: bool)\ndatatype Game = Game(state: string, player: User)\ndatatype HttpResponse = \n  | Ok(content: string)\n  | Redirect(url: string)\n  | Error(message: string)\ndatatype AuthResult = \n  | Success(user: User)\n  | Failure\nclass ChessSystem {\n  \n  var users: seq<User>\n  var games: seq<Game>\n  \n  \n  constructor()\n    ensures fresh(this)\n    ensures users == []\n    ensures games == []\n  {\n    users := [];\n    games := [];\n  }\n  \n  method authenticate(username: string, password: string) returns (result: AuthResult)\n    requires username != \"\"\n    requires password != \"\"\n    ensures result.Success? ==> exists u :: u in users && u.username == username\n    ensures result.Failure? ==> forall u :: u in users ==> u.username != username\n  {\n    var i := 0;\n    while i < |users|\n      invariant 0 <= i <= |users|\n      invariant forall k :: 0 <= k < i ==> users[k].username != username\n    {\n      if users[i].username == username {\n        \n        return Success(users[i]);\n      }\n      i := i + 1;\n    }\n    return Failure;\n  }\n  \n  method register(username: string, email: string, password: string) returns (response: HttpResponse)\n    requires username != \"\" && email != \"\" && password != \"\"\n    modifies this`users, this`games\n    ensures response.Ok? ==> exists u :: u in users && u.username == username\n    ensures response.Error? ==> exists u :: u in old(users) && u.username == username\n  {\n    \n    var i := 0;\n    while i < |users|\n      invariant 0 <= i <= |users|\n      invariant forall k :: 0 <= k < i ==> users[k].username != username\n    {\n      if users[i].username == username {\n        return Error(\"Username already exists\");\n      }\n      i := i + 1;\n    }\n    \n    var newUser := User(|users|, username, email, false);\n    users := users + [newUser];\n    \n    \n    var newGame := Game(\"initial_state\", newUser);\n    games := games + [newGame];\n    \n    return Ok(\"User registered successfully\");\n  }\n  \n  method getGame(user: User) returns (game: Game)\n    requires user in users\n    ensures game.player == user\n  {\n    var i := 0;\n    while i < |games|\n      invariant 0 <= i <= |games|\n      invariant forall k :: 0 <= k < i ==> games[k].player != user\n    {\n      if games[i].player == user {\n        return games[i];\n      }\n      i := i + 1;\n    }\n    \n    return Game(\"initial_state\", user);\n  }\n}", "name": "py2dfy_119", "id": 119}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Registry {\n  \n  var items: set<string>\n  \n  ghost predicate Valid()\n  {\n    true \n  }\n  constructor()\n  {\n    items := {};\n  }\n  \n  method Register(item: string)\n  {\n    items := items + {item};\n  }\n  \n  method IsRegistered(item: string) returns (registered: bool)\n  {\n    registered := item in items;\n  }\n}\nmethod Main()\n{\n  var registry := new Registry();\n  registry.Register(\"username\");\n  var isRegistered := registry.IsRegistered(\"username\");\n}", "output": "class Registry {\n  \n  var items: set<string>\n  \n  ghost predicate Valid()\n    reads this\n  {\n    true \n  }\n  constructor()\n    ensures Valid()\n    ensures items == {}\n  {\n    items := {};\n  }\n  \n  method Register(item: string)\n    requires Valid() \n    modifies this\n    ensures Valid()\n    ensures items == old(items) + {item}\n    ensures item in items\n  {\n    items := items + {item};\n  }\n  \n  method IsRegistered(item: string) returns (registered: bool)\n    requires Valid()\n    ensures registered <==> item in items\n  {\n    registered := item in items;\n  }\n}\nmethod Main()\n{\n  var registry := new Registry();\n  registry.Register(\"username\");\n  var isRegistered := registry.IsRegistered(\"username\");\n  assert isRegistered;\n}", "name": "py2dfy_164", "id": 164}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module TalonOne {\n  class IntegrationApi {\n    constructor()\n    {\n      \n    }\n    predicate Valid()\n    {\n      \n      true\n    }\n    \n  }\n  class ManagementApi {\n    constructor()\n    {\n      \n    }\n    predicate Valid()\n    {\n      \n      true\n    }\n    \n  }\n  method CreateApis() returns (integration: IntegrationApi, management: ManagementApi)\n  {\n    integration := new IntegrationApi();\n    management := new ManagementApi();\n  }\n}", "output": "module TalonOne {\n  class IntegrationApi {\n    constructor()\n      ensures Valid()\n    {\n      \n    }\n    predicate Valid()\n      reads this\n    {\n      \n      true\n    }\n    \n  }\n  class ManagementApi {\n    constructor()\n      ensures Valid()\n    {\n      \n    }\n    predicate Valid()\n      reads this\n    {\n      \n      true\n    }\n    \n  }\n  method CreateApis() returns (integration: IntegrationApi, management: ManagementApi)\n    ensures integration.Valid()\n    ensures management.Valid()\n  {\n    integration := new IntegrationApi();\n    management := new ManagementApi();\n  }\n}", "name": "py2dfy_161", "id": 161}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Project {\n  \n  var name: string\n  var description: string\n  var defaultChannels: seq<string>\n  var version: string\n  var defaultEnvironment: string\n  var environments: map<string, string>\n  var commands: seq<string>\n  var icon: string\n  var isDefault: bool\n  var isCondaApp: bool\n  var devTool: bool\n  var isApp: bool\n  \n  constructor (\n    name: string := \"default\", \n    description: string := \"\", \n    defaultChannels: seq<string> := [], \n    version: string := \"0.0.1\",\n    defaultEnvironment: string := \"default\",\n    environments: map<string, string> := map[\"default\" := \"env.yaml\"],\n    commands: seq<string> := [],\n    icon: string := \"\",\n    isDefault: bool := false,\n    isCondaApp: bool := false,\n    devTool: bool := false,\n    isApp: bool := false\n  )\n  {\n    this.name := name;\n    this.description := description;\n    this.defaultChannels := defaultChannels;\n    this.version := version;\n    this.defaultEnvironment := defaultEnvironment;\n    this.environments := environments;\n    this.commands := commands;\n    this.icon := icon;\n    this.isDefault := isDefault;\n    this.isCondaApp := isCondaApp;\n    this.devTool := devTool;\n    this.isApp := isApp;\n  }\n  \n  method ToDict() returns (projectDict: map<string, string>)\n  {\n    projectDict := map[\n      \"name\" := name,\n      \"description\" := description,\n      \"version\" := version,\n      \"default_environment\" := defaultEnvironment,\n      \"icon\" := icon\n    ];\n  }\n  \n  method Save(path: string)\n  {\n    \n    \n  }\n  \n  method EnvPrefix(path: string) returns (prefix: string)\n  {\n    if isDefault {\n      \n      \n      prefix := \"/default/prefix\";\n    } else {\n      prefix := path + \"/project_envs/\" + defaultEnvironment;\n    }\n  }\n}\nmethod TestProject() {\n  var project := new Project(\n    name := \"SampleProject\", \n    description := \"A sample verified project\"\n  );\n  \n  var projectDict := project.ToDict();\n}", "output": "class Project {\n  \n  var name: string\n  var description: string\n  var defaultChannels: seq<string>\n  var version: string\n  var defaultEnvironment: string\n  var environments: map<string, string>\n  var commands: seq<string>\n  var icon: string\n  var isDefault: bool\n  var isCondaApp: bool\n  var devTool: bool\n  var isApp: bool\n  \n  constructor (\n    name: string := \"default\", \n    description: string := \"\", \n    defaultChannels: seq<string> := [], \n    version: string := \"0.0.1\",\n    defaultEnvironment: string := \"default\",\n    environments: map<string, string> := map[\"default\" := \"env.yaml\"],\n    commands: seq<string> := [],\n    icon: string := \"\",\n    isDefault: bool := false,\n    isCondaApp: bool := false,\n    devTool: bool := false,\n    isApp: bool := false\n  )\n  ensures this.name == name\n  ensures this.description == description\n  ensures this.defaultChannels == defaultChannels\n  ensures this.version == version\n  ensures this.defaultEnvironment == defaultEnvironment\n  ensures this.environments == environments\n  ensures this.commands == commands\n  ensures this.icon == icon\n  ensures this.isDefault == isDefault\n  ensures this.isCondaApp == isCondaApp\n  ensures this.devTool == devTool\n  ensures this.isApp == isApp\n  {\n    this.name := name;\n    this.description := description;\n    this.defaultChannels := defaultChannels;\n    this.version := version;\n    this.defaultEnvironment := defaultEnvironment;\n    this.environments := environments;\n    this.commands := commands;\n    this.icon := icon;\n    this.isDefault := isDefault;\n    this.isCondaApp := isCondaApp;\n    this.devTool := devTool;\n    this.isApp := isApp;\n  }\n  \n  method ToDict() returns (projectDict: map<string, string>)\n  ensures \"name\" in projectDict && projectDict[\"name\"] == name\n  ensures \"description\" in projectDict && projectDict[\"description\"] == description\n  ensures \"version\" in projectDict && projectDict[\"version\"] == version\n  ensures \"default_environment\" in projectDict && projectDict[\"default_environment\"] == defaultEnvironment\n  ensures \"icon\" in projectDict && projectDict[\"icon\"] == icon\n  {\n    projectDict := map[\n      \"name\" := name,\n      \"description\" := description,\n      \"version\" := version,\n      \"default_environment\" := defaultEnvironment,\n      \"icon\" := icon\n    ];\n  }\n  \n  method Save(path: string)\n  requires path != \"\"\n  requires |path| > 0\n  modifies this\n  {\n    \n    \n    assert path != \"\";\n  }\n  \n  method EnvPrefix(path: string) returns (prefix: string)\n  requires path != \"\"\n  ensures prefix != \"\"\n  {\n    if isDefault {\n      \n      \n      prefix := \"/default/prefix\";\n    } else {\n      prefix := path + \"/project_envs/\" + defaultEnvironment;\n    }\n  }\n}\nmethod TestProject() {\n  var project := new Project(\n    name := \"SampleProject\", \n    description := \"A sample verified project\"\n  );\n  \n  var projectDict := project.ToDict();\n  assert \"name\" in projectDict;\n  assert projectDict[\"name\"] == \"SampleProject\";\n}", "name": "py2dfy_171", "id": 171}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "predicate sorted (a : seq<int>)\n{\n    forall j, k :: 0 <= j < k < |a| ==> a[j] <= a[k]\n}\npredicate nodups (a : seq<int>)\n{\n    forall i, j :: 0 <= i < |a| ==> 0 <= j < |a| ==> a[i] == a[j] ==> i == j\n}\nmethod removeDups(a : seq<int>) returns (b:seq<int>)\n{\n    var indexb : int;\n    var a' : seq<int>;\n    indexb := 1;\n    a' := [];\n    if( |a| <= 1) \n    {\n        return a;\n    }\n    while (indexb < |a|)\n    {\n        if(a[indexb] != a[indexb - 1])\n        {\n            a' := (a' + [a[indexb - 1]]);\n        }\n        indexb := indexb + 1;\n    }\n    return a';\n}", "output": "predicate sorted (a : seq<int>)\n{\n    forall j, k :: 0 <= j < k < |a| ==> a[j] <= a[k]\n}\npredicate nodups (a : seq<int>)\n{\n    forall i, j :: 0 <= i < |a| ==> 0 <= j < |a| ==> a[i] == a[j] ==> i == j\n}\nmethod removeDups(a : seq<int>) returns (b:seq<int>)\n    requires sorted(a)\n    ensures nodups(b)\n{\n    var indexb : int;\n    var a' : seq<int>;\n    indexb := 1;\n    a' := [];\n    if( |a| <= 1) \n    {\n        return a;\n    }\n    while (indexb < |a|)\n    invariant 0 <= indexb - 1 < |a|\n    invariant(sorted(a[0..(indexb)]))\n    invariant(sorted(a))\n    invariant(|a| > indexb - 1 ==> sorted(a' + [a[indexb - 1]]))\n    invariant(|a'| > 0 ==> a'[|a'| - 1] <= a[indexb - 1])\n    invariant(sorted(a'))\n    invariant(|a| > indexb - 1 ==> nodups(a' + [a[indexb - 1]]))\n    invariant(nodups(a'))\n    {\n        if(a[indexb] != a[indexb - 1])\n        {\n            a' := (a' + [a[indexb - 1]]);\n        }\n        indexb := indexb + 1;\n    }\n    return a';\n}", "name": "py2dfy_175", "id": 175}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PixelsGenerator(w: nat, h: nat) returns (pixels: seq<(nat, nat)>)\n    pixels[i] == (i / w, i % w)\n{\n  var i := 0;\n  pixels := [];\n  while i < w * h\n      pixels[j] == (j / w, j % w)\n  {\n    pixels := pixels + [(i / w, i % w)];\n    i := i + 1;\n  }\n}", "output": "method PixelsGenerator(w: nat, h: nat) returns (pixels: seq<(nat, nat)>)\n  requires w > 0 && h > 0\n  ensures |pixels| == w * h\n  ensures forall i :: 0 <= i < |pixels| ==> \n    pixels[i] == (i / w, i % w)\n{\n  var i := 0;\n  pixels := [];\n  while i < w * h\n    invariant 0 <= i <= w * h\n    invariant |pixels| == i\n    invariant forall j :: 0 <= j < i ==> \n      pixels[j] == (j / w, j % w)\n  {\n    pixels := pixels + [(i / w, i % w)];\n    i := i + 1;\n  }\n}", "name": "py2dfy_193", "id": 193}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method ReadFileContents() returns (contents: seq<int>)\n{\n  \n  \n  var result := new int[1];\n  result[0] := 516;\n  return result[..];\n}\nmethod FinalFrequency() returns (frequency: int)\n{\n  var contents := ReadFileContents();\n  frequency := 0;\n  \n  \n  var i := 0;\n  while i < |contents|\n  {\n    frequency := frequency + contents[i];\n    i := i + 1;\n  }\n}\nfunction sum(s: seq<int>): int\n{\n  if |s| == 0 then 0\n  else s[0] + sum(s[1..])\n}\nmethod Main()\n{\n  var result := FinalFrequency();\n  print result, \"\\n\";\n}", "output": "method ReadFileContents() returns (contents: seq<int>)\n  ensures |contents| == 1  \n  ensures contents[0] == 516\n{\n  \n  \n  var result := new int[1];\n  result[0] := 516;\n  return result[..];\n}\nmethod FinalFrequency() returns (frequency: int)\n  ensures frequency == 516  \n{\n  var contents := ReadFileContents();\n  frequency := 0;\n  \n  \n  var i := 0;\n  while i < |contents|\n    invariant 0 <= i <= |contents|  \n    invariant frequency == sum(contents[..i])  \n    decreases |contents| - i\n  {\n    frequency := frequency + contents[i];\n    i := i + 1;\n  }\n}\nfunction sum(s: seq<int>): int\n  decreases |s|\n{\n  if |s| == 0 then 0\n  else s[0] + sum(s[1..])\n}\nmethod Main()\n{\n  var result := FinalFrequency();\n  print result, \"\\n\";\n}", "name": "py2dfy_186", "id": 186}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class CodeEntry {\n  var code: string\n  var expired: int\n}\nclass CodeGenerator {\n  var codes: seq<CodeEntry>\n  constructor() \n  {\n    codes := [];\n  }\n  method BuildBlock(size: int) returns (code: string)\n  {\n    var letters := \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    code := \"\";\n    var i := 0;\n    while i < size\n    {\n      var idx :| 0 <= idx < |letters|;\n      code := code + [letters[idx]];\n      i := i + 1;\n    }\n  }\n  method CodeAdd() returns (generatedCode: string)\n  {\n    generatedCode := BuildBlock(8);\n    var existsCode := false;\n    var i := 0;\n    while i < |codes|\n    {\n      if codes[i].code == generatedCode {\n        existsCode := true;\n        break;\n      }\n      i := i + 1;\n    }\n    \n    if existsCode {\n      generatedCode := BuildBlock(8);\n    }\n    \n    var newEntry := new CodeEntry;\n    newEntry.code := generatedCode;\n    newEntry.expired := 3;\n    codes := codes + [newEntry];\n  }\n  method CodeUse(oneCode: string) returns (success: bool)\n  {\n    var i := 0;\n    success := false;\n    var newCodes: seq<CodeEntry> := [];\n    \n    while i < |codes|\n    {\n      if codes[i].code != oneCode {\n        newCodes := newCodes + [codes[i]];\n      } else {\n        success := true;\n      }\n      i := i + 1;\n    }\n    \n    codes := newCodes;\n  }\n  method CodeWatcher()\n  {\n    var now := 0;\n    var newCodes: seq<CodeEntry> := [];\n    var i := 0;\n    \n    while i < |codes|\n    {\n      if codes[i].expired > now {\n        newCodes := newCodes + [codes[i]];\n      }\n      i := i + 1;\n    }\n    \n    codes := newCodes;\n  }\n}", "output": "class CodeEntry {\n  var code: string\n  var expired: int\n}\nclass CodeGenerator {\n  var codes: seq<CodeEntry>\n  constructor() \n    ensures |codes| == 0\n  {\n    codes := [];\n  }\n  method BuildBlock(size: int) returns (code: string)\n    requires size > 0\n    ensures |code| == size\n  {\n    var letters := \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    code := \"\";\n    var i := 0;\n    while i < size\n      invariant 0 <= i <= size\n      invariant |code| == i\n    {\n      var idx :| 0 <= idx < |letters|;\n      code := code + [letters[idx]];\n      i := i + 1;\n    }\n  }\n  method CodeAdd() returns (generatedCode: string)\n    modifies this\n    ensures |codes| == |old(codes)| + 1\n    ensures generatedCode == codes[|codes|-1].code\n  {\n    generatedCode := BuildBlock(8);\n    var existsCode := false;\n    var i := 0;\n    while i < |codes|\n      invariant 0 <= i <= |codes|\n    {\n      if codes[i].code == generatedCode {\n        existsCode := true;\n        break;\n      }\n      i := i + 1;\n    }\n    \n    if existsCode {\n      generatedCode := BuildBlock(8);\n    }\n    \n    var newEntry := new CodeEntry;\n    newEntry.code := generatedCode;\n    newEntry.expired := 3;\n    codes := codes + [newEntry];\n  }\n  method CodeUse(oneCode: string) returns (success: bool)\n    modifies this\n    ensures |codes| <= |old(codes)|\n    ensures forall i :: 0 <= i < |codes| ==> codes[i] in old(codes)\n  {\n    var i := 0;\n    success := false;\n    var newCodes: seq<CodeEntry> := [];\n    \n    while i < |codes|\n      invariant 0 <= i <= |codes|\n      invariant |newCodes| <= i\n      invariant forall j :: 0 <= j < |newCodes| ==> newCodes[j] in codes[..i]\n    {\n      if codes[i].code != oneCode {\n        newCodes := newCodes + [codes[i]];\n      } else {\n        success := true;\n      }\n      i := i + 1;\n    }\n    \n    codes := newCodes;\n  }\n  method CodeWatcher()\n    modifies this\n    ensures |codes| <= |old(codes)|\n    ensures forall i :: 0 <= i < |codes| ==> codes[i] in old(codes)\n  {\n    var now := 0;\n    var newCodes: seq<CodeEntry> := [];\n    var i := 0;\n    \n    while i < |codes|\n      invariant 0 <= i <= |codes|\n      invariant |newCodes| <= i\n      invariant forall j :: 0 <= j < |newCodes| ==> newCodes[j] in codes[..i]\n    {\n      if codes[i].expired > now {\n        newCodes := newCodes + [codes[i]];\n      }\n      i := i + 1;\n    }\n    \n    codes := newCodes;\n  }\n}", "name": "py2dfy_177", "id": 177}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Color = Silver | Black | Green | Orange | White | Grey | Red | Blue | Purple | Yellow | Gold | Brown | Coffee\ndatatype Direction = \n  | FrontRightAngle45 \n  | FrontLeftAngle45 \n  | RearRightAngle45 \n  | RearLeftAngle45 \n  | SideRight \n  | SideLeft \n  | FrontDirect \n  | RearDirect\ndatatype Result<T,E> = Success(value: T) | Failure(error: E)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  \n  predicate IsSuccess() {\n    this.Success?\n  }\n}\nmethod StrToInt(s: string) returns (result: Result<int, string>)\n{\n  if ValidIntString(s) {\n    return Success(ParseInt(s));\n  }\n  return Failure(\"ValueError\");\n}\nmethod CheckDirection(propertyName: string) returns (direction: int)\n{\n  var directionList := [\n    \"侧前45度车头向右水平\", \"侧前45度车头向左水平\", \n    \"侧后45度车头向右水平\", \"侧后45度车头向左水平\",\n    \"正侧车头向右水平\", \"正侧车头向左水平\",\n    \"正前水平\", \"正后水平\"\n  ];\n  var i := 0;\n  while i < |directionList|\n  {\n    if directionList[i] == propertyName {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\nmethod CheckColor(photoName: string) returns (colorIndex: int)\n{\n  var colorList := [\n    \"银\", \"黑\", \"绿\", \"橙\", \"白\", \"灰\", \"红\", \n    \"蓝\", \"紫\", \"黄\", \"金\", \"棕\", \"咖啡\"\n  ];\n  \n  var words := SplitString(photoName);\n  \n  var i := 0;\n  while i < |words|\n      !StartsWithExternal(words[j]) || \n      !ContainsAnyColor(words[j], colorList)\n  {\n    if StartsWithExternal(words[i]) {\n      var j := 0;\n      while j < |colorList|\n          !Contains(words[i], colorList[k])\n      {\n        if Contains(words[i], colorList[j]) {\n          return j;\n        }\n        j := j + 1;\n      }\n    }\n    i := i + 1;\n  }\n  return -1;\n}\npredicate ValidIntString(s: string)\n{\n  \n  \n  true\n}\npredicate StartsWithExternal(s: string)\n{\n  \n  \n  true\n}\npredicate ContainsAnyColor(s: string, colors: seq<string>)\n{\n  exists i :: 0 <= i < |colors| && Contains(s, colors[i])\n}\npredicate Contains(s: string, substr: string)\n{\n  \n  \n  true\n}\nfunction SplitString(s: string): seq<string>\n{\n  \n  \n  []\n}\nfunction ParseInt(s: string): int\n{\n  \n  \n  0\n}\npredicate ValidDirectionIndex(i: int)\n{\n  0 <= i < 8\n}", "output": "datatype Color = Silver | Black | Green | Orange | White | Grey | Red | Blue | Purple | Yellow | Gold | Brown | Coffee\ndatatype Direction = \n  | FrontRightAngle45 \n  | FrontLeftAngle45 \n  | RearRightAngle45 \n  | RearLeftAngle45 \n  | SideRight \n  | SideLeft \n  | FrontDirect \n  | RearDirect\ndatatype Result<T,E> = Success(value: T) | Failure(error: E)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  \n  predicate IsSuccess() {\n    this.Success?\n  }\n}\nmethod StrToInt(s: string) returns (result: Result<int, string>)\n  ensures result.IsFailure() ==> result.error == \"ValueError\"\n  ensures result.IsSuccess() ==> ValidIntString(s)\n{\n  if ValidIntString(s) {\n    return Success(ParseInt(s));\n  }\n  return Failure(\"ValueError\");\n}\nmethod CheckDirection(propertyName: string) returns (direction: int)\n  ensures -1 <= direction < 8  \n  ensures direction != -1 ==> ValidDirectionIndex(direction)\n{\n  var directionList := [\n    \"侧前45度车头向右水平\", \"侧前45度车头向左水平\", \n    \"侧后45度车头向右水平\", \"侧后45度车头向左水平\",\n    \"正侧车头向右水平\", \"正侧车头向左水平\",\n    \"正前水平\", \"正后水平\"\n  ];\n  var i := 0;\n  while i < |directionList|\n    invariant 0 <= i <= |directionList|\n    invariant forall j :: 0 <= j < i ==> directionList[j] != propertyName\n  {\n    if directionList[i] == propertyName {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\nmethod CheckColor(photoName: string) returns (colorIndex: int)\n  ensures -1 <= colorIndex < 13  \n{\n  var colorList := [\n    \"银\", \"黑\", \"绿\", \"橙\", \"白\", \"灰\", \"红\", \n    \"蓝\", \"紫\", \"黄\", \"金\", \"棕\", \"咖啡\"\n  ];\n  \n  var words := SplitString(photoName);\n  \n  var i := 0;\n  while i < |words|\n    invariant 0 <= i <= |words|\n    invariant forall j :: 0 <= j < i ==> \n      !StartsWithExternal(words[j]) || \n      !ContainsAnyColor(words[j], colorList)\n  {\n    if StartsWithExternal(words[i]) {\n      var j := 0;\n      while j < |colorList|\n        invariant 0 <= j <= |colorList|\n        invariant forall k :: 0 <= k < j ==> \n          !Contains(words[i], colorList[k])\n      {\n        if Contains(words[i], colorList[j]) {\n          return j;\n        }\n        j := j + 1;\n      }\n    }\n    i := i + 1;\n  }\n  return -1;\n}\npredicate ValidIntString(s: string)\n{\n  \n  \n  true\n}\npredicate StartsWithExternal(s: string)\n{\n  \n  \n  true\n}\npredicate ContainsAnyColor(s: string, colors: seq<string>)\n{\n  exists i :: 0 <= i < |colors| && Contains(s, colors[i])\n}\npredicate Contains(s: string, substr: string)\n{\n  \n  \n  true\n}\nfunction SplitString(s: string): seq<string>\n{\n  \n  \n  []\n}\nfunction ParseInt(s: string): int\n  requires ValidIntString(s)\n{\n  \n  \n  0\n}\npredicate ValidDirectionIndex(i: int)\n{\n  0 <= i < 8\n}", "name": "py2dfy_134", "id": 134}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Question = Question(text: string)\ndatatype Game = Game(questions: seq<Question>)\nclass WordCategories {\n  const colorWords: set<string>\n  const peopleWords: set<string>\n  const prepWords: set<string>\n  const numberWords: set<string>\n  const spatialWords: set<string>\n  const verbWords: set<string>\n  const objWords: set<string>\n  const miscWords: set<string>\n  constructor()\n  {\n    colorWords := {\"green\", \"blue\", \"brown\", \"red\", \"white\", \"black\", \"yellow\", \"color\", \"orange\", \"pink\"};\n    peopleWords := {\"people\", \"person\", \"he\", \"she\", \"human\", \"man\", \"woman\", \"guy\", \"alive\", \"girl\", \"boy\", \"head\", \"animal\"};\n    prepWords := {\"on\", \"in\", \"of\", \"to\", \"with\", \"by\", \"at\", \"or\", \"and\", \"from\"};\n    numberWords := {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"first\", \"second\", \"third\", \"half\"};\n    spatialWords := {\"top\", \"left\", \"right\", \"side\", \"next\", \"front\", \"middle\", \"foreground\", \"bottom\", \"background\"};\n    verbWords := {\"wearing\", \"have\", \"can\", \"holding\", \"sitting\", \"building\", \"standing\", \"see\"};\n    objWords := {\"hand\", \"table\", \"car\", \"food\", \"plate\", \"shirt\"};\n    miscWords := {\"visible\", \"made\", \"part\", \"piece\", \"all\"};\n  }\n}\ndatatype WordCounts = WordCounts(\n  colors: nat,\n  people: nat,\n  preps: nat,\n  numbers: nat,\n  spatials: nat,\n  verbs: nat,\n  objects: nat,\n  misc: nat\n)\nmethod ToLower(s: string) returns (result: string)\n{\n  \n  \n  var lowercaseOnly := \"\";\n  var i := 0;\n  while i < |s|\n  {\n    var c := s[i];\n    if 'a' <= c <= 'z' {\n      lowercaseOnly := lowercaseOnly + [c];\n    } else if 'A' <= c <= 'Z' {\n      \n      var lowercase := (c - 'A' + 'a') as char;\n      lowercaseOnly := lowercaseOnly + [lowercase];\n    }\n    i := i + 1;\n  }\n  result := lowercaseOnly;\n}\nmethod SplitIntoWords(text: string) returns (words: seq<string>)\n{\n  if |text| == 0 {\n    words := [];\n  } else {\n    \n    words := [text];\n    \n    \n    \n    \n  }\n}\nmethod CountWordTypes(games: seq<Game>, categories: WordCategories) returns (counts: WordCounts)\n{\n  var colorCount := 0;\n  var peopleCount := 0;\n  var prepCount := 0;\n  var numberCount := 0;\n  var spatialCount := 0;\n  var verbCount := 0;\n  var objCount := 0;\n  var miscCount := 0;\n  \n  var i := 0;\n  while i < |games|\n  {\n    var game := games[i];\n    var j := 0;\n    \n    \n    while j < |game.questions|\n    {\n      var question := game.questions[j];\n      var words := SplitIntoWords(question.text);\n      \n      var k := 0;\n      while k < |words|\n      {\n        var word := ToLower(words[k]);\n        \n        if word in categories.colorWords { colorCount := colorCount + 1; }\n        if word in categories.peopleWords { peopleCount := peopleCount + 1; }\n        if word in categories.prepWords { prepCount := prepCount + 1; }\n        if word in categories.numberWords { numberCount := numberCount + 1; }\n        if word in categories.spatialWords { spatialCount := spatialCount + 1; }\n        if word in categories.verbWords { verbCount := verbCount + 1; }\n        if word in categories.objWords { objCount := objCount + 1; }\n        if word in categories.miscWords { miscCount := miscCount + 1; }\n        \n        k := k + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  counts := WordCounts(colorCount, peopleCount, prepCount, numberCount, \n                      spatialCount, verbCount, objCount, miscCount);\n}", "output": "datatype Question = Question(text: string)\ndatatype Game = Game(questions: seq<Question>)\nclass WordCategories {\n  const colorWords: set<string>\n  const peopleWords: set<string>\n  const prepWords: set<string>\n  const numberWords: set<string>\n  const spatialWords: set<string>\n  const verbWords: set<string>\n  const objWords: set<string>\n  const miscWords: set<string>\n  constructor()\n    ensures colorWords != {}  \n    ensures peopleWords != {}\n    ensures prepWords != {}\n    ensures numberWords != {}\n    ensures spatialWords != {}\n    ensures verbWords != {}\n    ensures objWords != {}\n    ensures miscWords != {}\n  {\n    colorWords := {\"green\", \"blue\", \"brown\", \"red\", \"white\", \"black\", \"yellow\", \"color\", \"orange\", \"pink\"};\n    peopleWords := {\"people\", \"person\", \"he\", \"she\", \"human\", \"man\", \"woman\", \"guy\", \"alive\", \"girl\", \"boy\", \"head\", \"animal\"};\n    prepWords := {\"on\", \"in\", \"of\", \"to\", \"with\", \"by\", \"at\", \"or\", \"and\", \"from\"};\n    numberWords := {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"first\", \"second\", \"third\", \"half\"};\n    spatialWords := {\"top\", \"left\", \"right\", \"side\", \"next\", \"front\", \"middle\", \"foreground\", \"bottom\", \"background\"};\n    verbWords := {\"wearing\", \"have\", \"can\", \"holding\", \"sitting\", \"building\", \"standing\", \"see\"};\n    objWords := {\"hand\", \"table\", \"car\", \"food\", \"plate\", \"shirt\"};\n    miscWords := {\"visible\", \"made\", \"part\", \"piece\", \"all\"};\n  }\n}\ndatatype WordCounts = WordCounts(\n  colors: nat,\n  people: nat,\n  preps: nat,\n  numbers: nat,\n  spatials: nat,\n  verbs: nat,\n  objects: nat,\n  misc: nat\n)\nmethod ToLower(s: string) returns (result: string)\n  ensures forall c :: c in result ==> 'a' <= c <= 'z'\n{\n  \n  \n  var lowercaseOnly := \"\";\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall c :: c in lowercaseOnly ==> 'a' <= c <= 'z'\n  {\n    var c := s[i];\n    if 'a' <= c <= 'z' {\n      lowercaseOnly := lowercaseOnly + [c];\n    } else if 'A' <= c <= 'Z' {\n      \n      var lowercase := (c - 'A' + 'a') as char;\n      lowercaseOnly := lowercaseOnly + [lowercase];\n    }\n    i := i + 1;\n  }\n  result := lowercaseOnly;\n}\nmethod SplitIntoWords(text: string) returns (words: seq<string>)\n  ensures |words| > 0 ==> forall w :: w in words ==> |w| > 0\n{\n  if |text| == 0 {\n    words := [];\n  } else {\n    \n    words := [text];\n    \n    \n    \n    \n  }\n}\nmethod CountWordTypes(games: seq<Game>, categories: WordCategories) returns (counts: WordCounts)\n  requires |games| > 0\n  requires forall g :: g in games ==> |g.questions| > 0\n  ensures counts.colors >= 0\n  ensures counts.people >= 0\n  ensures counts.preps >= 0\n  ensures counts.numbers >= 0\n  ensures counts.spatials >= 0\n  ensures counts.verbs >= 0\n  ensures counts.objects >= 0\n  ensures counts.misc >= 0\n{\n  var colorCount := 0;\n  var peopleCount := 0;\n  var prepCount := 0;\n  var numberCount := 0;\n  var spatialCount := 0;\n  var verbCount := 0;\n  var objCount := 0;\n  var miscCount := 0;\n  \n  var i := 0;\n  while i < |games|\n    invariant 0 <= i <= |games|\n    invariant colorCount >= 0\n    invariant peopleCount >= 0\n    invariant prepCount >= 0\n    invariant numberCount >= 0\n    invariant spatialCount >= 0\n    invariant verbCount >= 0\n    invariant objCount >= 0\n    invariant miscCount >= 0\n  {\n    var game := games[i];\n    var j := 0;\n    \n    \n    while j < |game.questions|\n      invariant 0 <= j <= |game.questions|\n      invariant colorCount >= 0\n      invariant peopleCount >= 0\n      invariant prepCount >= 0\n      invariant numberCount >= 0\n      invariant spatialCount >= 0\n      invariant verbCount >= 0\n      invariant objCount >= 0\n      invariant miscCount >= 0\n    {\n      var question := game.questions[j];\n      var words := SplitIntoWords(question.text);\n      \n      var k := 0;\n      while k < |words|\n        invariant 0 <= k <= |words|\n        invariant colorCount >= 0\n        invariant peopleCount >= 0\n        invariant prepCount >= 0\n        invariant numberCount >= 0\n        invariant spatialCount >= 0\n        invariant verbCount >= 0\n        invariant objCount >= 0\n        invariant miscCount >= 0\n      {\n        var word := ToLower(words[k]);\n        \n        if word in categories.colorWords { colorCount := colorCount + 1; }\n        if word in categories.peopleWords { peopleCount := peopleCount + 1; }\n        if word in categories.prepWords { prepCount := prepCount + 1; }\n        if word in categories.numberWords { numberCount := numberCount + 1; }\n        if word in categories.spatialWords { spatialCount := spatialCount + 1; }\n        if word in categories.verbWords { verbCount := verbCount + 1; }\n        if word in categories.objWords { objCount := objCount + 1; }\n        if word in categories.miscWords { miscCount := miscCount + 1; }\n        \n        k := k + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  counts := WordCounts(colorCount, peopleCount, prepCount, numberCount, \n                      spatialCount, verbCount, objCount, miscCount);\n}", "name": "py2dfy_163", "id": 163}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module DatabaseUtils {\n  function IsDigit(c: char): bool {\n    '0' <= c <= '9'\n  }\n  method TruncateName(name: string, length: nat, hash_length: nat := 4) returns (result: string)\n  {\n    if |name| <= length {\n      return name;\n    }\n    \n    var hash := ComputeHash(name, hash_length);\n    var prefix_length := length - hash_length;\n    result := name[..prefix_length] + hash;\n  }\n  method SplitIdentifier(identifier: string) returns (namespace: string, name: string)\n  {\n    if |identifier| >= 2 && identifier[0] == '\"' && identifier[|identifier|-1] == '\"' {\n      \n      if |identifier| == 2 {\n        namespace, name := \"default\", identifier;\n      } else {\n        var ns, n := SplitIdentifier(identifier[1..|identifier|-1]);\n        return ns, n;\n      }\n    }\n    var parts := SplitString(identifier, '.');\n    if |parts| == 2 {\n      namespace, name := parts[0], parts[1];\n      \n      }\n    } else {\n      namespace, name := \"default\", identifier;\n    }\n  }\n  datatype Option<T> = None | Some(v: T)\n  method FormatNumber(value: real, max_digits: Option<nat>, places: Option<nat>) returns (result: string)\n  {\n    var formatted := \"0.00\";\n    return formatted;\n  }\n  method SplitTZNameDelta(tzname: string) returns (name: string, sign: Option<string>, delta: Option<string>)\n  {\n    var offset_idx := -1;\n    var i := 0;\n    while i < |tzname|\n          (k < |tzname| ==> tzname[k] != '+' && tzname[k] != '-') || \n          (k < |tzname| - 5 ==> !IsValidOffset(tzname[k+1..]))\n    {\n      if i < |tzname| - 5 && (tzname[i] == '+' || tzname[i] == '-') && IsValidOffset(tzname[i+1..]) {\n        offset_idx := i;\n        break;\n      }\n      i := i + 1;\n    }\n    if offset_idx == -1 {\n      return tzname, None, None;\n    }\n    name := tzname[..offset_idx];\n    if |name| == 0 { name := \"UTC\"; }\n    sign := Some([tzname[offset_idx]]);\n    delta := Some(tzname[offset_idx + 1..offset_idx + 6]);\n    \n    return name, sign, delta;\n  }\n  predicate IsValidOffset(s: string)\n  {\n    |s| >= 5 &&\n    IsDigit(s[0]) && IsDigit(s[1]) && s[2] == ':' && \n    IsDigit(s[3]) && IsDigit(s[4])\n  }\n  method ComputeHash(s: string, length: nat) returns (hash: string)\n  {\n    hash := \"a38a\"[..length];\n  }\n  method SplitString(s: string, delimiter: char) returns (parts: seq<string>)\n  {\n    var idx := 0;\n    while idx < |s| && s[idx] != delimiter \n    {\n      idx := idx + 1;\n    }\n    if idx < |s| {\n      var first := s[..idx];\n      var second := s[idx+1..];\n      if |first| == 0 { first := \"default\"; }\n      if |second| == 0 { second := \"default\"; }\n      return [first, second];\n    }\n    return [s];\n  }\n}", "output": "module DatabaseUtils {\n  function IsDigit(c: char): bool {\n    '0' <= c <= '9'\n  }\n  method TruncateName(name: string, length: nat, hash_length: nat := 4) returns (result: string)\n    requires length > hash_length \n    requires hash_length > 0\n    requires hash_length <= 4\n    requires |name| > 0\n    ensures |result| <= length\n    ensures result != \"\"\n  {\n    if |name| <= length {\n      return name;\n    }\n    \n    var hash := ComputeHash(name, hash_length);\n    var prefix_length := length - hash_length;\n    result := name[..prefix_length] + hash;\n  }\n  method SplitIdentifier(identifier: string) returns (namespace: string, name: string)\n    requires |identifier| > 0\n    ensures namespace != \"\"\n    ensures name != \"\"\n  {\n    if |identifier| >= 2 && identifier[0] == '\"' && identifier[|identifier|-1] == '\"' {\n      \n      if |identifier| == 2 {\n        namespace, name := \"default\", identifier;\n      } else {\n        assert |identifier[1..|identifier|-1]| > 0;\n        var ns, n := SplitIdentifier(identifier[1..|identifier|-1]);\n        return ns, n;\n      }\n    }\n    var parts := SplitString(identifier, '.');\n    if |parts| == 2 {\n      namespace, name := parts[0], parts[1];\n      \n      assert namespace != \"\" && name != \"\" by {\n        assert forall p :: p in parts ==> p != \"\";\n        assert parts[0] in parts && parts[1] in parts;\n      }\n    } else {\n      namespace, name := \"default\", identifier;\n    }\n  }\n  datatype Option<T> = None | Some(v: T)\n  method FormatNumber(value: real, max_digits: Option<nat>, places: Option<nat>) returns (result: string)\n    requires places.Some? ==> places.v >= 0\n    requires max_digits.Some? ==> max_digits.v > 0\n    ensures result != \"\"\n  {\n    var formatted := \"0.00\";\n    return formatted;\n  }\n  method SplitTZNameDelta(tzname: string) returns (name: string, sign: Option<string>, delta: Option<string>)\n    requires |tzname| > 0\n    ensures name != \"\"\n    ensures sign.Some? ==> (sign.v == \"+\" || sign.v == \"-\")\n    ensures delta.None? ==> sign.None?\n    ensures delta.Some? ==> |delta.v| == 5\n  {\n    var offset_idx := -1;\n    var i := 0;\n    while i < |tzname|\n      invariant 0 <= i <= |tzname|\n      invariant offset_idx == -1 ==> forall k :: 0 <= k < i ==> \n          (k < |tzname| ==> tzname[k] != '+' && tzname[k] != '-') || \n          (k < |tzname| - 5 ==> !IsValidOffset(tzname[k+1..]))\n      decreases |tzname| - i\n    {\n      if i < |tzname| - 5 && (tzname[i] == '+' || tzname[i] == '-') && IsValidOffset(tzname[i+1..]) {\n        offset_idx := i;\n        break;\n      }\n      i := i + 1;\n    }\n    if offset_idx == -1 {\n      return tzname, None, None;\n    }\n    name := tzname[..offset_idx];\n    if |name| == 0 { name := \"UTC\"; }\n    sign := Some([tzname[offset_idx]]);\n    delta := Some(tzname[offset_idx + 1..offset_idx + 6]);\n    \n    return name, sign, delta;\n  }\n  predicate IsValidOffset(s: string)\n    requires |s| >= 5\n  {\n    |s| >= 5 &&\n    IsDigit(s[0]) && IsDigit(s[1]) && s[2] == ':' && \n    IsDigit(s[3]) && IsDigit(s[4])\n  }\n  method ComputeHash(s: string, length: nat) returns (hash: string)\n    requires length > 0\n    requires length <= 4\n    ensures |hash| == length\n  {\n    hash := \"a38a\"[..length];\n  }\n  method SplitString(s: string, delimiter: char) returns (parts: seq<string>)\n    requires |s| > 0\n    ensures |parts| >= 1\n    ensures forall p :: p in parts ==> p != \"\"\n  {\n    var idx := 0;\n    while idx < |s| && s[idx] != delimiter \n      invariant 0 <= idx <= |s|\n    {\n      idx := idx + 1;\n    }\n    if idx < |s| {\n      var first := s[..idx];\n      var second := s[idx+1..];\n      if |first| == 0 { first := \"default\"; }\n      if |second| == 0 { second := \"default\"; }\n      return [first, second];\n    }\n    return [s];\n  }\n}", "name": "py2dfy_183", "id": 183}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Star {\n  var x: int\n  var y: int\n  var color: string\n  constructor(x': int, y': int, color': string := \"yellow\")\n  {\n    x := x';\n    y := y';\n    color := color';\n  }\n}\nclass Level {\n  var stars: seq<Star>\n  constructor()\n  {\n    var starParams := [\n      (450, 440, \"yellow\"), (450, 360, \"yellow\"), (370, 360, \"yellow\"), \n      (530, 360, \"yellow\"), (370, 280, \"yellow\"), (530, 280, \"yellow\"),\n      (290, 280, \"yellow\"), (610, 280, \"yellow\"), (290, 200, \"yellow\"),\n      (610, 200, \"yellow\"), (370, 200, \"red\"), (530, 200, \"red\"),\n      (450, 280, \"red\"), (370, 440, \"red\"), (530, 440, \"red\"),\n      (610, 360, \"red\"), (290, 360, \"red\"), (690, 280, \"red\"),\n      (210, 280, \"red\")\n    ];\n    stars := [];\n    \n    new;\n    var i := 0;\n    var starsArray := [];\n    while i < |starParams|\n    {\n      var (x, y, color) := starParams[i];\n      var star := new Star(x, y, color);\n      starsArray := starsArray + [star];\n      i := i + 1;\n    }\n    \n    stars := starsArray;\n  }\n  method GetStars() returns (result: seq<Star>)\n  {\n    return stars;\n  }\n}", "output": "class Star {\n  var x: int\n  var y: int\n  var color: string\n  constructor(x': int, y': int, color': string := \"yellow\")\n    ensures this.x == x'\n    ensures this.y == y'\n    ensures this.color == color'\n  {\n    x := x';\n    y := y';\n    color := color';\n  }\n}\nclass Level {\n  var stars: seq<Star>\n  constructor()\n    ensures fresh(stars)\n    ensures |stars| == 19\n    ensures forall i :: 0 <= i < |stars| ==> fresh(stars[i])\n  {\n    var starParams := [\n      (450, 440, \"yellow\"), (450, 360, \"yellow\"), (370, 360, \"yellow\"), \n      (530, 360, \"yellow\"), (370, 280, \"yellow\"), (530, 280, \"yellow\"),\n      (290, 280, \"yellow\"), (610, 280, \"yellow\"), (290, 200, \"yellow\"),\n      (610, 200, \"yellow\"), (370, 200, \"red\"), (530, 200, \"red\"),\n      (450, 280, \"red\"), (370, 440, \"red\"), (530, 440, \"red\"),\n      (610, 360, \"red\"), (290, 360, \"red\"), (690, 280, \"red\"),\n      (210, 280, \"red\")\n    ];\n    stars := [];\n    \n    new;\n    var i := 0;\n    var starsArray := [];\n    while i < |starParams|\n      invariant 0 <= i <= |starParams|\n      invariant |starsArray| == i\n      invariant forall j :: 0 <= j < i ==> fresh(starsArray[j])\n    {\n      var (x, y, color) := starParams[i];\n      var star := new Star(x, y, color);\n      starsArray := starsArray + [star];\n      i := i + 1;\n    }\n    \n    stars := starsArray;\n  }\n  method GetStars() returns (result: seq<Star>)\n    ensures result == stars\n  {\n    return stars;\n  }\n}", "name": "py2dfy_174", "id": 174}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Polygon {\n  var vertices: array<Point?> \n  var numVertices: int\n  constructor(size: nat)\n  {\n    vertices := new Point?[size];\n    numVertices := 0;\n    new;\n    forall i | 0 <= i < vertices.Length {\n      vertices[i] := null;\n    }\n  }\n  \n  method GetCenter() returns (center: Point?)\n  {\n    var sumX := 0;\n    var sumY := 0;\n    \n    var i := 0;\n    while i < numVertices \n    {\n      sumX := sumX + vertices[i].x;\n      sumY := sumY + vertices[i].y;\n      i := i + 1;\n    }\n    center := new Point(sumX / numVertices, sumY / numVertices);\n  }\n  \n  method SquaredDistance(p1: Point?, p2: Point?) returns (dist: int)\n  {\n    var dx := p1.x - p2.x;\n    var dy := p1.y - p2.y;\n    dist := dx * dx + dy * dy;\n  }\n  \n  method IsRegular(tolerance: real) returns (regular: bool)\n  {\n    var edges: array<int> := new int[numVertices];\n    var i := 0;\n    \n    while i < numVertices\n    {\n      var next := if i == numVertices - 1 then 0 else i + 1;\n      var dist := SquaredDistance(vertices[i], vertices[next]);\n      edges[i] := dist;\n      i := i + 1;\n    }\n    var minEdge := edges[0];\n    var maxEdge := edges[0];\n    i := 1;\n    \n    while i < numVertices\n    {\n      if edges[i] < minEdge { minEdge := edges[i]; }\n      if edges[i] > maxEdge { maxEdge := edges[i]; }\n      i := i + 1;\n    }\n    regular := minEdge > 0 && (maxEdge as real) / (minEdge as real) <= tolerance;\n  }\n}\nmethod TranslatePolygon(poly: Polygon?, dx: int, dy: int) returns (newPoly: Polygon?)\n{\n  newPoly := new Polygon(poly.numVertices);\n  newPoly.numVertices := poly.numVertices;\n  var i := 0;\n  while i < poly.numVertices\n  {\n    newPoly.vertices[i] := new Point(poly.vertices[i].x + dx, poly.vertices[i].y + dy);\n    i := i + 1;\n  }\n}", "output": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n    ensures x == x' && y == y'\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Polygon {\n  var vertices: array<Point?> \n  var numVertices: int\n  constructor(size: nat)\n    requires size > 0\n    ensures fresh(vertices)\n    ensures vertices.Length == size\n    ensures numVertices == 0\n    ensures forall i :: 0 <= i < vertices.Length ==> vertices[i] == null\n  {\n    vertices := new Point?[size];\n    numVertices := 0;\n    new;\n    forall i | 0 <= i < vertices.Length {\n      vertices[i] := null;\n    }\n  }\n  \n  method GetCenter() returns (center: Point?)\n    requires numVertices > 0\n    requires forall i :: 0 <= i < vertices.Length ==> vertices[i] != null\n    requires numVertices <= vertices.Length\n    ensures center != null\n  {\n    var sumX := 0;\n    var sumY := 0;\n    \n    var i := 0;\n    while i < numVertices \n      invariant 0 <= i <= numVertices\n      invariant forall k :: 0 <= k < i ==> vertices[k] != null\n      invariant i <= vertices.Length\n    {\n      sumX := sumX + vertices[i].x;\n      sumY := sumY + vertices[i].y;\n      i := i + 1;\n    }\n    center := new Point(sumX / numVertices, sumY / numVertices);\n  }\n  \n  method SquaredDistance(p1: Point?, p2: Point?) returns (dist: int)\n    requires p1 != null && p2 != null\n    ensures dist >= 0\n  {\n    var dx := p1.x - p2.x;\n    var dy := p1.y - p2.y;\n    dist := dx * dx + dy * dy;\n  }\n  \n  method IsRegular(tolerance: real) returns (regular: bool)\n    requires numVertices >= 3\n    requires numVertices <= vertices.Length\n    requires forall i :: 0 <= i < vertices.Length ==> vertices[i] != null\n    requires tolerance > 1.0\n    ensures regular ==> tolerance > 1.0\n  {\n    var edges: array<int> := new int[numVertices];\n    var i := 0;\n    \n    while i < numVertices\n      invariant 0 <= i <= numVertices\n      invariant edges.Length == numVertices\n    {\n      var next := if i == numVertices - 1 then 0 else i + 1;\n      var dist := SquaredDistance(vertices[i], vertices[next]);\n      edges[i] := dist;\n      i := i + 1;\n    }\n    var minEdge := edges[0];\n    var maxEdge := edges[0];\n    i := 1;\n    \n    while i < numVertices\n      invariant 1 <= i <= numVertices\n      invariant minEdge <= maxEdge\n    {\n      if edges[i] < minEdge { minEdge := edges[i]; }\n      if edges[i] > maxEdge { maxEdge := edges[i]; }\n      i := i + 1;\n    }\n    regular := minEdge > 0 && (maxEdge as real) / (minEdge as real) <= tolerance;\n  }\n}\nmethod TranslatePolygon(poly: Polygon?, dx: int, dy: int) returns (newPoly: Polygon?)\n  requires poly != null\n  requires poly.numVertices > 0\n  requires poly.numVertices <= poly.vertices.Length\n  requires forall i :: 0 <= i < poly.vertices.Length ==> poly.vertices[i] != null\n  ensures newPoly != null\n  ensures newPoly.numVertices == poly.numVertices\n  ensures fresh(newPoly)\n  ensures fresh(newPoly.vertices)\n{\n  newPoly := new Polygon(poly.numVertices);\n  newPoly.numVertices := poly.numVertices;\n  var i := 0;\n  while i < poly.numVertices\n    invariant 0 <= i <= poly.numVertices\n    invariant newPoly.numVertices == poly.numVertices\n    modifies newPoly.vertices\n  {\n    newPoly.vertices[i] := new Point(poly.vertices[i].x + dx, poly.vertices[i].y + dy);\n    i := i + 1;\n  }\n}", "name": "py2dfy_169", "id": 169}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype FieldType = \n  | AutoField(autoCreated: bool, primaryKey: bool)\n  | CharField(maxLength: int)\n  | IntegerField(defaultValue: int)\n  | DateTimeField(verbose: string)\n  | DateField\n  | ForeignKey(targetModel: string)\nclass Field {\n  var name: string\n  var fieldType: FieldType\n  \n  constructor(n: string, ft: FieldType)\n  {\n    name := n;\n    fieldType := ft;\n  }\n}\nclass Model {\n  var name: string\n  var fields: seq<Field>\n  \n  constructor(n: string)\n  {\n    name := n;\n    fields := [];\n  }\n  \n  method AddField(field: Field)\n  {\n    fields := fields + [field];\n  }\n}\nclass Migration {\n  var dependencies: seq<string>\n  var operations: seq<Model>\n  \n  constructor()\n  {\n    dependencies := [];\n    operations := [];\n  }\n  \n  method CreateModel(modelName: string, fields: seq<Field>) returns (model: Model)\n  {\n    model := new Model(modelName);\n    var i := 0;\n    while i < |fields|\n    {\n      model.AddField(fields[i]);\n      i := i + 1;\n    }\n    operations := operations + [model];\n  }\n  \n  method AddDependency(dep: string)\n  {\n    dependencies := dependencies + [dep];\n  }\n}", "output": "datatype FieldType = \n  | AutoField(autoCreated: bool, primaryKey: bool)\n  | CharField(maxLength: int)\n  | IntegerField(defaultValue: int)\n  | DateTimeField(verbose: string)\n  | DateField\n  | ForeignKey(targetModel: string)\nclass Field {\n  var name: string\n  var fieldType: FieldType\n  \n  constructor(n: string, ft: FieldType)\n    ensures name == n && fieldType == ft\n  {\n    name := n;\n    fieldType := ft;\n  }\n}\nclass Model {\n  var name: string\n  var fields: seq<Field>\n  \n  constructor(n: string)\n    ensures name == n && |fields| == 0\n  {\n    name := n;\n    fields := [];\n  }\n  \n  method AddField(field: Field)\n    modifies this\n    ensures |fields| == old(|fields|) + 1\n    ensures fields[|fields|-1] == field\n    ensures forall i :: 0 <= i < old(|fields|) ==> fields[i] == old(fields[i])\n    ensures name == old(name)\n  {\n    fields := fields + [field];\n  }\n}\nclass Migration {\n  var dependencies: seq<string>\n  var operations: seq<Model>\n  \n  constructor()\n    ensures |dependencies| == 0 && |operations| == 0\n  {\n    dependencies := [];\n    operations := [];\n  }\n  \n  method CreateModel(modelName: string, fields: seq<Field>) returns (model: Model)\n    modifies this\n    ensures model.name == modelName\n    ensures model.fields == fields\n    ensures operations == old(operations) + [model]\n  {\n    model := new Model(modelName);\n    var i := 0;\n    while i < |fields|\n      modifies model\n      invariant 0 <= i <= |fields|\n      invariant model.fields == fields[..i]\n      invariant model.name == modelName\n      invariant forall j :: 0 <= j < i ==> model.fields[j] == fields[j]\n      decreases |fields| - i\n    {\n      model.AddField(fields[i]);\n      i := i + 1;\n    }\n    operations := operations + [model];\n  }\n  \n  method AddDependency(dep: string)\n    modifies this\n    ensures |dependencies| == old(|dependencies|) + 1\n    ensures dependencies[|dependencies|-1] == dep\n  {\n    dependencies := dependencies + [dep];\n  }\n}", "name": "py2dfy_191", "id": 191}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Location {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Warehouse {\n  var location: Location\n  var inventory: seq<int>  \n  var deliveryPoints: seq<Order>\n  var id: int\n  constructor(loc: Location, inv: seq<int>, id': int)\n  {\n    location := loc;\n    inventory := inv;\n    deliveryPoints := [];\n    id := id';\n  }\n}\nclass Order {\n  var location: Location\n  var products: seq<int>\n  var assignedWarehouse: Warehouse?\n  constructor(loc: Location, prods: seq<int>)\n  {\n    location := loc;\n    products := prods;\n    assignedWarehouse := null;\n  }\n}\nclass Drone {\n  var location: Location\n  var maxPayload: int\n  var currentLoad: int\n  var busy: bool\n  constructor(loc: Location, maxLoad: int)\n  {\n    location := loc;\n    maxPayload := maxLoad;\n    currentLoad := 0;\n    busy := false;\n  }\n}\nmethod TravelTime(from: Location, to: Location) returns (time: int)\n{\n  var dx := from.x - to.x;\n  var dy := from.y - to.y;\n  time := dx * dx + dy * dy;\n  time := SqrtCeil(time);\n}\nmethod SqrtCeil(n: int) returns (result: int)\n{\n  if n == 0 {\n    return 0;\n  }\n  result := 1;\n  while result * result < n\n  {\n    result := result + 1;\n  }\n}\nmethod AssignWarehousesToOrders(orders: seq<Order>, warehouses: seq<Warehouse>)\n{\n  var i := 0;\n  while i < |orders|\n  {\n    var minDist := -1;\n    var bestWH := 0;\n    var j := 0;\n    while j < |warehouses|\n    {\n      var dist := TravelTime(orders[i].location, warehouses[j].location);\n      if minDist == -1 || dist < minDist {\n        minDist := dist;\n        bestWH := j;\n      }\n      j := j + 1;\n    }\n    orders[i].assignedWarehouse := warehouses[bestWH];\n    i := i + 1;\n  }\n}", "output": "class Location {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n    ensures this.x == x' && this.y == y'\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Warehouse {\n  var location: Location\n  var inventory: seq<int>  \n  var deliveryPoints: seq<Order>\n  var id: int\n  constructor(loc: Location, inv: seq<int>, id': int)\n    ensures this.location == loc\n    ensures this.inventory == inv\n    ensures this.id == id'\n  {\n    location := loc;\n    inventory := inv;\n    deliveryPoints := [];\n    id := id';\n  }\n}\nclass Order {\n  var location: Location\n  var products: seq<int>\n  var assignedWarehouse: Warehouse?\n  constructor(loc: Location, prods: seq<int>)\n    ensures this.location == loc\n    ensures this.products == prods\n    ensures this.assignedWarehouse == null\n  {\n    location := loc;\n    products := prods;\n    assignedWarehouse := null;\n  }\n}\nclass Drone {\n  var location: Location\n  var maxPayload: int\n  var currentLoad: int\n  var busy: bool\n  constructor(loc: Location, maxLoad: int)\n    requires maxLoad > 0\n    ensures this.location == loc\n    ensures this.maxPayload == maxLoad\n    ensures this.currentLoad == 0\n    ensures !this.busy\n  {\n    location := loc;\n    maxPayload := maxLoad;\n    currentLoad := 0;\n    busy := false;\n  }\n}\nmethod TravelTime(from: Location, to: Location) returns (time: int)\n  ensures time >= 0  \n{\n  var dx := from.x - to.x;\n  var dy := from.y - to.y;\n  time := dx * dx + dy * dy;\n  time := SqrtCeil(time);\n}\nmethod SqrtCeil(n: int) returns (result: int)\n  requires n >= 0\n  ensures result >= 0\n  ensures result * result >= n\n  ensures (result - 1) * (result - 1) < n || result == 0\n{\n  if n == 0 {\n    return 0;\n  }\n  result := 1;\n  while result * result < n\n    invariant result >= 1\n    invariant (result - 1) * (result - 1) < n\n    decreases n - result * result\n  {\n    result := result + 1;\n  }\n}\nmethod AssignWarehousesToOrders(orders: seq<Order>, warehouses: seq<Warehouse>)\n  requires |warehouses| > 0\n  modifies orders, set o | 0 <= o < |orders| :: orders[o]\n  ensures forall o | 0 <= o < |orders| :: orders[o].assignedWarehouse != null\n{\n  var i := 0;\n  while i < |orders|\n    invariant 0 <= i <= |orders|\n    invariant forall k | 0 <= k < i :: orders[k].assignedWarehouse != null\n    invariant forall k | 0 <= k < |orders| :: orders[k] in orders\n    invariant forall k | 0 <= k < i :: orders[k].assignedWarehouse in warehouses\n    modifies set o | 0 <= o < |orders| :: orders[o]\n  {\n    var minDist := -1;\n    var bestWH := 0;\n    var j := 0;\n    while j < |warehouses|\n      invariant 0 <= j <= |warehouses|\n      invariant minDist == -1 ==> j == 0\n      invariant minDist >= 0 ==> 0 <= bestWH < j\n      invariant bestWH < |warehouses|\n      invariant forall k | 0 <= k < i :: orders[k].assignedWarehouse != null\n      invariant forall k | 0 <= k < i :: orders[k].assignedWarehouse in warehouses\n    {\n      var dist := TravelTime(orders[i].location, warehouses[j].location);\n      if minDist == -1 || dist < minDist {\n        minDist := dist;\n        bestWH := j;\n      }\n      j := j + 1;\n    }\n    orders[i].assignedWarehouse := warehouses[bestWH];\n    i := i + 1;\n  }\n}", "name": "py2dfy_187", "id": 187}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module MainApp {\n  \n  datatype Screen = HomeScreen | SettingsScreen | LoginScreen | SignUpScreen | ForgotPasswordScreen\n  \n  datatype Option<T> = None | Some(value: T)\n  \n  datatype User = User(email: string, passwordHash: string)\n  \n  \n  class AppState {\n    \n    var currentScreen: Screen\n    \n    var users: seq<User>\n    \n    var loggedInUser: Option<User>\n    \n    \n    constructor()\n    {\n      currentScreen := LoginScreen;\n      users := [];\n      loggedInUser := None;\n    }\n    \n    \n    method ChangeScreen(targetScreen: Screen)\n    {\n      currentScreen := targetScreen;\n    }\n    \n    \n    method SignUp(email: string, password: string) returns (success: bool)\n    {\n      \n      var i := 0;\n      var userExists := false;\n      \n      \n      while i < |users|\n      {\n        if users[i].email == email {\n          userExists := true;\n          break;\n        }\n        i := i + 1;\n      }\n      \n      if userExists {\n        success := false;\n        return;\n      }\n      \n      \n      var newUser := User(email, password); \n      var oldUsers := users;\n      users := users + [newUser];\n      \n      \n      \n      success := true;\n    }\n    \n    method Login(email: string, password: string) returns (success: bool)\n    {\n      \n      var i := 0;\n      var foundUser: Option<User> := None;\n      \n      while i < |users|\n      {\n        if users[i].email == email && users[i].passwordHash == password {\n          foundUser := Some(users[i]);\n          break;\n        }\n        i := i + 1;\n      }\n      \n      if foundUser.Some? {\n        loggedInUser := foundUser;\n        success := true;\n        \n        currentScreen := HomeScreen;\n      } else {\n        success := false;\n      }\n    }\n    \n    method ForgotPassword(email: string) returns (success: bool)\n    {\n      \n      var userExists := false;\n      var i := 0;\n      \n      while i < |users|\n      {\n        if users[i].email == email {\n          userExists := true;\n          break;\n        }\n        i := i + 1;\n      }\n      \n      success := userExists;\n    }\n    \n    method Logout()\n    {\n      loggedInUser := None;\n      currentScreen := LoginScreen;\n    }\n  }\n  \n  \n  method Main()\n  {\n    var app := new AppState();\n    \n    \n    \n  }\n}", "output": "module MainApp {\n  \n  datatype Screen = HomeScreen | SettingsScreen | LoginScreen | SignUpScreen | ForgotPasswordScreen\n  \n  datatype Option<T> = None | Some(value: T)\n  \n  datatype User = User(email: string, passwordHash: string)\n  \n  \n  class AppState {\n    \n    var currentScreen: Screen\n    \n    var users: seq<User>\n    \n    var loggedInUser: Option<User>\n    \n    \n    constructor()\n      ensures currentScreen == LoginScreen\n      ensures users == []\n      ensures loggedInUser == None\n    {\n      currentScreen := LoginScreen;\n      users := [];\n      loggedInUser := None;\n    }\n    \n    \n    method ChangeScreen(targetScreen: Screen)\n      modifies this\n      ensures currentScreen == targetScreen\n      ensures users == old(users)\n      ensures loggedInUser == old(loggedInUser)\n    {\n      currentScreen := targetScreen;\n    }\n    \n    \n    method SignUp(email: string, password: string) returns (success: bool)\n      modifies this\n      requires email != \"\"\n      requires |password| >= 6 \n      ensures success ==> exists i :: 0 <= i < |users| && users[i].email == email\n      ensures !success ==> users == old(users)\n      ensures currentScreen == old(currentScreen)\n      ensures loggedInUser == old(loggedInUser)\n    {\n      \n      var i := 0;\n      var userExists := false;\n      \n      \n      while i < |users|\n        invariant 0 <= i <= |users|\n        invariant userExists <==> exists j :: 0 <= j < i && users[j].email == email\n      {\n        if users[i].email == email {\n          userExists := true;\n          break;\n        }\n        i := i + 1;\n      }\n      \n      if userExists {\n        success := false;\n        return;\n      }\n      \n      \n      var newUser := User(email, password); \n      var oldUsers := users;\n      users := users + [newUser];\n      \n      \n      assert users[|oldUsers|] == newUser;\n      assert users[|oldUsers|].email == email;\n      assert |oldUsers| < |users|;\n      assert exists i :: 0 <= i < |users| && users[i].email == email;\n      \n      success := true;\n    }\n    \n    method Login(email: string, password: string) returns (success: bool)\n      modifies this\n      ensures success ==> loggedInUser.Some?\n      ensures success ==> loggedInUser.value.email == email\n      ensures !success ==> loggedInUser == old(loggedInUser)\n      ensures users == old(users)\n    {\n      \n      var i := 0;\n      var foundUser: Option<User> := None;\n      \n      while i < |users|\n        invariant 0 <= i <= |users|\n        invariant foundUser.Some? ==> exists j :: 0 <= j < i && users[j].email == email && users[j].passwordHash == password\n        invariant foundUser.None? ==> !(exists j :: 0 <= j < i && users[j].email == email && users[j].passwordHash == password)\n      {\n        if users[i].email == email && users[i].passwordHash == password {\n          foundUser := Some(users[i]);\n          break;\n        }\n        i := i + 1;\n      }\n      \n      if foundUser.Some? {\n        loggedInUser := foundUser;\n        success := true;\n        \n        currentScreen := HomeScreen;\n      } else {\n        success := false;\n      }\n    }\n    \n    method ForgotPassword(email: string) returns (success: bool)\n      ensures users == old(users)\n      ensures loggedInUser == old(loggedInUser)\n      ensures currentScreen == old(currentScreen)\n    {\n      \n      var userExists := false;\n      var i := 0;\n      \n      while i < |users|\n        invariant 0 <= i <= |users|\n        invariant userExists <==> exists j :: 0 <= j < i && users[j].email == email\n      {\n        if users[i].email == email {\n          userExists := true;\n          break;\n        }\n        i := i + 1;\n      }\n      \n      success := userExists;\n    }\n    \n    method Logout()\n      modifies this\n      ensures loggedInUser == None\n      ensures currentScreen == LoginScreen\n      ensures users == old(users)\n    {\n      loggedInUser := None;\n      currentScreen := LoginScreen;\n    }\n  }\n  \n  \n  method Main()\n  {\n    var app := new AppState();\n    \n    \n    \n  }\n}", "name": "py2dfy_188", "id": 188}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class RoomManager {\n    var roomTypes: map<string, int>\n    constructor()\n    {\n        roomTypes := map[];\n    }\n    method AddRoom(roomName: string, chance: int) returns (success: bool)\n                r in roomTypes && roomTypes[r] == old(roomTypes)[r]\n    {\n        if roomName in roomTypes {\n            success := false;\n            return;\n        }\n        roomTypes := roomTypes[roomName := chance];\n        success := true;\n    }\n    method DeleteRoom(roomName: string) returns (success: bool)\n                r in roomTypes && roomTypes[r] == old(roomTypes)[r]\n    {\n        if roomName !in roomTypes {\n            success := false;\n            return;\n        }\n        \n        var newRoomTypes := map[];\n        success := true;\n        \n        var keys := roomTypes.Keys;\n        while keys != {}\n                    r in old(roomTypes) && newRoomTypes[r] == old(roomTypes)[r]\n                    r in newRoomTypes && newRoomTypes[r] == old(roomTypes)[r]\n        {\n            var k :| k in keys;\n            if k != roomName {\n                newRoomTypes := newRoomTypes[k := roomTypes[k]];\n            }\n            keys := keys - {k};\n        }\n        \n        roomTypes := newRoomTypes;\n    }\n    method GetRooms() returns (rooms: map<string, int>)\n    {\n        rooms := roomTypes;\n    }\n}\nmethod MainLoop(rm: RoomManager?)\n{\n    var running := true;\n    while running\n    {\n        var option := \"\"; \n        print \"Enter option (add/del/view/quit): \";\n        \n        \n        match option {\n            case \"add\" =>\n                var name := \"\"; \n                var chance := 0; \n                \n                var success := rm.AddRoom(name, chance);\n                \n            case \"del\" =>\n                var name := \"\"; \n                \n                var success := rm.DeleteRoom(name);\n                \n            case \"view\" =>\n                var rooms := rm.GetRooms();\n                \n            case _ =>\n                running := false;\n        }\n    }\n}", "output": "class RoomManager {\n    var roomTypes: map<string, int>\n    constructor()\n        ensures fresh(this)\n        ensures roomTypes == map[]\n    {\n        roomTypes := map[];\n    }\n    method AddRoom(roomName: string, chance: int) returns (success: bool)\n        requires chance >= 0 && chance <= 100  \n        modifies this\n        ensures success ==> roomName in roomTypes\n        ensures success ==> roomTypes[roomName] == chance\n        ensures !success ==> roomTypes == old(roomTypes)\n        ensures forall r :: r in old(roomTypes) && r != roomName ==> \n                r in roomTypes && roomTypes[r] == old(roomTypes)[r]\n    {\n        if roomName in roomTypes {\n            success := false;\n            return;\n        }\n        roomTypes := roomTypes[roomName := chance];\n        success := true;\n    }\n    method DeleteRoom(roomName: string) returns (success: bool)\n        modifies this\n        ensures success <==> (roomName in old(roomTypes))\n        ensures success ==> roomName !in roomTypes\n        ensures forall r :: r in old(roomTypes) && r != roomName ==> \n                r in roomTypes && roomTypes[r] == old(roomTypes)[r]\n    {\n        if roomName !in roomTypes {\n            success := false;\n            return;\n        }\n        \n        var newRoomTypes := map[];\n        success := true;\n        \n        var keys := roomTypes.Keys;\n        while keys != {}\n            decreases keys\n            invariant newRoomTypes.Keys !! {roomName}\n            invariant forall r :: r in newRoomTypes ==> \n                    r in old(roomTypes) && newRoomTypes[r] == old(roomTypes)[r]\n            invariant forall r :: r in old(roomTypes) && r != roomName && r !in keys ==>\n                    r in newRoomTypes && newRoomTypes[r] == old(roomTypes)[r]\n        {\n            var k :| k in keys;\n            if k != roomName {\n                newRoomTypes := newRoomTypes[k := roomTypes[k]];\n            }\n            keys := keys - {k};\n        }\n        \n        roomTypes := newRoomTypes;\n    }\n    method GetRooms() returns (rooms: map<string, int>)\n        ensures rooms == roomTypes\n    {\n        rooms := roomTypes;\n    }\n}\nmethod MainLoop(rm: RoomManager?)\n    requires rm != null\n    modifies rm\n    decreases *\n{\n    var running := true;\n    while running\n        modifies rm\n        decreases *\n    {\n        var option := \"\"; \n        print \"Enter option (add/del/view/quit): \";\n        \n        \n        match option {\n            case \"add\" =>\n                var name := \"\"; \n                var chance := 0; \n                \n                var success := rm.AddRoom(name, chance);\n                \n            case \"del\" =>\n                var name := \"\"; \n                \n                var success := rm.DeleteRoom(name);\n                \n            case \"view\" =>\n                var rooms := rm.GetRooms();\n                \n            case _ =>\n                running := false;\n        }\n    }\n}", "name": "py2dfy_190", "id": 190}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class WorkCenter {\n    var id: int\n    var qtyTerminalsReceived: int\n    var qtyTerminalsUsed: int\n    var region: string\n    constructor(id': int, region': string)\n    {\n        id := id';\n        qtyTerminalsReceived := 0;\n        qtyTerminalsUsed := 0;\n        region := region';\n    }\n    \n    function GetAvailableTerminals(): int\n    {\n        qtyTerminalsReceived - qtyTerminalsUsed\n    }\n}\nclass Expedition {\n    var id: int\n    var qtyTerminals: int\n    var wasCanceled: bool\n    var workCenter: WorkCenter\n    constructor(id': int, qty: int, wc: WorkCenter)\n    {\n        id := id';\n        qtyTerminals := qty;\n        wasCanceled := false;\n        workCenter := wc;\n    }\n}\nclass ExpeditionManager {\n    var expeditions: seq<Expedition>\n    var repr: set<object>\n    predicate Valid()\n    {\n        this in repr &&\n        (forall e :: e in expeditions ==> e in repr && e.workCenter in repr)\n    }\n    constructor()\n    {\n        expeditions := [];\n        repr := {this};\n    }\n    \n    method CreateExpedition(id: int, qty: int, workCenter: WorkCenter) returns (exp: Expedition)\n    {\n        exp := new Expedition(id, qty, workCenter);\n        expeditions := expeditions + [exp];\n        repr := repr + {exp};\n        workCenter.qtyTerminalsReceived := workCenter.qtyTerminalsReceived + qty;\n    }\n    \n    method CancelExpedition(exp: Expedition)\n                old(exp.workCenter.qtyTerminalsReceived) - (if old(!exp.wasCanceled) then exp.qtyTerminals else 0)\n    {\n        if !exp.wasCanceled {\n            exp.wasCanceled := true;\n            exp.workCenter.qtyTerminalsReceived := \n                exp.workCenter.qtyTerminalsReceived - exp.qtyTerminals;\n        }\n    }\n    \n    method FindExpedition(id: int) returns (exp: Expedition?)\n    {\n        var i := 0;\n        while i < |expeditions|\n        {\n            if expeditions[i].id == id {\n                return expeditions[i];\n            }\n            i := i + 1;\n        }\n        return null;\n    }\n}", "output": "class WorkCenter {\n    var id: int\n    var qtyTerminalsReceived: int\n    var qtyTerminalsUsed: int\n    var region: string\n    constructor(id': int, region': string)\n        requires id' > 0\n    {\n        id := id';\n        qtyTerminalsReceived := 0;\n        qtyTerminalsUsed := 0;\n        region := region';\n    }\n    \n    function GetAvailableTerminals(): int\n        reads this\n    {\n        qtyTerminalsReceived - qtyTerminalsUsed\n    }\n}\nclass Expedition {\n    var id: int\n    var qtyTerminals: int\n    var wasCanceled: bool\n    var workCenter: WorkCenter\n    constructor(id': int, qty: int, wc: WorkCenter)\n        requires id' > 0\n        requires qty > 0\n        ensures id == id'\n        ensures qtyTerminals == qty\n        ensures workCenter == wc\n        ensures !wasCanceled\n    {\n        id := id';\n        qtyTerminals := qty;\n        wasCanceled := false;\n        workCenter := wc;\n    }\n}\nclass ExpeditionManager {\n    var expeditions: seq<Expedition>\n    var repr: set<object>\n    predicate Valid()\n        reads this, repr\n    {\n        this in repr &&\n        (forall e :: e in expeditions ==> e in repr && e.workCenter in repr)\n    }\n    constructor()\n        ensures Valid()\n        ensures fresh(repr)\n    {\n        expeditions := [];\n        repr := {this};\n    }\n    \n    method CreateExpedition(id: int, qty: int, workCenter: WorkCenter) returns (exp: Expedition)\n        requires id > 0\n        requires qty > 0\n        requires Valid()\n        requires workCenter in repr\n        modifies this, repr, workCenter\n        ensures exp.id == id && exp.qtyTerminals == qty\n        ensures exp.workCenter == workCenter && !exp.wasCanceled\n        ensures workCenter.qtyTerminalsReceived == old(workCenter.qtyTerminalsReceived) + qty\n        ensures Valid()\n        ensures fresh(exp)\n    {\n        exp := new Expedition(id, qty, workCenter);\n        expeditions := expeditions + [exp];\n        repr := repr + {exp};\n        workCenter.qtyTerminalsReceived := workCenter.qtyTerminalsReceived + qty;\n    }\n    \n    method CancelExpedition(exp: Expedition)\n        requires exp in expeditions\n        requires Valid()\n        modifies exp, exp.workCenter\n        ensures exp.wasCanceled\n        ensures exp.workCenter.qtyTerminalsReceived == \n                old(exp.workCenter.qtyTerminalsReceived) - (if old(!exp.wasCanceled) then exp.qtyTerminals else 0)\n        ensures Valid()\n    {\n        if !exp.wasCanceled {\n            exp.wasCanceled := true;\n            exp.workCenter.qtyTerminalsReceived := \n                exp.workCenter.qtyTerminalsReceived - exp.qtyTerminals;\n        }\n    }\n    \n    method FindExpedition(id: int) returns (exp: Expedition?)\n        requires Valid()\n        ensures exp != null ==> exp in expeditions && exp.id == id\n        ensures exp == null ==> forall e :: e in expeditions ==> e.id != id\n    {\n        var i := 0;\n        while i < |expeditions|\n            invariant 0 <= i <= |expeditions|\n            invariant forall k :: 0 <= k < i ==> expeditions[k].id != id\n        {\n            if expeditions[i].id == id {\n                return expeditions[i];\n            }\n            i := i + 1;\n        }\n        return null;\n    }\n}", "name": "py2dfy_178", "id": 178}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Configuration {\n    var secretKey: string\n    var clientAuthBase: string\n    var djoserConfig: map<string, string>\n    var databaseConfig: map<string, string>\n    predicate ValidState()\n    {\n        secretKey != \"\" &&\n        clientAuthBase != \"\" &&\n        |djoserConfig| > 0 &&\n        |databaseConfig| > 0\n    }\n    constructor()\n    {\n        secretKey := \"\";\n        clientAuthBase := \"\";\n        djoserConfig := map[];\n        databaseConfig := map[];\n    }\n    method SetSecretKey(key: string)\n    {\n        secretKey := key;\n    }\n    method ConfigureDjoser(base: string)\n    {\n        clientAuthBase := base;\n        \n        var newConfig := map[\n            \"PASSWORD_RESET_CONFIRM_URL\" := base + \"/password/reset/confirm/{uid}/{token}\",\n            \"ACTIVATION_URL\" := base + \"/activate/{uid}/{token}\",\n            \"SEND_ACTIVATION_EMAIL\" := \"false\",\n            \"SERIALIZERS_USER\" := \"base.serializers.UserSerializer\"\n        ];\n        djoserConfig := newConfig;\n    }\n    method ConfigureDatabase(\n        name: string, \n        user: string, \n        password: string, \n        host: string, \n        port: string\n    )\n    {\n        var newConfig := map[\n            \"ENGINE\" := \"django.db.backends.postgresql\",\n            \"NAME\" := name,\n            \"USER\" := user,\n            \"PASSWORD\" := password,\n            \"HOST\" := host,\n            \"PORT\" := port\n        ];\n        databaseConfig := newConfig;\n    }\n}", "output": "class Configuration {\n    var secretKey: string\n    var clientAuthBase: string\n    var djoserConfig: map<string, string>\n    var databaseConfig: map<string, string>\n    predicate ValidState()\n    reads this\n    {\n        secretKey != \"\" &&\n        clientAuthBase != \"\" &&\n        |djoserConfig| > 0 &&\n        |databaseConfig| > 0\n    }\n    constructor()\n    ensures secretKey == \"\"\n    ensures clientAuthBase == \"\"\n    ensures djoserConfig == map[]\n    ensures databaseConfig == map[]\n    {\n        secretKey := \"\";\n        clientAuthBase := \"\";\n        djoserConfig := map[];\n        databaseConfig := map[];\n    }\n    method SetSecretKey(key: string)\n    requires key != \"\"\n    requires |djoserConfig| > 0 && |databaseConfig| > 0 && clientAuthBase != \"\"\n    modifies this\n    ensures secretKey == key\n    ensures clientAuthBase == old(clientAuthBase)\n    ensures djoserConfig == old(djoserConfig)\n    ensures databaseConfig == old(databaseConfig)\n    ensures ValidState()\n    {\n        secretKey := key;\n    }\n    method ConfigureDjoser(base: string)\n    requires base != \"\"\n    requires secretKey != \"\" && |databaseConfig| > 0\n    modifies this\n    ensures clientAuthBase == base\n    ensures \"PASSWORD_RESET_CONFIRM_URL\" in djoserConfig && djoserConfig[\"PASSWORD_RESET_CONFIRM_URL\"] == base + \"/password/reset/confirm/{uid}/{token}\"\n    ensures \"ACTIVATION_URL\" in djoserConfig && djoserConfig[\"ACTIVATION_URL\"] == base + \"/activate/{uid}/{token}\"\n    ensures \"SEND_ACTIVATION_EMAIL\" in djoserConfig && djoserConfig[\"SEND_ACTIVATION_EMAIL\"] == \"false\"\n    ensures \"SERIALIZERS_USER\" in djoserConfig && djoserConfig[\"SERIALIZERS_USER\"] == \"base.serializers.UserSerializer\"\n    ensures secretKey == old(secretKey)\n    ensures databaseConfig == old(databaseConfig)\n    ensures ValidState()\n    {\n        clientAuthBase := base;\n        \n        var newConfig := map[\n            \"PASSWORD_RESET_CONFIRM_URL\" := base + \"/password/reset/confirm/{uid}/{token}\",\n            \"ACTIVATION_URL\" := base + \"/activate/{uid}/{token}\",\n            \"SEND_ACTIVATION_EMAIL\" := \"false\",\n            \"SERIALIZERS_USER\" := \"base.serializers.UserSerializer\"\n        ];\n        djoserConfig := newConfig;\n    }\n    method ConfigureDatabase(\n        name: string, \n        user: string, \n        password: string, \n        host: string, \n        port: string\n    )\n    requires name != \"\" && user != \"\" && password != \"\" && host != \"\" && port != \"\"\n    requires secretKey != \"\" && clientAuthBase != \"\" && |djoserConfig| > 0\n    modifies this\n    ensures \"ENGINE\" in databaseConfig && databaseConfig[\"ENGINE\"] == \"django.db.backends.postgresql\"\n    ensures \"NAME\" in databaseConfig && databaseConfig[\"NAME\"] == name\n    ensures \"USER\" in databaseConfig && databaseConfig[\"USER\"] == user\n    ensures \"PASSWORD\" in databaseConfig && databaseConfig[\"PASSWORD\"] == password\n    ensures \"HOST\" in databaseConfig && databaseConfig[\"HOST\"] == host\n    ensures \"PORT\" in databaseConfig && databaseConfig[\"PORT\"] == port\n    ensures secretKey == old(secretKey)\n    ensures clientAuthBase == old(clientAuthBase)\n    ensures djoserConfig == old(djoserConfig)\n    ensures ValidState()\n    {\n        var newConfig := map[\n            \"ENGINE\" := \"django.db.backends.postgresql\",\n            \"NAME\" := name,\n            \"USER\" := user,\n            \"PASSWORD\" := password,\n            \"HOST\" := host,\n            \"PORT\" := port\n        ];\n        databaseConfig := newConfig;\n    }\n}", "name": "py2dfy_156", "id": 156}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main() {\n  var i := 0;\n  while i < 2\n  {\n    i := i + 1;\n  }\n}", "output": "method Main() {\n  var i := 0;\n  while i < 2\n  invariant 0 <= i\n  decreases  2 - i\n  {\n    i := i + 1;\n  }\n  assert 1 < 2;\n  assert 2 < 3;\n  assert 3 < 4;\n}", "name": "py2dfy_203", "id": 203}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class FlowerPredictionModel {\n    \n    var classToIdx: map<int, int>  \n    var modelState: array<real>     \n    var hiddenUnits: nat\n    var learningRate: real  \n    var epochs: nat\n    var trainingSteps: nat\n    \n    \n    constructor(gpu: bool)\n    {\n        modelState := new real[100];  \n        hiddenUnits := 0;\n        learningRate := 0.0;\n        epochs := 0;\n        trainingSteps := 0;\n        classToIdx := map[];\n    }\n    \n    method Build(arch: string, lr: real, hidden: nat) returns (success: bool)\n    {\n        if arch != \"vgg16\" && arch != \"resnet18\" {\n            return false;\n        }\n        \n        learningRate := lr;\n        hiddenUnits := hidden;\n        return true;\n    }\n    \n    method Train(data: array<real>, labels: array<int>, epochs: nat) returns (loss: real)\n    {\n        var currentEpoch := 0;\n        loss := 0.0;\n        var oldTrainingSteps := trainingSteps;\n        trainingSteps := trainingSteps + 1; \n        \n        while currentEpoch < epochs\n        {\n            var i := 0;\n            while i < data.Length\n            {\n                \n                trainingSteps := trainingSteps + 1;\n                var stepLoss: real;\n                stepLoss := if data[i] >= 0.0 then 0.1 else 0.2; \n                loss := loss + stepLoss;\n                i := i + 1;\n            }\n            currentEpoch := currentEpoch + 1;\n        }\n    }\n    \n    function ComputeLoss(x: real, lbl: int): real\n    {\n        if x >= 0.0 then 0.1 else 0.2\n    }\n    \n    method Predict(input: array<real>, topK: nat) returns (probs: array<real>, classes: array<int>)\n    {\n        probs := new real[topK];\n        classes := new int[topK];\n        \n        var i := 0;\n        while i < topK\n        {\n            \n            var denominator := i as real + 1.0;\n            probs[i] := 1.0 / denominator;\n            classes[i] := i;\n            i := i + 1;\n        }\n    }\n}", "output": "class FlowerPredictionModel {\n    \n    var classToIdx: map<int, int>  \n    var modelState: array<real>     \n    var hiddenUnits: nat\n    var learningRate: real  \n    var epochs: nat\n    var trainingSteps: nat\n    \n    \n    constructor(gpu: bool)\n        ensures fresh(modelState)\n        ensures modelState.Length > 0\n    {\n        modelState := new real[100];  \n        hiddenUnits := 0;\n        learningRate := 0.0;\n        epochs := 0;\n        trainingSteps := 0;\n        classToIdx := map[];\n    }\n    \n    method Build(arch: string, lr: real, hidden: nat) returns (success: bool)\n        requires lr > 0.0\n        requires hidden > 0\n        modifies this\n        ensures success ==> learningRate == lr && hiddenUnits == hidden\n        ensures !success ==> learningRate == old(learningRate) && hiddenUnits == old(hiddenUnits)\n    {\n        if arch != \"vgg16\" && arch != \"resnet18\" {\n            return false;\n        }\n        \n        learningRate := lr;\n        hiddenUnits := hidden;\n        return true;\n    }\n    \n    method Train(data: array<real>, labels: array<int>, epochs: nat) returns (loss: real)\n        requires data.Length > 0 && labels.Length > 0\n        requires data.Length == labels.Length\n        requires epochs > 0\n        modifies this`trainingSteps, this`modelState\n        ensures trainingSteps > old(trainingSteps)\n        ensures loss >= 0.0\n    {\n        var currentEpoch := 0;\n        loss := 0.0;\n        var oldTrainingSteps := trainingSteps;\n        trainingSteps := trainingSteps + 1; \n        \n        while currentEpoch < epochs\n            invariant 0 <= currentEpoch <= epochs\n            invariant trainingSteps > oldTrainingSteps\n            invariant loss >= 0.0\n        {\n            var i := 0;\n            while i < data.Length\n                invariant 0 <= i <= data.Length\n                invariant loss >= 0.0\n                invariant trainingSteps > oldTrainingSteps\n            {\n                \n                trainingSteps := trainingSteps + 1;\n                var stepLoss: real;\n                stepLoss := if data[i] >= 0.0 then 0.1 else 0.2; \n                loss := loss + stepLoss;\n                i := i + 1;\n            }\n            currentEpoch := currentEpoch + 1;\n        }\n    }\n    \n    function ComputeLoss(x: real, lbl: int): real\n        ensures ComputeLoss(x, lbl) >= 0.0\n    {\n        if x >= 0.0 then 0.1 else 0.2\n    }\n    \n    method Predict(input: array<real>, topK: nat) returns (probs: array<real>, classes: array<int>)\n        requires input.Length > 0\n        requires topK > 0 && topK <= 102  \n        ensures fresh(probs) && fresh(classes)\n        ensures probs.Length == topK\n        ensures classes.Length == topK\n        ensures forall i :: 0 <= i < probs.Length ==> 0.0 <= probs[i] <= 1.0\n    {\n        probs := new real[topK];\n        classes := new int[topK];\n        \n        var i := 0;\n        while i < topK\n            invariant 0 <= i <= topK\n            invariant forall j :: 0 <= j < i ==> 0.0 <= probs[j] <= 1.0\n        {\n            \n            var denominator := i as real + 1.0;\n            probs[i] := 1.0 / denominator;\n            classes[i] := i;\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_194", "id": 194}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Query {\n  \n  var author: string\n  var body: string\n  var displayName: string\n  var id: string\n  var name: string\n  var description: string\n  var timeCreated: string\n  var timeModified: string\n  var queryType: string\n  \n  \n  predicate Valid()\n  {\n    \n    |author| > 0 &&\n    |body| > 0 &&\n    |displayName| > 0 &&\n    |id| > 0 &&\n    |name| > 0 &&\n    |timeCreated| > 0 &&\n    |timeModified| > 0 &&\n    |queryType| > 0\n  }\n  \n  constructor(\n    author: string,\n    body: string,\n    displayName: string,\n    id: string,\n    name: string,\n    description: string,\n    timeCreated: string,\n    timeModified: string,\n    queryType: string)\n  {\n    this.author := author;\n    this.body := body;\n    this.displayName := displayName;\n    this.id := id;\n    this.name := name;\n    this.description := description;\n    this.timeCreated := timeCreated;\n    this.timeModified := timeModified;\n    this.queryType := queryType;\n  }\n  \n  method UpdateDescription(newDescription: string)\n  {\n    description := newDescription;\n  }\n}", "output": "class Query {\n  \n  var author: string\n  var body: string\n  var displayName: string\n  var id: string\n  var name: string\n  var description: string\n  var timeCreated: string\n  var timeModified: string\n  var queryType: string\n  \n  \n  predicate Valid()\n    reads this\n  {\n    \n    |author| > 0 &&\n    |body| > 0 &&\n    |displayName| > 0 &&\n    |id| > 0 &&\n    |name| > 0 &&\n    |timeCreated| > 0 &&\n    |timeModified| > 0 &&\n    |queryType| > 0\n  }\n  \n  constructor(\n    author: string,\n    body: string,\n    displayName: string,\n    id: string,\n    name: string,\n    description: string,\n    timeCreated: string,\n    timeModified: string,\n    queryType: string)\n    requires |author| > 0\n    requires |body| > 0\n    requires |displayName| > 0\n    requires |id| > 0\n    requires |name| > 0\n    requires |timeCreated| > 0\n    requires |timeModified| > 0\n    requires |queryType| > 0\n    ensures Valid()\n    ensures this.author == author\n    ensures this.body == body\n    ensures this.displayName == displayName\n    ensures this.id == id\n    ensures this.name == name\n    ensures this.description == description\n    ensures this.timeCreated == timeCreated\n    ensures this.timeModified == timeModified\n    ensures this.queryType == queryType\n  {\n    this.author := author;\n    this.body := body;\n    this.displayName := displayName;\n    this.id := id;\n    this.name := name;\n    this.description := description;\n    this.timeCreated := timeCreated;\n    this.timeModified := timeModified;\n    this.queryType := queryType;\n  }\n  \n  method UpdateDescription(newDescription: string)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures description == newDescription\n    ensures author == old(author)\n    ensures body == old(body)\n    ensures displayName == old(displayName)\n    ensures id == old(id)\n    ensures name == old(name)\n    ensures timeCreated == old(timeCreated)\n    ensures timeModified == old(timeModified)\n    ensures queryType == old(queryType)\n  {\n    description := newDescription;\n  }\n}", "name": "py2dfy_197", "id": 197}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Nuisance {\n  var name: string\n  var kind: string\n  var nuisanceType: string\n  var samples: map<string, seq<string>>\n  var skipCMS: int\n  constructor()\n  {\n    samples := map[];\n    skipCMS := 0;\n  }\n}\nclass NuisanceManager {\n  var nuisances: map<string, Nuisance>\n  constructor()\n  {\n    nuisances := map[];\n  }\n  method Init()\n  {\n    nuisances := map[];\n  }\n  method AddQCDScaleWW()\n  {\n    var qcdScale := new Nuisance();\n    qcdScale.name := \"QCDscale_WW\";\n    qcdScale.kind := \"weight\";\n    qcdScale.nuisanceType := \"shape\";\n    qcdScale.samples := map[\"WW\" := [\"Alt$(LHEScaleWeight[0],1)\", \"Alt$(LHEScaleWeight[8],1)\"]];\n    nuisances := nuisances[qcdScale.name := qcdScale];\n  }\n  function IntToString(n: int): string\n  {\n    if n < 10 then [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"][n]\n    else IntToString(n/10) + IntToString(n%10)\n  }\n  \n  function IntToStringHelper(n: int): string\n  {\n    if n < 0 then \"-\" + IntToStringHelper(-n)\n    else if n < 10 then [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"][n]\n    else IntToStringHelper(n/10) + IntToStringHelper(n%10)\n  }\n  method AddPdfWW()\n  {\n    var pdfWW := new Nuisance();\n    pdfWW.name := \"pdf_WW_2016\";\n    pdfWW.kind := \"weight_rms\";\n    pdfWW.nuisanceType := \"shape\";\n    \n    var pdfVariations: seq<string> := [];\n    var i := 0;\n    while i < 100\n    {\n      pdfVariations := pdfVariations + [\"LHEPdfWeight[\" + IntToStringHelper(i) + \"]\"];\n      i := i + 1;\n    }\n    \n    pdfWW.samples := map[\"WW\" := pdfVariations];\n    \n    nuisances := nuisances[\"pdf_WW\" := pdfWW];\n  }\n  method SetSkipCMS()\n  {\n    var keys := nuisances.Keys;\n    \n    while keys != {}\n    {\n      var k :| k in keys;\n      nuisances[k].skipCMS := 1;\n      keys := keys - {k};\n    }\n  }\n}", "output": "class Nuisance {\n  var name: string\n  var kind: string\n  var nuisanceType: string\n  var samples: map<string, seq<string>>\n  var skipCMS: int\n  constructor()\n    ensures fresh(this)\n    ensures samples == map[]\n    ensures skipCMS == 0\n  {\n    samples := map[];\n    skipCMS := 0;\n  }\n}\nclass NuisanceManager {\n  var nuisances: map<string, Nuisance>\n  constructor()\n    ensures nuisances == map[]\n  {\n    nuisances := map[];\n  }\n  method Init()\n    modifies this\n    ensures nuisances == map[]\n  {\n    nuisances := map[];\n  }\n  method AddQCDScaleWW()\n    modifies this\n    ensures \"QCDscale_WW\" in nuisances\n    ensures nuisances[\"QCDscale_WW\"].name == \"QCDscale_WW\"\n    ensures nuisances[\"QCDscale_WW\"].kind == \"weight\"\n    ensures nuisances[\"QCDscale_WW\"].nuisanceType == \"shape\"\n    ensures \"WW\" in nuisances[\"QCDscale_WW\"].samples\n    ensures |nuisances[\"QCDscale_WW\"].samples[\"WW\"]| == 2\n  {\n    var qcdScale := new Nuisance();\n    qcdScale.name := \"QCDscale_WW\";\n    qcdScale.kind := \"weight\";\n    qcdScale.nuisanceType := \"shape\";\n    qcdScale.samples := map[\"WW\" := [\"Alt$(LHEScaleWeight[0],1)\", \"Alt$(LHEScaleWeight[8],1)\"]];\n    nuisances := nuisances[qcdScale.name := qcdScale];\n  }\n  function IntToString(n: int): string\n    requires n >= 0\n  {\n    if n < 10 then [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"][n]\n    else IntToString(n/10) + IntToString(n%10)\n  }\n  \n  function IntToStringHelper(n: int): string\n    decreases n < 0, if n < 0 then -n else n\n  {\n    if n < 0 then \"-\" + IntToStringHelper(-n)\n    else if n < 10 then [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"][n]\n    else IntToStringHelper(n/10) + IntToStringHelper(n%10)\n  }\n  method AddPdfWW()\n    modifies this\n    ensures \"pdf_WW\" in nuisances\n    ensures nuisances[\"pdf_WW\"].name == \"pdf_WW_2016\"\n    ensures nuisances[\"pdf_WW\"].kind == \"weight_rms\"\n    ensures nuisances[\"pdf_WW\"].nuisanceType == \"shape\"\n    ensures \"WW\" in nuisances[\"pdf_WW\"].samples\n    ensures |nuisances[\"pdf_WW\"].samples[\"WW\"]| == 100\n  {\n    var pdfWW := new Nuisance();\n    pdfWW.name := \"pdf_WW_2016\";\n    pdfWW.kind := \"weight_rms\";\n    pdfWW.nuisanceType := \"shape\";\n    \n    var pdfVariations: seq<string> := [];\n    var i := 0;\n    while i < 100\n      invariant 0 <= i <= 100\n      invariant |pdfVariations| == i\n      invariant forall j :: 0 <= j < i ==> pdfVariations[j] == \"LHEPdfWeight[\" + IntToStringHelper(j) + \"]\"\n    {\n      pdfVariations := pdfVariations + [\"LHEPdfWeight[\" + IntToStringHelper(i) + \"]\"];\n      i := i + 1;\n    }\n    \n    pdfWW.samples := map[\"WW\" := pdfVariations];\n    \n    nuisances := nuisances[\"pdf_WW\" := pdfWW];\n  }\n  method SetSkipCMS()\n    modifies nuisances.Values\n    ensures forall n :: n in nuisances.Values ==> n.skipCMS == 1\n  {\n    var keys := nuisances.Keys;\n    \n    while keys != {}\n      invariant keys <= nuisances.Keys\n      invariant forall k :: k in nuisances.Keys && k !in keys ==> nuisances[k].skipCMS == 1\n      invariant forall k :: k in keys ==> k in nuisances\n      decreases |keys|\n    {\n      var k :| k in keys;\n      assert k in nuisances.Keys;\n      nuisances[k].skipCMS := 1;\n      keys := keys - {k};\n    }\n  }\n}", "name": "py2dfy_162", "id": 162}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class SerialConnection {\n  var isOpen: bool\n  var baudRate: nat  \n  var portName: string\n  \n  var written: seq<int>\n  \n  predicate Valid()\n  {\n    baudRate > 0 &&\n    |portName| > 0 &&\n    (isOpen ==> |written| >= 0)\n  }\n  \n  constructor(port: string, baud: nat)\n  {\n    portName := port;\n    baudRate := baud;\n    isOpen := false;\n    written := [];\n  }\n  \n  method Open() returns (success: bool)\n  {\n    if !isOpen {\n      isOpen := true;\n      written := [];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method Write(data: array<int>)\n  {\n    var newWritten := written + data[..];\n    written := newWritten;\n  }\n  \n  method Close()\n  {\n    isOpen := false;\n    written := [];\n  }\n}\nmethod Main()\n{\n  var portName := \"/dev/ttyS3\";\n  var baudRate := 9600;\n  \n  var serial := new SerialConnection(portName, baudRate);\n  var success := serial.Open();\n  \n  if success {\n    var data := new int[3];\n    data[0], data[1], data[2] := 255, 0, 0;\n    \n    serial.Write(data);\n    serial.Close();\n  }\n}", "output": "class SerialConnection {\n  var isOpen: bool\n  var baudRate: nat  \n  var portName: string\n  \n  var written: seq<int>\n  \n  predicate Valid()\n    reads this\n  {\n    baudRate > 0 &&\n    |portName| > 0 &&\n    (isOpen ==> |written| >= 0)\n  }\n  \n  constructor(port: string, baud: nat)\n    requires baud > 0\n    requires |port| > 0\n    ensures Valid()\n    ensures isOpen == false\n    ensures portName == port\n    ensures baudRate == baud\n    ensures written == []\n  {\n    portName := port;\n    baudRate := baud;\n    isOpen := false;\n    written := [];\n  }\n  \n  method Open() returns (success: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures old(isOpen) ==> success == false\n    ensures !old(isOpen) ==> isOpen && success\n    ensures success ==> written == []\n  {\n    if !isOpen {\n      isOpen := true;\n      written := [];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method Write(data: array<int>)\n    requires Valid()\n    requires isOpen\n    modifies this\n    ensures Valid()\n    ensures isOpen\n    ensures |written| == |old(written)| + data.Length\n  {\n    var newWritten := written + data[..];\n    written := newWritten;\n  }\n  \n  method Close()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures !isOpen\n    ensures written == []\n  {\n    isOpen := false;\n    written := [];\n  }\n}\nmethod Main()\n{\n  var portName := \"/dev/ttyS3\";\n  var baudRate := 9600;\n  \n  var serial := new SerialConnection(portName, baudRate);\n  var success := serial.Open();\n  \n  if success {\n    var data := new int[3];\n    data[0], data[1], data[2] := 255, 0, 0;\n    \n    serial.Write(data);\n    serial.Close();\n  }\n}", "name": "py2dfy_199", "id": 199}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Item = Item(value: string)\nclass Bag {\n    \n    var elements: seq<Item>\n    \n    \n    ghost predicate Valid()\n    {\n        true \n    }\n    \n    constructor()\n    {\n        elements := [];\n    }\n    \n    \n    method Add(item: Item)\n    {\n        elements := elements + [item];\n    }\n    \n    \n    method Size() returns (size: nat)\n    {\n        return |elements|;\n    }\n}\nmethod FromSequence(input: seq<string>) returns (bag: Bag)\n        bag.elements[i] == Item(input[i])\n{\n    bag := new Bag();\n    \n    \n    var i := 0;\n    while i < |input|\n            bag.elements[k] == Item(input[k])\n    {\n        bag.Add(Item(input[i]));\n        i := i + 1;\n    }\n}\nmethod FromFilenames(filenames: seq<string>) returns (bag: Bag)\n        bag.elements[i] == Item(filenames[i])\n{\n    \n    bag := FromSequence(filenames);\n}", "output": "datatype Item = Item(value: string)\nclass Bag {\n    \n    var elements: seq<Item>\n    \n    \n    ghost predicate Valid()\n        reads this\n    {\n        true \n    }\n    \n    constructor()\n        ensures Valid()\n        ensures fresh(this)\n        ensures elements == []\n    {\n        elements := [];\n    }\n    \n    \n    method Add(item: Item)\n        requires Valid()\n        modifies this\n        ensures Valid()\n        ensures elements == old(elements) + [item]\n    {\n        elements := elements + [item];\n    }\n    \n    \n    method Size() returns (size: nat)\n        requires Valid()\n        ensures size == |elements|\n    {\n        return |elements|;\n    }\n}\nmethod FromSequence(input: seq<string>) returns (bag: Bag)\n    ensures fresh(bag)\n    ensures bag.Valid()\n    ensures |bag.elements| == |input|\n    ensures forall i :: 0 <= i < |input| ==> \n        bag.elements[i] == Item(input[i])\n{\n    bag := new Bag();\n    \n    \n    var i := 0;\n    while i < |input|\n        invariant 0 <= i <= |input|\n        invariant bag.Valid()\n        invariant |bag.elements| == i\n        invariant forall k :: 0 <= k < i ==> \n            bag.elements[k] == Item(input[k])\n    {\n        bag.Add(Item(input[i]));\n        i := i + 1;\n    }\n}\nmethod FromFilenames(filenames: seq<string>) returns (bag: Bag)\n    ensures fresh(bag)\n    ensures bag.Valid()\n    ensures |bag.elements| == |filenames|\n    ensures forall i :: 0 <= i < |filenames| ==> \n        bag.elements[i] == Item(filenames[i])\n{\n    \n    bag := FromSequence(filenames);\n}", "name": "py2dfy_201", "id": 201}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Point {\n  var x: real\n  var y: real\n  constructor(x': real, y': real)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Matrix {\n  var data: array2<real>\n  var rows: nat\n  var cols: nat\n  constructor(r: nat, c: nat)\n  {\n    rows := r;\n    cols := c;\n    data := new real[r, c];\n  }\n  \n  predicate ValidCoords(i: int, j: int)\n  {\n    0 <= i < rows && 0 <= j < cols\n  }\n}\nmethod ObjectDef(D: real, DRatio: real, N: nat) returns (result: Matrix)\n{\n  \n  result := new Matrix(N, N);\n  \n  \n  var step: real := D / (N as real);\n  var offset: real := D / (2.0 * (N as real));\n  \n  \n  var x0: real := 0.3 * D * DRatio;\n  var y0: real := 0.1 * D * DRatio;\n  var radius: real := D * DRatio / 2.0;\n  \n  \n  var i := 0;\n  while i < N\n  {\n    var j := 0;\n    while j < N\n    {\n      \n      var x: real := -D/2.0 + (j as real)*step + offset;\n      var y: real := -D/2.0 + (i as real)*step + offset;\n      \n      \n      var r: real := Sqrt(x*x + y*y);\n      \n      \n      var dx := x-x0;\n      var dy := y-y0;\n      var dist: real := Sqrt(dx*dx + dy*dy);\n      \n      \n      if r < radius && dist >= radius/50.0 {\n        result.data[i,j] := 1.0;\n      } else {\n        result.data[i,j] := 0.0;\n      }\n      \n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nfunction {:axiom} Sqrt(x: real): (r: real)", "output": "class Point {\n  var x: real\n  var y: real\n  constructor(x': real, y': real)\n    ensures this.x == x' && this.y == y'\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Matrix {\n  var data: array2<real>\n  var rows: nat\n  var cols: nat\n  constructor(r: nat, c: nat)\n    requires r > 0 && c > 0\n    ensures fresh(data)\n    ensures data.Length0 == r && data.Length1 == c\n    ensures rows == r && cols == c\n  {\n    rows := r;\n    cols := c;\n    data := new real[r, c];\n  }\n  \n  predicate ValidCoords(i: int, j: int)\n    reads this\n  {\n    0 <= i < rows && 0 <= j < cols\n  }\n}\nmethod ObjectDef(D: real, DRatio: real, N: nat) returns (result: Matrix)\n  requires D > 0.0\n  requires 0.0 < DRatio <= 1.0\n  requires N > 0\n  ensures fresh(result)\n  ensures result.rows == N && result.cols == N\n  ensures fresh(result.data)\n{\n  \n  result := new Matrix(N, N);\n  \n  \n  var step: real := D / (N as real);\n  var offset: real := D / (2.0 * (N as real));\n  \n  \n  var x0: real := 0.3 * D * DRatio;\n  var y0: real := 0.1 * D * DRatio;\n  var radius: real := D * DRatio / 2.0;\n  \n  \n  var i := 0;\n  while i < N\n    invariant 0 <= i <= N\n    invariant fresh(result.data)\n    invariant result.rows == N && result.cols == N\n    invariant result.data.Length0 == N && result.data.Length1 == N\n  {\n    var j := 0;\n    while j < N\n      invariant 0 <= j <= N\n      invariant 0 <= i < N\n      invariant fresh(result.data)\n      invariant result.rows == N && result.cols == N\n      invariant result.ValidCoords(i,j-1) || j == 0\n      invariant result.data.Length0 == N && result.data.Length1 == N\n    {\n      \n      var x: real := -D/2.0 + (j as real)*step + offset;\n      var y: real := -D/2.0 + (i as real)*step + offset;\n      \n      \n      var r: real := Sqrt(x*x + y*y);\n      \n      \n      var dx := x-x0;\n      var dy := y-y0;\n      var dist: real := Sqrt(dx*dx + dy*dy);\n      \n      \n      if r < radius && dist >= radius/50.0 {\n        assert 0 <= i < result.data.Length0;\n        assert 0 <= j < result.data.Length1;\n        result.data[i,j] := 1.0;\n      } else {\n        assert 0 <= i < result.data.Length0;\n        assert 0 <= j < result.data.Length1;\n        result.data[i,j] := 0.0;\n      }\n      \n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nfunction {:axiom} Sqrt(x: real): (r: real)\n  requires x >= 0.0\n  ensures r >= 0.0\n  ensures r * r <= x + 0.000001  \n  ensures x <= r * r + 0.000001", "name": "py2dfy_200", "id": 200}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Product = Product(\n  id: int,\n  title: string, \n  price: real,\n  quantity: int,\n  description: string,\n  condition: string\n)\ndatatype ProductSpecification = ProductSpecification(\n  name: string,\n  value: string  \n)\ndatatype ProductImage = ProductImage(\n  image: string\n)\ndatatype Option<T> = None | Some(value: T)\nclass UpdateProduct {\n  \n  var products: map<int, Product>\n  var specifications: map<int, seq<ProductSpecification>> \n  var images: map<int, seq<ProductImage>>\n  constructor()\n  {\n    products := map[];\n    specifications := map[];\n    images := map[];\n  }\n  \n  method GetProduct(id: int) returns (p: Option<Product>)\n  {\n    if id in products {\n      return Some(products[id]);\n    }\n    return None;\n  }\n  \n  method ExtractFilterData<T>(data: seq<T>) returns (result: seq<T>)\n  {\n    result := data;\n  }\n  \n  predicate ValidSpecification(spec: ProductSpecification)\n  {\n    spec.name != \"\" && spec.value != \"\"\n  }\n  \n  method UpdateMainData(productId: int, newProduct: Product,\n                       newSpecs: seq<ProductSpecification>)\n    returns (success: bool)\n  {\n    \n    var allSpecsValid := true;\n    var i := 0;\n    while i < |newSpecs|\n    {\n      if !ValidSpecification(newSpecs[i]) {\n        allSpecsValid := false;\n        break;\n      }\n      i := i + 1;\n    }\n    if allSpecsValid {\n      products := products[productId := newProduct];\n      specifications := specifications[productId := newSpecs];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}", "output": "datatype Product = Product(\n  id: int,\n  title: string, \n  price: real,\n  quantity: int,\n  description: string,\n  condition: string\n)\ndatatype ProductSpecification = ProductSpecification(\n  name: string,\n  value: string  \n)\ndatatype ProductImage = ProductImage(\n  image: string\n)\ndatatype Option<T> = None | Some(value: T)\nclass UpdateProduct {\n  \n  var products: map<int, Product>\n  var specifications: map<int, seq<ProductSpecification>> \n  var images: map<int, seq<ProductImage>>\n  constructor()\n    ensures fresh(this)\n    ensures products == map[]\n    ensures specifications == map[]\n    ensures images == map[]\n  {\n    products := map[];\n    specifications := map[];\n    images := map[];\n  }\n  \n  method GetProduct(id: int) returns (p: Option<Product>)\n    ensures id in products ==> p.Some? && p.value == products[id]\n    ensures id !in products ==> p.None?\n  {\n    if id in products {\n      return Some(products[id]);\n    }\n    return None;\n  }\n  \n  method ExtractFilterData<T>(data: seq<T>) returns (result: seq<T>)\n    ensures |result| == |data|\n    ensures forall i :: 0 <= i < |data| ==> result[i] == data[i]\n  {\n    result := data;\n  }\n  \n  predicate ValidSpecification(spec: ProductSpecification)\n  {\n    spec.name != \"\" && spec.value != \"\"\n  }\n  \n  method UpdateMainData(productId: int, newProduct: Product,\n                       newSpecs: seq<ProductSpecification>)\n    returns (success: bool)\n    modifies this`products, this`specifications\n    requires productId in products\n    ensures success ==> productId in products && products[productId] == newProduct\n    ensures success ==> productId in specifications && specifications[productId] == newSpecs\n    ensures !success ==> products == old(products) && specifications == old(specifications)\n  {\n    \n    var allSpecsValid := true;\n    var i := 0;\n    while i < |newSpecs|\n      invariant 0 <= i <= |newSpecs|\n      invariant allSpecsValid <==> forall j :: 0 <= j < i ==> ValidSpecification(newSpecs[j])\n    {\n      if !ValidSpecification(newSpecs[i]) {\n        allSpecsValid := false;\n        break;\n      }\n      i := i + 1;\n    }\n    if allSpecsValid {\n      products := products[productId := newProduct];\n      specifications := specifications[productId := newSpecs];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}", "name": "py2dfy_196", "id": 196}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module BookManagementSystem {\n    function PER_PAGE(): nat\n    {\n        15\n    }\n    \n    function RECENT_BOOK_COUNT(): nat\n    {\n        30\n    }\n    \n    function BEANS_UPLOAD_ONE_BOOK(): real\n    {\n        0.5\n    }\n    method CalculateBeansForBooks(numBooks: nat) returns (totalBeans: real)\n    {\n        totalBeans := numBooks as real * BEANS_UPLOAD_ONE_BOOK();\n    }\n    method CalculatePaginationPages(totalItems: nat) returns (pages: nat)\n                        else (totalItems + PER_PAGE() - 1) / PER_PAGE()\n    {\n        if totalItems == 0 {\n            pages := 0;\n        } else {\n            pages := (totalItems + PER_PAGE() - 1) / PER_PAGE();\n        }\n    }\n}", "output": "module BookManagementSystem {\n    function PER_PAGE(): nat\n    {\n        15\n    }\n    \n    function RECENT_BOOK_COUNT(): nat\n    {\n        30\n    }\n    \n    function BEANS_UPLOAD_ONE_BOOK(): real\n    {\n        0.5\n    }\n    method CalculateBeansForBooks(numBooks: nat) returns (totalBeans: real)\n        ensures totalBeans == numBooks as real * BEANS_UPLOAD_ONE_BOOK()\n        ensures totalBeans >= 0.0\n    {\n        totalBeans := numBooks as real * BEANS_UPLOAD_ONE_BOOK();\n    }\n    method CalculatePaginationPages(totalItems: nat) returns (pages: nat)\n        ensures pages == if totalItems == 0 then 0 \n                        else (totalItems + PER_PAGE() - 1) / PER_PAGE()\n        ensures pages >= 0\n    {\n        if totalItems == 0 {\n            pages := 0;\n        } else {\n            pages := (totalItems + PER_PAGE() - 1) / PER_PAGE();\n        }\n    }\n}", "name": "py2dfy_198", "id": 198}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module MD5FileHash {\n    \n    class File {\n        var content: seq<int>\n        \n        constructor()\n        {\n            content := [];\n        }\n    }\n    \n    function ComputeMD5(data: seq<int>): seq<int>\n    {\n        \n        seq(16, i => 0)\n    }\n    \n    \n    method ReadFileChunks(filename: string) returns (file: File?)\n    {\n        if !FileExists(filename) {\n            return null;\n        }\n        var f := new File();\n        \n        \n        return f;\n    }\n    \n    predicate FileExists(filename: string)\n    {\n        true \n    }\n    \n    method ComputeFileMD5(filename: string) returns (result: string)\n    {\n        var file := ReadFileChunks(filename);\n        \n        if file == null {\n            return filename + \" is not exists.\";\n        }\n        \n        \n        var hash := ComputeMD5(file.content);\n        \n        \n        result := BytesToHexString(hash);\n        \n        return result;\n    }\n    \n    method BytesToHexString(bytes: seq<int>) returns (hex: string)\n    {\n        \n        \n        var zeros := \"0\";\n        var result := \"\";\n        var i := 0;\n        while i < 32\n        {\n            result := result + zeros;\n            i := i + 1;\n        }\n        return result;\n    }\n}", "output": "module MD5FileHash {\n    \n    class File {\n        var content: seq<int>\n        \n        constructor()\n            ensures content == []\n        {\n            content := [];\n        }\n    }\n    \n    function ComputeMD5(data: seq<int>): seq<int>\n        ensures |ComputeMD5(data)| == 16  \n    {\n        \n        seq(16, i => 0)\n    }\n    \n    \n    method ReadFileChunks(filename: string) returns (file: File?)\n        ensures file == null ==> !FileExists(filename)\n        ensures file != null ==> FileExists(filename)\n        ensures file != null ==> |file.content| >= 0\n    {\n        if !FileExists(filename) {\n            return null;\n        }\n        var f := new File();\n        \n        \n        return f;\n    }\n    \n    predicate FileExists(filename: string)\n    {\n        true \n    }\n    \n    method ComputeFileMD5(filename: string) returns (result: string)\n        ensures FileExists(filename) ==> |result| == 32  \n        ensures !FileExists(filename) ==> result == filename + \" is not exists.\"\n    {\n        var file := ReadFileChunks(filename);\n        \n        if file == null {\n            return filename + \" is not exists.\";\n        }\n        \n        \n        var hash := ComputeMD5(file.content);\n        \n        \n        result := BytesToHexString(hash);\n        \n        return result;\n    }\n    \n    method BytesToHexString(bytes: seq<int>) returns (hex: string)\n        requires |bytes| == 16  \n        ensures |hex| == 32     \n    {\n        \n        \n        var zeros := \"0\";\n        var result := \"\";\n        var i := 0;\n        while i < 32\n            invariant 0 <= i <= 32\n            invariant |result| == i\n        {\n            result := result + zeros;\n            i := i + 1;\n        }\n        return result;\n    }\n}", "name": "py2dfy_231", "id": 231}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype HackerEntry = HackerEntry(\n  ticket_type: string,\n  order_ref: string,\n  shirt_size: string,\n  school: string,\n  checkin_first: string,\n  checkin_last: string\n)\ndatatype ShirtCounts = ShirtCounts(\n  Total: int,\n  Male: int,\n  MaleXS: int, MaleS: int, MaleM: int, MaleL: int, MaleXL: int,\n  Female: int,\n  FemaleXS: int, FemaleS: int, FemaleM: int, FemaleL: int, FemaleXL: int,\n  None: int\n)\nmethod GetHackers() returns (hackers: seq<HackerEntry>)\n{\n  \n  hackers := [];  \n}\nmethod GetShirts(hackers: seq<HackerEntry>) returns (counts: ShirtCounts)\n{\n  var malexs, males, malem, malel, malexl := 0, 0, 0, 0, 0;\n  var femalexs, females, femalem, femalel, femalexl := 0, 0, 0, 0, 0;\n  var other := 0;\n  var i := 0;\n  \n  while i < |hackers|\n    \n    \n              femalexs + females + femalem + femalel + femalexl + other == i\n  {\n    var entry := hackers[i];\n    if entry.shirt_size == \"Male XS\" { malexs := malexs + 1; }\n    else if entry.shirt_size == \"Male S\" { males := males + 1; }\n    else if entry.shirt_size == \"Male M\" { malem := malem + 1; }\n    else if entry.shirt_size == \"Male L\" { malel := malel + 1; }\n    else if entry.shirt_size == \"Male XL\" { malexl := malexl + 1; }\n    else if entry.shirt_size == \"Female XS\" { femalexs := femalexs + 1; }\n    else if entry.shirt_size == \"Female S\" { females := females + 1; }\n    else if entry.shirt_size == \"Female M\" { femalem := femalem + 1; }\n    else if entry.shirt_size == \"Female L\" { femalel := femalel + 1; }\n    else if entry.shirt_size == \"Female XL\" { femalexl := femalexl + 1; }\n    else { other := other + 1; }\n    \n    i := i + 1;\n  }\n  var male_total := malexs + males + malem + malel + malexl;\n  var female_total := femalexs + females + femalem + femalel + femalexl;\n  var total := male_total + female_total + other;\n  counts := ShirtCounts(\n    total,\n    male_total,\n    malexs, males, malem, malel, malexl,\n    female_total,\n    femalexs, females, femalem, femalel, femalexl,\n    other\n  );\n}", "output": "datatype HackerEntry = HackerEntry(\n  ticket_type: string,\n  order_ref: string,\n  shirt_size: string,\n  school: string,\n  checkin_first: string,\n  checkin_last: string\n)\ndatatype ShirtCounts = ShirtCounts(\n  Total: int,\n  Male: int,\n  MaleXS: int, MaleS: int, MaleM: int, MaleL: int, MaleXL: int,\n  Female: int,\n  FemaleXS: int, FemaleS: int, FemaleM: int, FemaleL: int, FemaleXL: int,\n  None: int\n)\nmethod GetHackers() returns (hackers: seq<HackerEntry>)\n  ensures |hackers| >= 0  \n{\n  \n  hackers := [];  \n}\nmethod GetShirts(hackers: seq<HackerEntry>) returns (counts: ShirtCounts)\n  requires |hackers| >= 0\n  ensures counts.Total == counts.Male + counts.Female + counts.None\n  ensures counts.Male == counts.MaleXS + counts.MaleS + counts.MaleM + counts.MaleL + counts.MaleXL\n  ensures counts.Female == counts.FemaleXS + counts.FemaleS + counts.FemaleM + counts.FemaleL + counts.FemaleXL\n  ensures counts.Total >= 0 && counts.Male >= 0 && counts.Female >= 0 && counts.None >= 0\n{\n  var malexs, males, malem, malel, malexl := 0, 0, 0, 0, 0;\n  var femalexs, females, femalem, femalel, femalexl := 0, 0, 0, 0, 0;\n  var other := 0;\n  var i := 0;\n  \n  while i < |hackers|\n    invariant 0 <= i <= |hackers|\n    \n    invariant malexs >= 0 && males >= 0 && malem >= 0 && malel >= 0 && malexl >= 0\n    invariant femalexs >= 0 && females >= 0 && femalem >= 0 && femalel >= 0 && femalexl >= 0\n    invariant other >= 0\n    \n    invariant malexs + males + malem + malel + malexl + \n              femalexs + females + femalem + femalel + femalexl + other == i\n  {\n    var entry := hackers[i];\n    if entry.shirt_size == \"Male XS\" { malexs := malexs + 1; }\n    else if entry.shirt_size == \"Male S\" { males := males + 1; }\n    else if entry.shirt_size == \"Male M\" { malem := malem + 1; }\n    else if entry.shirt_size == \"Male L\" { malel := malel + 1; }\n    else if entry.shirt_size == \"Male XL\" { malexl := malexl + 1; }\n    else if entry.shirt_size == \"Female XS\" { femalexs := femalexs + 1; }\n    else if entry.shirt_size == \"Female S\" { females := females + 1; }\n    else if entry.shirt_size == \"Female M\" { femalem := femalem + 1; }\n    else if entry.shirt_size == \"Female L\" { femalel := femalel + 1; }\n    else if entry.shirt_size == \"Female XL\" { femalexl := femalexl + 1; }\n    else { other := other + 1; }\n    \n    i := i + 1;\n  }\n  var male_total := malexs + males + malem + malel + malexl;\n  var female_total := femalexs + females + femalem + femalel + femalexl;\n  var total := male_total + female_total + other;\n  counts := ShirtCounts(\n    total,\n    male_total,\n    malexs, males, malem, malel, malexl,\n    female_total,\n    femalexs, females, femalem, femalel, femalexl,\n    other\n  );\n}", "name": "py2dfy_212", "id": 212}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintMessages()\n  \n  \n  \n{\n  \n  print \"hello world\\n\";\n  print \"lol\\n\";\n  print \"new changes in vis\\n\";\n}\nmethod Main() {\n  PrintMessages();\n}", "output": "method PrintMessages()\n  \n  \n  \n  ensures true  \n{\n  \n  print \"hello world\\n\";\n  print \"lol\\n\";\n  print \"new changes in vis\\n\";\n}\nmethod Main() {\n  PrintMessages();\n}", "name": "py2dfy_211", "id": 211}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Count() {\n    \n    var i: int := 0;\n    while i < 10\n        \n    {\n        print i, \"\\n\";\n        i := i + 1;\n    }\n}\nmethod RemoveSpaces(text: string) returns (result: string)\n    \n{\n    var textWithoutSpaces := \"\";\n    var currentText := text;\n    \n    while |currentText| > 0\n        \n    {\n        var nextChar := currentText[0];\n        if nextChar != ' ' {\n            textWithoutSpaces := textWithoutSpaces + [nextChar];\n        }\n        currentText := currentText[1..];\n    }\n    return textWithoutSpaces;\n}\nmethod PrintNumbers(n: int)\n{\n    var count := 1;\n    while count <= n\n        \n    {\n        print count, \"\\n\";\n        count := count + 1;\n    }\n}\nmethod Main() {\n    Count();\n    var result := RemoveSpaces(\"hello my name is andy how are you?\");\n    print result, \"\\n\";\n    PrintNumbers(3);\n}", "output": "method Count() {\n    \n    var i: int := 0;\n    while i < 10\n        \n        invariant 0 <= i <= 10\n    {\n        print i, \"\\n\";\n        i := i + 1;\n    }\n}\nmethod RemoveSpaces(text: string) returns (result: string)\n    \n    ensures |result| <= |text|  \n    ensures forall i :: 0 <= i < |result| ==> result[i] != ' '  \n{\n    var textWithoutSpaces := \"\";\n    var currentText := text;\n    \n    while |currentText| > 0\n        \n        invariant |textWithoutSpaces| <= |text| - |currentText|\n        invariant forall i :: 0 <= i < |textWithoutSpaces| ==> textWithoutSpaces[i] != ' '\n    {\n        var nextChar := currentText[0];\n        if nextChar != ' ' {\n            textWithoutSpaces := textWithoutSpaces + [nextChar];\n        }\n        currentText := currentText[1..];\n    }\n    return textWithoutSpaces;\n}\nmethod PrintNumbers(n: int)\n    requires n >= 0  \n{\n    var count := 1;\n    while count <= n\n        \n        invariant 1 <= count <= n + 1\n    {\n        print count, \"\\n\";\n        count := count + 1;\n    }\n}\nmethod Main() {\n    Count();\n    var result := RemoveSpaces(\"hello my name is andy how are you?\");\n    print result, \"\\n\";\n    PrintNumbers(3);\n}", "name": "py2dfy_264", "id": 264}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Month = Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec\nclass LogEntry {\n  var requestPath: string\n  constructor(path: string) \n  {\n    requestPath := path;\n  }\n}\nclass LogStats {\n  \n}\nmethod FindMostRequestedFile(entries: seq<LogEntry>) returns (path: string, count: int)\n{\n  var countMap: map<string, int> := map[];\n  var maxCount := 0;\n  var maxPath := entries[0].requestPath;\n  \n  countMap := countMap[maxPath := 1];\n  maxCount := 1;\n  \n  var i := 1;\n  while i < |entries|\n  {\n    var currentPath := entries[i].requestPath;\n    \n    if currentPath in countMap {\n      countMap := countMap[currentPath := countMap[currentPath] + 1];\n    } else {\n      countMap := countMap[currentPath := 1];\n    }\n    \n    if countMap[currentPath] > maxCount {\n      maxCount := countMap[currentPath];\n      maxPath := currentPath;\n    }\n    \n    i := i + 1;\n  }\n  \n  return maxPath, maxCount;\n}", "output": "datatype Month = Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec\nclass LogEntry {\n  var requestPath: string\n  constructor(path: string) \n    ensures requestPath == path\n  {\n    requestPath := path;\n  }\n}\nclass LogStats {\n  \n}\nmethod FindMostRequestedFile(entries: seq<LogEntry>) returns (path: string, count: int)\n  requires |entries| > 0 \n  ensures count > 0\n{\n  var countMap: map<string, int> := map[];\n  var maxCount := 0;\n  var maxPath := entries[0].requestPath;\n  \n  countMap := countMap[maxPath := 1];\n  maxCount := 1;\n  \n  var i := 1;\n  while i < |entries|\n    invariant 1 <= i <= |entries|\n    invariant maxCount > 0\n    invariant maxPath in countMap\n    invariant countMap[maxPath] == maxCount\n    invariant forall p :: p in countMap ==> countMap[p] <= maxCount\n  {\n    var currentPath := entries[i].requestPath;\n    \n    if currentPath in countMap {\n      countMap := countMap[currentPath := countMap[currentPath] + 1];\n    } else {\n      countMap := countMap[currentPath := 1];\n    }\n    \n    if countMap[currentPath] > maxCount {\n      maxCount := countMap[currentPath];\n      maxPath := currentPath;\n    }\n    \n    i := i + 1;\n  }\n  \n  return maxPath, maxCount;\n}", "name": "py2dfy_263", "id": 263}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CheckSumEquality(first_number: int, second_number: int, third_number: int) returns (result: string)\n          result == \"Cумма первых двух чисел не равна третьему\"\n{\n  var sum := first_number + second_number;\n  if sum == third_number {\n    result := \"Сумма первых двух чисел равна третьему\";\n  } else {\n    result := \"Cумма первых двух чисел не равна третьему\";\n  }\n}\nmethod Main()\n{\n  var first, second, third: int;\n  print \"Введите первое число: \";\n  first := ReadInt();\n  print \"Введите второе число: \";\n  second := ReadInt();\n  print \"Введите третье число: \";\n  third := ReadInt();\n  var result := CheckSumEquality(first, second, third);\n  print result, \"\\n\";\n}\nmethod ReadInt() returns (n: int)\n{\n  \n  \n  n := 0; \n}", "output": "method CheckSumEquality(first_number: int, second_number: int, third_number: int) returns (result: string)\n  ensures result == \"Сумма первых двух чисел равна третьему\" || \n          result == \"Cумма первых двух чисел не равна третьему\"\n  ensures result == \"Сумма первых двух чисел равна третьему\" <==> first_number + second_number == third_number\n{\n  var sum := first_number + second_number;\n  if sum == third_number {\n    result := \"Сумма первых двух чисел равна третьему\";\n  } else {\n    result := \"Cумма первых двух чисел не равна третьему\";\n  }\n}\nmethod Main()\n{\n  var first, second, third: int;\n  print \"Введите первое число: \";\n  first := ReadInt();\n  print \"Введите второе число: \";\n  second := ReadInt();\n  print \"Введите третье число: \";\n  third := ReadInt();\n  var result := CheckSumEquality(first, second, third);\n  print result, \"\\n\";\n}\nmethod ReadInt() returns (n: int)\n{\n  \n  \n  n := 0; \n}", "name": "py2dfy_230", "id": 230}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function Factorial(n: int): int\n{\n    if n == 0 then \n        1\n    else \n        n * Factorial(n-1)\n}\nmethod ComputeFactorial(n: int) returns (result: int)\n{\n    if n == 0 {\n        return 1;\n    } else {\n        var subResult := ComputeFactorial(n-1);\n        return n * subResult;\n    }\n}\nmethod Main() {\n    var result := ComputeFactorial(5);\n    print \"Factorial(5) = \", result, \"\\n\";\n}", "output": "function Factorial(n: int): int\n    requires n >= 0\n    ensures Factorial(n) > 0 \n    ensures n == 0 ==> Factorial(n) == 1\n    ensures n > 0 ==> Factorial(n) == n * Factorial(n-1)\n    decreases n\n{\n    if n == 0 then \n        1\n    else \n        n * Factorial(n-1)\n}\nmethod ComputeFactorial(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == Factorial(n)\n{\n    if n == 0 {\n        return 1;\n    } else {\n        var subResult := ComputeFactorial(n-1);\n        return n * subResult;\n    }\n}\nmethod Main() {\n    var result := ComputeFactorial(5);\n    print \"Factorial(5) = \", result, \"\\n\";\n}", "name": "py2dfy_245", "id": 245}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module PythonOperators {\n    \n    method AddIntegers(a: int, b: int) returns (result: int)\n    {\n        result := a + b;\n    }\n    \n    method ConcatStrings(s1: string, s2: string) returns (result: string)\n    {\n        result := s1 + s2;\n    }\n    \n    method SubtractIntegers(a: int, b: int) returns (result: int) \n    {\n        result := a - b;\n    }\n    \n    method MultiplyIntegers(a: int, b: int) returns (result: int)\n    {\n        result := a * b;\n    }\n    \n    method RepeatString(s: string, n: int) returns (result: string)\n    {\n        if n == 0 {\n            result := \"\";\n        } else {\n            var temp := s;\n            result := \"\";\n            var i := 0;\n            \n            \n            while i < n\n            {\n                result := result + s;\n                i := i + 1;\n            }\n        }\n    }\n    \n    method DivideReals(a: real, b: real) returns (result: real)\n    {\n        result := a / b;\n    }\n    \n    function Power(base: int, exponent: int): int\n    {\n        if exponent == 0 then\n            1\n        else \n            base * Power(base, exponent-1)\n    }\n    \n    method LessThan(a: int, b: int) returns (result: bool)\n    {\n        result := a < b;\n    }\n    \n    method Main()\n    {\n        \n        var sum := AddIntegers(7, 8);\n        print \"7 + 8 = \", sum, \"\\n\";\n        \n        var concat := ConcatStrings(\"GOOD\", \"Job\");\n        print \"GOOD + Job = \", concat, \"\\n\";\n        \n        var neg := SubtractIntegers(0, 7);\n        print \"-7 = \", neg, \"\\n\";\n        \n        var diff := SubtractIntegers(19, 1);\n        print \"19 - 1 = \", diff, \"\\n\";\n        \n        var prod := MultiplyIntegers(4, 7);\n        print \"4 * 7 = \", prod, \"\\n\";\n        \n        var repeated := RepeatString(\"hello\", 7);\n        print \"hello * 7 = \", repeated, \"\\n\";\n        \n        var power := Power(2, 3);\n        print \"2 ** 3 = \", power, \"\\n\";\n        \n        var less := LessThan(3, 7);\n        print \"3 < 7 = \", less, \"\\n\";\n    }\n}", "output": "module PythonOperators {\n    \n    method AddIntegers(a: int, b: int) returns (result: int)\n    ensures result == a + b  \n    {\n        result := a + b;\n    }\n    \n    method ConcatStrings(s1: string, s2: string) returns (result: string)\n    ensures result == s1 + s2  \n    {\n        result := s1 + s2;\n    }\n    \n    method SubtractIntegers(a: int, b: int) returns (result: int) \n    ensures result == a - b  \n    {\n        result := a - b;\n    }\n    \n    method MultiplyIntegers(a: int, b: int) returns (result: int)\n    ensures result == a * b  \n    {\n        result := a * b;\n    }\n    \n    method RepeatString(s: string, n: int) returns (result: string)\n    requires n >= 0  \n    ensures |result| == |s| * n  \n    {\n        if n == 0 {\n            result := \"\";\n        } else {\n            var temp := s;\n            result := \"\";\n            var i := 0;\n            \n            \n            while i < n\n                invariant 0 <= i <= n\n                invariant |result| == |s| * i\n            {\n                result := result + s;\n                i := i + 1;\n            }\n        }\n    }\n    \n    method DivideReals(a: real, b: real) returns (result: real)\n    requires b != 0.0  \n    ensures result == a / b  \n    {\n        result := a / b;\n    }\n    \n    function Power(base: int, exponent: int): int\n    requires exponent >= 0  \n    ensures exponent == 0 ==> Power(base, exponent) == 1  \n    ensures exponent > 0 ==> Power(base, exponent) == base * Power(base, exponent-1)  \n    {\n        if exponent == 0 then\n            1\n        else \n            base * Power(base, exponent-1)\n    }\n    \n    method LessThan(a: int, b: int) returns (result: bool)\n    ensures result <==> a < b  \n    {\n        result := a < b;\n    }\n    \n    method Main()\n    {\n        \n        var sum := AddIntegers(7, 8);\n        print \"7 + 8 = \", sum, \"\\n\";\n        \n        var concat := ConcatStrings(\"GOOD\", \"Job\");\n        print \"GOOD + Job = \", concat, \"\\n\";\n        \n        var neg := SubtractIntegers(0, 7);\n        print \"-7 = \", neg, \"\\n\";\n        \n        var diff := SubtractIntegers(19, 1);\n        print \"19 - 1 = \", diff, \"\\n\";\n        \n        var prod := MultiplyIntegers(4, 7);\n        print \"4 * 7 = \", prod, \"\\n\";\n        \n        var repeated := RepeatString(\"hello\", 7);\n        print \"hello * 7 = \", repeated, \"\\n\";\n        \n        var power := Power(2, 3);\n        print \"2 ** 3 = \", power, \"\\n\";\n        \n        var less := LessThan(3, 7);\n        print \"3 < 7 = \", less, \"\\n\";\n    }\n}", "name": "py2dfy_219", "id": 219}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype LayerType = FullyConnected | Convolutional | Other\nclass Layer {\n  var numUnits: int\n  var layerType: LayerType \n  var useBias: bool\n  var name: string\n  constructor(units: int, lType: LayerType, useB: bool, n: string)\n  {\n    numUnits := units;\n    layerType := lType;\n    useBias := useB;\n    name := n;\n  }\n}\nclass NeuralNetwork {\n  var layers: seq<Layer>\n  constructor()\n  {\n    layers := [];\n  }\n  method AddNewDenseLayer(numUnits: int, useBias: bool, name: string) returns (success: bool)\n  {\n    var newLayer := new Layer(numUnits, LayerType.FullyConnected, useBias, name);\n    layers := layers + [newLayer];\n    success := true;\n  }\n  method GetNumberOfLayers() returns (count: int)\n  {\n    return |layers|;\n  }\n}", "output": "datatype LayerType = FullyConnected | Convolutional | Other\nclass Layer {\n  var numUnits: int\n  var layerType: LayerType \n  var useBias: bool\n  var name: string\n  constructor(units: int, lType: LayerType, useB: bool, n: string)\n    requires units > 0\n    ensures numUnits == units\n    ensures layerType == lType \n    ensures useBias == useB\n    ensures name == n\n  {\n    numUnits := units;\n    layerType := lType;\n    useBias := useB;\n    name := n;\n  }\n}\nclass NeuralNetwork {\n  var layers: seq<Layer>\n  constructor()\n    ensures layers == []\n  {\n    layers := [];\n  }\n  method AddNewDenseLayer(numUnits: int, useBias: bool, name: string) returns (success: bool)\n    requires numUnits > 0\n    modifies this\n    ensures success ==> |layers| == old(|layers|) + 1\n    ensures !success ==> layers == old(layers)\n    ensures success ==> fresh(layers[|layers|-1])\n    ensures success ==> layers[|layers|-1].numUnits == numUnits\n    ensures success ==> layers[|layers|-1].layerType == LayerType.FullyConnected\n    ensures success ==> layers[|layers|-1].useBias == useBias\n    ensures success ==> layers[|layers|-1].name == name\n    ensures success\n  {\n    var newLayer := new Layer(numUnits, LayerType.FullyConnected, useBias, name);\n    layers := layers + [newLayer];\n    success := true;\n    assert newLayer.numUnits == numUnits;\n    assert newLayer.layerType == LayerType.FullyConnected;\n    assert newLayer.useBias == useBias;\n    assert newLayer.name == name;\n  }\n  method GetNumberOfLayers() returns (count: int)\n    ensures count == |layers|\n  {\n    return |layers|;\n  }\n}", "name": "py2dfy_225", "id": 225}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype DockerConfig = DockerConfig(dockerfile: string, imageName: string)\nclass DockerManager {\n    \n    var dockerConfigs: seq<DockerConfig>\n    \n    var username: string\n    var password: string\n    \n    \n    ghost predicate Valid()\n    {\n        |dockerConfigs| >= 0 &&\n        |username| >= 0 &&\n        |password| >= 0\n    }\n    constructor()\n    {\n        dockerConfigs := [];\n        username := \"\";\n        password := \"\";\n    }\n    \n    method SetCredentials(user: string, pass: string)\n    {\n        username := user;\n        password := pass;\n    }\n    \n    method InitializeConfigs()\n    {\n        dockerConfigs := [\n            DockerConfig(\"Dockerfile.ubuntu1804\", \"ubuntu1804_ansible_testinfra\"),\n            DockerConfig(\"Dockerfile.ubuntu1604\", \"ubuntu1604_ansible_testinfra\")\n        ];\n    }\n    \n    method ProcessDockerOperations() returns (success: bool)\n    {\n        \n        var loginSuccess := DockerLogin(username, password);\n        if !loginSuccess {\n            return false;\n        }\n        \n        success := BuildAndPushImages();\n    }\n    \n    method DockerLogin(user: string, pass: string) returns (success: bool)\n    {\n        \n        success := true;  \n    }\n    \n    method BuildAndPushImages() returns (success: bool)\n    {\n        var i := 0;\n        success := true;\n        \n        while i < |dockerConfigs|\n        {\n            var config := dockerConfigs[i];\n            \n            \n            var buildSuccess := BuildImage(config);\n            if !buildSuccess {\n                success := false;\n                return;\n            }\n            \n            var pushSuccess := PushImage(config);\n            if !pushSuccess {\n                success := false;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method BuildImage(config: DockerConfig) returns (success: bool)\n    {\n        success := true;  \n    }\n    \n    method PushImage(config: DockerConfig) returns (success: bool)\n    {\n        success := true;  \n    }\n}", "output": "datatype DockerConfig = DockerConfig(dockerfile: string, imageName: string)\nclass DockerManager {\n    \n    var dockerConfigs: seq<DockerConfig>\n    \n    var username: string\n    var password: string\n    \n    \n    ghost predicate Valid()\n    reads this\n    {\n        |dockerConfigs| >= 0 &&\n        |username| >= 0 &&\n        |password| >= 0\n    }\n    constructor()\n    ensures Valid()\n    ensures fresh(this)\n    ensures dockerConfigs == []\n    {\n        dockerConfigs := [];\n        username := \"\";\n        password := \"\";\n    }\n    \n    method SetCredentials(user: string, pass: string)\n    requires |user| >= 0 && |pass| >= 0\n    modifies this\n    ensures username == user\n    ensures password == pass\n    ensures Valid()\n    {\n        username := user;\n        password := pass;\n    }\n    \n    method InitializeConfigs()\n    modifies this\n    ensures Valid()\n    ensures |dockerConfigs| == 2  \n    ensures dockerConfigs[0].dockerfile == \"Dockerfile.ubuntu1804\"\n    ensures dockerConfigs[0].imageName == \"ubuntu1804_ansible_testinfra\"\n    ensures dockerConfigs[1].dockerfile == \"Dockerfile.ubuntu1604\"\n    ensures dockerConfigs[1].imageName == \"ubuntu1604_ansible_testinfra\"\n    {\n        dockerConfigs := [\n            DockerConfig(\"Dockerfile.ubuntu1804\", \"ubuntu1804_ansible_testinfra\"),\n            DockerConfig(\"Dockerfile.ubuntu1604\", \"ubuntu1604_ansible_testinfra\")\n        ];\n    }\n    \n    method ProcessDockerOperations() returns (success: bool)\n    requires Valid()\n    requires |dockerConfigs| > 0\n    requires username != \"\"\n    requires password != \"\"\n    ensures Valid()\n    {\n        \n        var loginSuccess := DockerLogin(username, password);\n        if !loginSuccess {\n            return false;\n        }\n        \n        success := BuildAndPushImages();\n    }\n    \n    method DockerLogin(user: string, pass: string) returns (success: bool)\n    requires |user| >= 0 && |pass| >= 0\n    ensures Valid()\n    {\n        \n        success := true;  \n    }\n    \n    method BuildAndPushImages() returns (success: bool)\n    requires Valid()\n    requires |dockerConfigs| > 0\n    requires username != \"\"\n    ensures Valid()\n    {\n        var i := 0;\n        success := true;\n        \n        while i < |dockerConfigs|\n        invariant 0 <= i <= |dockerConfigs|\n        invariant Valid()\n        decreases |dockerConfigs| - i\n        {\n            var config := dockerConfigs[i];\n            \n            \n            var buildSuccess := BuildImage(config);\n            if !buildSuccess {\n                success := false;\n                return;\n            }\n            \n            var pushSuccess := PushImage(config);\n            if !pushSuccess {\n                success := false;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method BuildImage(config: DockerConfig) returns (success: bool)\n    requires Valid()\n    ensures Valid()\n    {\n        success := true;  \n    }\n    \n    method PushImage(config: DockerConfig) returns (success: bool)\n    requires Valid()\n    ensures Valid()\n    {\n        success := true;  \n    }\n}", "name": "py2dfy_215", "id": 215}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Address = Seoul | Gyeonggi | Chungnam | Chungbuk | Gyeongbuk | Gyeongnam | Jeonbuk | Jeonnam\ndatatype Gender = Female | Male\nclass User {\n  var username: string\n  var password: string\n  var name: string\n  var phoneNumber: string\n  var address: Address\n  var gender: Gender\n  \n  \n  predicate Valid()\n  {\n    |username| > 0 && |username| <= 50 &&\n    |password| > 0 && |password| <= 50 &&\n    |name| > 0 && |name| <= 50 &&\n    |phoneNumber| > 0 && |phoneNumber| <= 50\n  }\n  \n  constructor(un: string, pw: string, n: string, phone: string, addr: Address, gen: Gender)\n  {\n    username := un;\n    password := pw;\n    name := n;\n    phoneNumber := phone;\n    address := addr;\n    gender := gen;\n  }\n}\nclass CartItem {\n  var user: User?\n  var productId: int\n  var quantity: int\n  var active: bool\n  \n  \n  predicate Valid()\n  {\n    quantity >= 1 && quantity <= 100 &&\n    user != null\n  }\n  \n  constructor(u: User?, pid: int, qty: int)\n  {\n    user := u;\n    productId := pid;\n    quantity := qty;\n    active := false;\n  }\n  \n  method UpdateQuantity(newQty: int) returns (success: bool)\n  {\n    quantity := newQty;\n    success := true;\n  }\n}", "output": "datatype Address = Seoul | Gyeonggi | Chungnam | Chungbuk | Gyeongbuk | Gyeongnam | Jeonbuk | Jeonnam\ndatatype Gender = Female | Male\nclass User {\n  var username: string\n  var password: string\n  var name: string\n  var phoneNumber: string\n  var address: Address\n  var gender: Gender\n  \n  \n  predicate Valid()\n  reads this\n  {\n    |username| > 0 && |username| <= 50 &&\n    |password| > 0 && |password| <= 50 &&\n    |name| > 0 && |name| <= 50 &&\n    |phoneNumber| > 0 && |phoneNumber| <= 50\n  }\n  \n  constructor(un: string, pw: string, n: string, phone: string, addr: Address, gen: Gender)\n  requires |un| > 0 && |un| <= 50\n  requires |pw| > 0 && |pw| <= 50\n  requires |n| > 0 && |n| <= 50\n  requires |phone| > 0 && |phone| <= 50\n  ensures Valid()\n  ensures username == un && password == pw && name == n && phoneNumber == phone\n  ensures address == addr && gender == gen\n  {\n    username := un;\n    password := pw;\n    name := n;\n    phoneNumber := phone;\n    address := addr;\n    gender := gen;\n  }\n}\nclass CartItem {\n  var user: User?\n  var productId: int\n  var quantity: int\n  var active: bool\n  \n  \n  predicate Valid()\n  reads this\n  {\n    quantity >= 1 && quantity <= 100 &&\n    user != null\n  }\n  \n  constructor(u: User?, pid: int, qty: int)\n  requires qty >= 1 && qty <= 100\n  requires u != null\n  ensures Valid()\n  ensures user == u && productId == pid && quantity == qty\n  ensures active == false  \n  {\n    user := u;\n    productId := pid;\n    quantity := qty;\n    active := false;\n  }\n  \n  method UpdateQuantity(newQty: int) returns (success: bool)\n  requires Valid()\n  requires newQty >= 1 && newQty <= 100\n  modifies this\n  ensures Valid()\n  ensures success ==> quantity == newQty\n  ensures !success ==> quantity == old(quantity)\n  {\n    quantity := newQty;\n    success := true;\n  }\n}", "name": "py2dfy_221", "id": 221}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module EmbryoGeneratorModel {\n  \n  class Generator {\n    \n    var parameters: seq<real>\n    var isInitialized: bool\n    \n    \n    constructor Init()\n    {\n      parameters := [];\n      isInitialized := false;\n    }\n    \n    \n    method Initialize(params: seq<real>) \n    {\n      parameters := params;\n      isInitialized := true;\n    }\n    \n    \n    method Generate(input: seq<real>) returns (output: seq<real>)\n    {\n      \n      output := input;  \n    }\n    \n    \n    method ProcessBatch(inputs: seq<seq<real>>) returns (outputs: seq<seq<real>>)\n    {\n      var i := 0;\n      outputs := [];\n      \n      \n      while i < |inputs|\n      {\n        var result := Generate(inputs[i]);\n        outputs := outputs + [result];\n        i := i + 1;\n      }\n    }\n  }\n}", "output": "module EmbryoGeneratorModel {\n  \n  class Generator {\n    \n    var parameters: seq<real>\n    var isInitialized: bool\n    \n    \n    constructor Init()\n      ensures fresh(this)  \n      ensures isInitialized == false\n      ensures |parameters| == 0\n    {\n      parameters := [];\n      isInitialized := false;\n    }\n    \n    \n    method Initialize(params: seq<real>) \n      requires |params| > 0  \n      modifies this\n      ensures isInitialized == true\n      ensures parameters == params\n      ensures |parameters| == |params|\n    {\n      parameters := params;\n      isInitialized := true;\n    }\n    \n    \n    method Generate(input: seq<real>) returns (output: seq<real>)\n      requires isInitialized  \n      requires |input| > 0    \n      ensures |output| > 0    \n      ensures |output| == |input|  \n    {\n      \n      output := input;  \n    }\n    \n    \n    method ProcessBatch(inputs: seq<seq<real>>) returns (outputs: seq<seq<real>>)\n      requires isInitialized\n      requires |inputs| > 0\n      requires forall i :: 0 <= i < |inputs| ==> |inputs[i]| > 0\n      ensures |outputs| == |inputs|\n      ensures forall i :: 0 <= i < |outputs| ==> |outputs[i]| == |inputs[i]|\n    {\n      var i := 0;\n      outputs := [];\n      \n      \n      while i < |inputs|\n        invariant 0 <= i <= |inputs|\n        invariant |outputs| == i\n        invariant forall j :: 0 <= j < i ==> |outputs[j]| == |inputs[j]|\n      {\n        var result := Generate(inputs[i]);\n        outputs := outputs + [result];\n        i := i + 1;\n      }\n    }\n  }\n}", "name": "py2dfy_209", "id": 209}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Line = Line(content: string)\ndatatype File = File(lines: seq<Line>)\nfunction StringToFloat(s: string): real\n{\n  \n  \n  1.0\n}\npredicate Contains(line: Line, substr: string)\n{\n  \n  true\n}\nmethod GetSingleDoc(file: File) returns (result: real)\n{\n  var i := 0;\n  while i < |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Singleton Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetRawDoc(file: File) returns (result: real)\n{\n  var i := 0;\n  while i < |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Raw Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetCollapsedDoc(file: File) returns (result: real)\n{\n  var i := 0;\n  while i < |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Collapsed Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetMeanEGFR(file: File) returns (result: real)\n{\n  var count := 0;\n  var sum := 0.0;\n  \n  var i := 0;\n  while i < |file.lines|\n  {\n    var line := file.lines[i];\n    \n    if !Contains(line, \"#\") && Contains(line, \"EGFR\") {\n      count := count + 1;\n      sum := sum + 1.0; \n    }\n    i := i + 1;\n  }\n  \n  if count > 0 {\n    result := sum / count as real;\n  } else {\n    result := 0.0;\n  }\n}\nmethod ProcessFiles(files: seq<File>) returns (output: seq<string>)\n{\n  var results: seq<string> := [];\n  var i := 0;\n  \n  while i < |files|\n  {\n    var meanDoc := GetCollapsedDoc(files[i]);\n    var rawDoc := GetRawDoc(files[i]);\n    var singleDoc := GetSingleDoc(files[i]);\n    var meanEGFR := GetMeanEGFR(files[i]);\n    \n    \n    var result := \"Result\";  \n    results := results + [result];\n    \n    i := i + 1;\n  }\n  \n  output := results;\n}", "output": "datatype Line = Line(content: string)\ndatatype File = File(lines: seq<Line>)\nfunction StringToFloat(s: string): real\n  requires s != \"\"\n  ensures StringToFloat(s) >= 0.0\n{\n  \n  \n  1.0\n}\npredicate Contains(line: Line, substr: string)\n{\n  \n  true\n}\nmethod GetSingleDoc(file: File) returns (result: real)\n  requires file.lines != []\n  ensures result >= 0.0\n{\n  var i := 0;\n  while i < |file.lines|\n    invariant 0 <= i <= |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Singleton Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetRawDoc(file: File) returns (result: real)\n  requires file.lines != []\n  ensures result >= 0.0\n{\n  var i := 0;\n  while i < |file.lines|\n    invariant 0 <= i <= |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Raw Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetCollapsedDoc(file: File) returns (result: real)\n  requires file.lines != []\n  ensures result >= 0.0\n{\n  var i := 0;\n  while i < |file.lines|\n    invariant 0 <= i <= |file.lines|\n  {\n    if Contains(file.lines[i], \"Mean Collapsed Coverage\") {\n      var parts := file.lines[i].content;\n      \n      if parts != \"\" {\n        result := StringToFloat(parts);\n        return;\n      }\n    }\n    i := i + 1;\n  }\n  result := 0.0;\n}\nmethod GetMeanEGFR(file: File) returns (result: real)\n  requires file.lines != []\n  ensures result >= 0.0\n{\n  var count := 0;\n  var sum := 0.0;\n  \n  var i := 0;\n  while i < |file.lines|\n    invariant 0 <= i <= |file.lines|\n    invariant count >= 0\n    invariant sum >= 0.0\n  {\n    var line := file.lines[i];\n    \n    if !Contains(line, \"#\") && Contains(line, \"EGFR\") {\n      count := count + 1;\n      sum := sum + 1.0; \n    }\n    i := i + 1;\n  }\n  \n  if count > 0 {\n    result := sum / count as real;\n  } else {\n    result := 0.0;\n  }\n}\nmethod ProcessFiles(files: seq<File>) returns (output: seq<string>)\n  requires |files| > 0\n  requires forall i :: 0 <= i < |files| ==> files[i].lines != []\n  ensures |output| == |files|\n{\n  var results: seq<string> := [];\n  var i := 0;\n  \n  while i < |files|\n    invariant 0 <= i <= |files|\n    invariant |results| == i\n  {\n    var meanDoc := GetCollapsedDoc(files[i]);\n    var rawDoc := GetRawDoc(files[i]);\n    var singleDoc := GetSingleDoc(files[i]);\n    var meanEGFR := GetMeanEGFR(files[i]);\n    \n    \n    var result := \"Result\";  \n    results := results + [result];\n    \n    i := i + 1;\n  }\n  \n  output := results;\n}", "name": "py2dfy_205", "id": 205}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method FactorsAddition(value: nat) returns (sum: nat)\n{\n    sum := 0;\n    var i := 1;\n    \n    \n    while i < value\n        \n    {\n        if value % i == 0 {\n            sum := sum + i;\n        }\n        i := i + 1;\n    }\n}\nfunction SumOfFactors(n: nat): nat\n{\n    SumOfFactorsUpTo(n, n-1)\n}\nfunction SumOfFactorsUpTo(n: nat, k: nat): nat\n{\n    if k == 0 then\n        0\n    else\n        (if n % k == 0 then k else 0) + SumOfFactorsUpTo(n, k-1)\n}\nmethod Main() {\n    print \"Enter number: \";\n    \n    \n    var value := 12;  \n    if value > 0 {\n        var result := FactorsAddition(value);\n        print \"Factors Addition of \", value, \" is \", result, \"\\n\";\n    } else {\n        print \"Please enter a positive number\\n\";\n    }\n}", "output": "method FactorsAddition(value: nat) returns (sum: nat)\n    requires value > 0  \n    ensures sum == SumOfFactors(value)  \n{\n    sum := 0;\n    var i := 1;\n    \n    \n    while i < value\n        \n        invariant 1 <= i <= value\n        invariant sum == SumOfFactorsUpTo(value, i-1)\n    {\n        if value % i == 0 {\n            sum := sum + i;\n        }\n        i := i + 1;\n    }\n}\nfunction SumOfFactors(n: nat): nat\n    requires n > 0\n{\n    SumOfFactorsUpTo(n, n-1)\n}\nfunction SumOfFactorsUpTo(n: nat, k: nat): nat\n    requires n > 0\n    requires 0 <= k < n\n{\n    if k == 0 then\n        0\n    else\n        (if n % k == 0 then k else 0) + SumOfFactorsUpTo(n, k-1)\n}\nmethod Main() {\n    print \"Enter number: \";\n    \n    \n    var value := 12;  \n    if value > 0 {\n        var result := FactorsAddition(value);\n        print \"Factors Addition of \", value, \" is \", result, \"\\n\";\n    } else {\n        print \"Please enter a positive number\\n\";\n    }\n}", "name": "py2dfy_255", "id": 255}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Date = Date(year: int, month: int, day: int)\ndatatype Measurement = Measurement(date: Date, name: string, value: real)\ndatatype DataFrame = DataFrame(measurements: seq<Measurement>)\nmethod ProcessPMData(files: seq<string>, startDate: Date, endDate: Date) returns (df: DataFrame)\n        DateInRange(m.date, startDate, endDate)  \n{\n    var allMeasurements: seq<Measurement> := [];\n    \n    \n    var i := 0;\n    while i < |files|\n            DateInRange(m.date, startDate, endDate)\n    {\n        var fileMeasurements := ReadCSVFile(files[i]);\n        var filteredMeasurements := FilterByDateRange(fileMeasurements, startDate, endDate);\n        allMeasurements := allMeasurements + filteredMeasurements;\n        i := i + 1;\n    }\n    \n    df := DataFrame(allMeasurements);\n}\nmethod ReadCSVFile(filename: string) returns (measurements: seq<Measurement>)\n{\n    \n    measurements := [];\n}\nmethod FilterByDateRange(measurements: seq<Measurement>, start: Date, end: Date) \n    returns (filtered: seq<Measurement>)\n{\n    filtered := [];\n    var i := 0;\n    \n    while i < |measurements|\n    {\n        if DateInRange(measurements[i].date, start, end) {\n            filtered := filtered + [measurements[i]];\n        }\n        i := i + 1;\n    }\n}\npredicate DateInRange(d: Date, start: Date, end: Date)\n{\n    DateLessOrEqual(start, d) && DateLessOrEqual(d, end)\n}\npredicate ValidDateRange(start: Date, end: Date)\n{\n    DateLessOrEqual(start, end)\n}\npredicate DateLessOrEqual(d1: Date, d2: Date)\n{\n    d1.year < d2.year ||\n    (d1.year == d2.year && d1.month < d2.month) ||\n    (d1.year == d2.year && d1.month == d2.month && d1.day <= d2.day)\n}", "output": "datatype Date = Date(year: int, month: int, day: int)\ndatatype Measurement = Measurement(date: Date, name: string, value: real)\ndatatype DataFrame = DataFrame(measurements: seq<Measurement>)\nmethod ProcessPMData(files: seq<string>, startDate: Date, endDate: Date) returns (df: DataFrame)\n    requires |files| > 0  \n    requires ValidDateRange(startDate, endDate)  \n    ensures |df.measurements| >= 0  \n    ensures forall m :: m in df.measurements ==> \n        DateInRange(m.date, startDate, endDate)  \n{\n    var allMeasurements: seq<Measurement> := [];\n    \n    \n    var i := 0;\n    while i < |files|\n        invariant 0 <= i <= |files|\n        invariant forall m :: m in allMeasurements ==> \n            DateInRange(m.date, startDate, endDate)\n    {\n        var fileMeasurements := ReadCSVFile(files[i]);\n        var filteredMeasurements := FilterByDateRange(fileMeasurements, startDate, endDate);\n        allMeasurements := allMeasurements + filteredMeasurements;\n        i := i + 1;\n    }\n    \n    df := DataFrame(allMeasurements);\n}\nmethod ReadCSVFile(filename: string) returns (measurements: seq<Measurement>)\n    ensures |measurements| >= 0\n{\n    \n    measurements := [];\n}\nmethod FilterByDateRange(measurements: seq<Measurement>, start: Date, end: Date) \n    returns (filtered: seq<Measurement>)\n    requires ValidDateRange(start, end)\n    ensures forall m :: m in filtered ==> DateInRange(m.date, start, end)\n    ensures |filtered| <= |measurements|\n{\n    filtered := [];\n    var i := 0;\n    \n    while i < |measurements|\n        invariant 0 <= i <= |measurements|\n        invariant forall m :: m in filtered ==> DateInRange(m.date, start, end)\n        invariant |filtered| <= i\n    {\n        if DateInRange(measurements[i].date, start, end) {\n            filtered := filtered + [measurements[i]];\n        }\n        i := i + 1;\n    }\n}\npredicate DateInRange(d: Date, start: Date, end: Date)\n{\n    DateLessOrEqual(start, d) && DateLessOrEqual(d, end)\n}\npredicate ValidDateRange(start: Date, end: Date)\n{\n    DateLessOrEqual(start, end)\n}\npredicate DateLessOrEqual(d1: Date, d2: Date)\n{\n    d1.year < d2.year ||\n    (d1.year == d2.year && d1.month < d2.month) ||\n    (d1.year == d2.year && d1.month == d2.month && d1.day <= d2.day)\n}", "name": "py2dfy_260", "id": 260}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class StatePoint {\n    var T: real    \n    var P: real    \n    var v: real    \n    \n    constructor(temp: real, press: real, vol: real)\n    {\n        T := temp;\n        P := press;\n        v := vol;\n    }\n}\nclass ThermodynamicCalculator {\n    const R: real := 8.314    \n    const gamma: real         \n    const M: real            \n    \n    constructor(g: real, m: real)\n    {\n        gamma := g;\n        M := m;\n    }\n    \n    \n    method CalcIsentropicPressure(v1: real, v2: real, P1: real) returns (P2: real)\n    {\n        P2 := P1 * (v1/v2) * (v1/v2) * (v1/v2);  \n    }\n    \n    \n    method CalcIsentropicTemperature(T1: real, v1: real, v2: real) returns (T2: real)\n    {\n        T2 := T1 * (v1/v2) * (v1/v2);  \n    }\n    \n    \n    method CalcWork(P: array<real>, v: array<real>) returns (W: real)\n    {\n        W := 0.0;\n        var i := 0;\n        \n        while i < P.Length - 1\n        {\n            var dW := (P[i] + P[i+1])/2.0 * (v[i+1] - v[i]);\n            W := W + if dW >= 0.0 then dW else -dW;  \n            i := i + 1;\n        }\n    }\n}\nmethod CalculateIdealGasCycle(\n    T1: real, P1: real, P3: real, T4: real, a: real,\n    calculator: ThermodynamicCalculator\n) returns (cycle: array<StatePoint>)\n{\n    var v1 := calculator.R * T1 / (calculator.M * P1);\n    var point0 := new StatePoint(T1, P1, v1);\n    \n    var v2 := v1 / a;\n    var P2 := calculator.CalcIsentropicPressure(v1, v2, P1);\n    var T2 := calculator.CalcIsentropicTemperature(T1, v1, v2);\n    var point1 := new StatePoint(T2, P2, v2);\n    \n    var T3 := calculator.M * P3 * v2 / calculator.R;\n    var point2 := new StatePoint(T3, P3, v2);\n    \n    var v4 := calculator.R * T4 / (calculator.M * P3);\n    var point3 := new StatePoint(T4, P3, v4);\n    \n    var P5 := calculator.CalcIsentropicPressure(v4, v1, P3);\n    var T5 := calculator.CalcIsentropicTemperature(T4, v4, v1);\n    var point4 := new StatePoint(T5, P5, v1);\n    \n    cycle := new StatePoint[5] [point0, point1, point2, point3, point4];\n}", "output": "class StatePoint {\n    var T: real    \n    var P: real    \n    var v: real    \n    \n    constructor(temp: real, press: real, vol: real)\n    requires temp > 0.0  \n    requires press > 0.0 \n    requires vol > 0.0   \n    ensures T == temp && P == press && v == vol\n    {\n        T := temp;\n        P := press;\n        v := vol;\n    }\n}\nclass ThermodynamicCalculator {\n    const R: real := 8.314    \n    const gamma: real         \n    const M: real            \n    \n    constructor(g: real, m: real)\n    requires g > 1.0  \n    requires m > 0.0  \n    ensures gamma == g && M == m\n    {\n        gamma := g;\n        M := m;\n    }\n    \n    \n    method CalcIsentropicPressure(v1: real, v2: real, P1: real) returns (P2: real)\n    requires v1 > 0.0 && v2 > 0.0 && P1 > 0.0\n    ensures P2 > 0.0\n    {\n        P2 := P1 * (v1/v2) * (v1/v2) * (v1/v2);  \n        assert P2 > 0.0;\n    }\n    \n    \n    method CalcIsentropicTemperature(T1: real, v1: real, v2: real) returns (T2: real)\n    requires T1 > 0.0 && v1 > 0.0 && v2 > 0.0\n    ensures T2 > 0.0\n    {\n        T2 := T1 * (v1/v2) * (v1/v2);  \n        assert T2 > 0.0;\n    }\n    \n    \n    method CalcWork(P: array<real>, v: array<real>) returns (W: real)\n    requires P.Length == v.Length\n    requires P.Length > 1\n    requires forall i :: 0 <= i < P.Length ==> P[i] > 0.0\n    requires forall i :: 0 <= i < v.Length ==> v[i] > 0.0\n    ensures W >= 0.0\n    {\n        W := 0.0;\n        var i := 0;\n        \n        while i < P.Length - 1\n        invariant 0 <= i <= P.Length - 1\n        invariant W >= 0.0\n        decreases P.Length - i\n        {\n            var dW := (P[i] + P[i+1])/2.0 * (v[i+1] - v[i]);\n            W := W + if dW >= 0.0 then dW else -dW;  \n            i := i + 1;\n        }\n    }\n}\nmethod CalculateIdealGasCycle(\n    T1: real, P1: real, P3: real, T4: real, a: real,\n    calculator: ThermodynamicCalculator\n) returns (cycle: array<StatePoint>)\nrequires T1 > 0.0 && P1 > 0.0 && P3 > 0.0 && T4 > 0.0 && a > 1.0\nrequires calculator.M > 0.0\nensures cycle.Length == 5\n{\n    var v1 := calculator.R * T1 / (calculator.M * P1);\n    assert v1 > 0.0;\n    var point0 := new StatePoint(T1, P1, v1);\n    \n    var v2 := v1 / a;\n    assert v2 > 0.0;\n    var P2 := calculator.CalcIsentropicPressure(v1, v2, P1);\n    var T2 := calculator.CalcIsentropicTemperature(T1, v1, v2);\n    var point1 := new StatePoint(T2, P2, v2);\n    \n    var T3 := calculator.M * P3 * v2 / calculator.R;\n    assert T3 > 0.0;\n    var point2 := new StatePoint(T3, P3, v2);\n    \n    var v4 := calculator.R * T4 / (calculator.M * P3);\n    assert v4 > 0.0;\n    var point3 := new StatePoint(T4, P3, v4);\n    \n    var P5 := calculator.CalcIsentropicPressure(v4, v1, P3);\n    var T5 := calculator.CalcIsentropicTemperature(T4, v4, v1);\n    var point4 := new StatePoint(T5, P5, v1);\n    \n    cycle := new StatePoint[5] [point0, point1, point2, point3, point4];\n}", "name": "py2dfy_213", "id": 213}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method SwapStringParts(s: string) returns (result: string)\n  \n  \n{\n  \n  result := s[5..] + \" \" + s[..4];\n}\nmethod Main() {\n  var s := \"Daum KaKao\";\n  var swapped := SwapStringParts(s);\n  print swapped, \"\\n\";  \n}", "output": "method SwapStringParts(s: string) returns (result: string)\n  \n  requires |s| >= 5\n  requires s[4] == ' '  \n  \n  ensures result == s[5..] + \" \" + s[..4]\n{\n  \n  result := s[5..] + \" \" + s[..4];\n}\nmethod Main() {\n  var s := \"Daum KaKao\";\n  var swapped := SwapStringParts(s);\n  print swapped, \"\\n\";  \n}", "name": "py2dfy_243", "id": 243}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method InfiniteRunningLoop()\n{\n  while true \n  {\n    print \"running\\n\";\n  }\n}\nmethod Main()\n{\n  InfiniteRunningLoop();\n}", "output": "method InfiniteRunningLoop()\n  decreases *  \n  ensures false  \n{\n  while true \n    decreases *  \n  {\n    print \"running\\n\";\n  }\n}\nmethod Main()\n  decreases * \n{\n  InfiniteRunningLoop();\n}", "name": "py2dfy_280", "id": 280}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module AudioProcessor {\n    function SimulateExternalCall(text: string): (success: bool)\n    method GetAudio(text: string) returns (result: string)\n    {\n        var success := SimulateExternalCall(text);\n        \n        if success {\n            result := \"Success\";\n        } else {\n            print \"Failed\";\n            result := \"Failed\";\n        }\n    }\n    method Main()\n    {\n        var text := \"我是聊天机器人\";\n        var result := GetAudio(text);\n        print result;\n    }\n}", "output": "module AudioProcessor {\n    function SimulateExternalCall(text: string): (success: bool)\n    method GetAudio(text: string) returns (result: string)\n    requires text != \"\"\n    ensures result == \"Success\" || result == \"Failed\" \n    {\n        var success := SimulateExternalCall(text);\n        \n        if success {\n            result := \"Success\";\n        } else {\n            print \"Failed\";\n            result := \"Failed\";\n        }\n    }\n    method Main()\n    {\n        var text := \"我是聊天机器人\";\n        var result := GetAudio(text);\n        print result;\n    }\n}", "name": "py2dfy_268", "id": 268}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Path = Path(components: seq<string>)\ndatatype ViewFunction = ViewFunction(name: string)\ndatatype URLPattern = URLPattern(path: Path, view: ViewFunction, name: string)\nclass URLRouter {\n    \n    var patterns: seq<URLPattern>\n    \n    ghost predicate Valid()\n    {\n        true \n    }\n    constructor()\n    {\n        patterns := [];\n    }\n    \n    method AddPattern(path: seq<string>, viewName: string, patternName: string)\n    {\n        var newPattern := URLPattern(Path(path), ViewFunction(viewName), patternName);\n        patterns := patterns + [newPattern];\n    }\n    \n    method FindView(urlPath: seq<string>) returns (found: bool, view: ViewFunction)\n    {\n        found := false;\n        view := ViewFunction(\"\");\n        \n        \n        var i := 0;\n        while i < |patterns|\n        {\n            if patterns[i].path.components == urlPath {\n                found := true;\n                view := patterns[i].view;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}\nmethod Main()\n{\n    var router := new URLRouter();\n    \n    \n    var contactPath := [\"contacts\"];\n    router.AddPattern(contactPath, \"contact_view\", \"contact_view\");\n}", "output": "datatype Path = Path(components: seq<string>)\ndatatype ViewFunction = ViewFunction(name: string)\ndatatype URLPattern = URLPattern(path: Path, view: ViewFunction, name: string)\nclass URLRouter {\n    \n    var patterns: seq<URLPattern>\n    \n    ghost predicate Valid()\n        reads this\n    {\n        true \n    }\n    constructor()\n        ensures Valid()\n        ensures fresh(this)\n        ensures patterns == []\n    {\n        patterns := [];\n    }\n    \n    method AddPattern(path: seq<string>, viewName: string, patternName: string)\n        requires Valid()\n        modifies this\n        ensures Valid()\n        ensures |patterns| == |old(patterns)| + 1\n        ensures patterns[|patterns|-1] == URLPattern(Path(path), ViewFunction(viewName), patternName)\n        ensures forall i :: 0 <= i < |old(patterns)| ==> patterns[i] == old(patterns[i])\n    {\n        var newPattern := URLPattern(Path(path), ViewFunction(viewName), patternName);\n        patterns := patterns + [newPattern];\n    }\n    \n    method FindView(urlPath: seq<string>) returns (found: bool, view: ViewFunction)\n        requires Valid()\n        ensures found ==> exists i :: 0 <= i < |patterns| && patterns[i].path.components == urlPath\n        ensures found ==> exists i :: 0 <= i < |patterns| && patterns[i].path.components == urlPath && view == patterns[i].view\n        ensures !found ==> forall i :: 0 <= i < |patterns| ==> patterns[i].path.components != urlPath\n    {\n        found := false;\n        view := ViewFunction(\"\");\n        \n        \n        var i := 0;\n        while i < |patterns|\n            invariant 0 <= i <= |patterns|\n            invariant !found ==> forall k :: 0 <= k < i ==> patterns[k].path.components != urlPath\n        {\n            if patterns[i].path.components == urlPath {\n                found := true;\n                view := patterns[i].view;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}\nmethod Main()\n{\n    var router := new URLRouter();\n    \n    \n    var contactPath := [\"contacts\"];\n    router.AddPattern(contactPath, \"contact_view\", \"contact_view\");\n}", "name": "py2dfy_222", "id": 222}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module Ploneboard {\n    \n    trait Message {\n        var content: string\n        var author: string\n        ghost var Valid: bool  \n        predicate ValidState()\n        {\n            |content| > 0 && |author| > 0\n        }\n        \n        method Init(c: string, a: string)\n        {\n            content := c;\n            author := a;\n            Valid := true;\n        }\n    }\n    \n    class Comment extends Message {\n        var timestamp: nat\n        \n        constructor(c: string, a: string, time: nat)\n        {\n            content := c;\n            author := a;\n            Valid := true;\n            timestamp := time;\n        }\n    }\n    \n    class Conversation {\n        var comments: seq<Comment?>\n        var title: string\n        \n        predicate ValidState()\n        {\n            |title| > 0 &&\n            forall i :: 0 <= i < |comments| ==> comments[i] != null\n        }\n        constructor(t: string)\n        {\n            title := t;\n            comments := [];\n        }\n        \n        method AddComment(c: Comment?)\n                comments[i] == old(comments[i])\n        {\n            comments := comments + [c];\n        }\n        \n        method GetCommentCount() returns (count: nat)\n        {\n            return |comments|;\n        }\n    }\n    \n    class Forum {\n        var conversations: seq<Conversation?>\n        var name: string\n        predicate ValidState()\n        {\n            |name| > 0 &&\n            forall i :: 0 <= i < |conversations| ==> conversations[i] != null\n        }\n        constructor(n: string)\n        {\n            name := n;\n            conversations := [];\n        }\n        \n        method AddConversation(conv: Conversation?)\n                conversations[i] == old(conversations[i])\n        {\n            conversations := conversations + [conv];\n        }\n    }\n}", "output": "module Ploneboard {\n    \n    trait Message {\n        var content: string\n        var author: string\n        ghost var Valid: bool  \n        predicate ValidState()\n            reads this\n        {\n            |content| > 0 && |author| > 0\n        }\n        \n        method Init(c: string, a: string)\n            requires |c| > 0 && |a| > 0 \n            modifies this\n            ensures ValidState()\n            ensures content == c && author == a\n        {\n            content := c;\n            author := a;\n            Valid := true;\n        }\n    }\n    \n    class Comment extends Message {\n        var timestamp: nat\n        \n        constructor(c: string, a: string, time: nat)\n            requires |c| > 0 && |a| > 0\n            ensures ValidState()\n            ensures timestamp == time\n        {\n            content := c;\n            author := a;\n            Valid := true;\n            timestamp := time;\n        }\n    }\n    \n    class Conversation {\n        var comments: seq<Comment?>\n        var title: string\n        \n        predicate ValidState()\n            reads this, comments\n        {\n            |title| > 0 &&\n            forall i :: 0 <= i < |comments| ==> comments[i] != null\n        }\n        constructor(t: string)\n            requires |t| > 0\n            ensures ValidState()\n            ensures title == t\n            ensures |comments| == 0\n        {\n            title := t;\n            comments := [];\n        }\n        \n        method AddComment(c: Comment?)\n            requires c != null\n            requires ValidState()\n            modifies this\n            ensures ValidState()\n            ensures |comments| == old(|comments|) + 1\n            ensures comments[|comments|-1] == c\n            ensures forall i :: 0 <= i < old(|comments|) ==> \n                comments[i] == old(comments[i])\n        {\n            comments := comments + [c];\n        }\n        \n        method GetCommentCount() returns (count: nat)\n            requires ValidState()\n            ensures count == |comments|\n        {\n            return |comments|;\n        }\n    }\n    \n    class Forum {\n        var conversations: seq<Conversation?>\n        var name: string\n        predicate ValidState()\n            reads this, conversations\n        {\n            |name| > 0 &&\n            forall i :: 0 <= i < |conversations| ==> conversations[i] != null\n        }\n        constructor(n: string)\n            requires |n| > 0\n            ensures ValidState()\n            ensures name == n\n            ensures |conversations| == 0\n        {\n            name := n;\n            conversations := [];\n        }\n        \n        method AddConversation(conv: Conversation?)\n            requires conv != null\n            requires ValidState()\n            modifies this\n            ensures ValidState()\n            ensures |conversations| == old(|conversations|) + 1\n            ensures conversations[|conversations|-1] == conv\n            ensures forall i :: 0 <= i < old(|conversations|) ==> \n                conversations[i] == old(conversations[i])\n        {\n            conversations := conversations + [conv];\n        }\n    }\n}", "name": "py2dfy_218", "id": 218}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Function {\n  \n  var executed: bool\n  constructor()\n  {\n    executed := false;\n  }\n  \n  method Execute()\n  {\n    executed := true;\n  }\n}\nclass BThread {\n  \n  var func: Function?\n  constructor(f: Function?)\n  {\n    func := f;\n  }\n  \n  method Run()\n  {\n    func.Execute();\n  }\n}\nmethod Main() {\n  var f := new Function();\n  var thread := new BThread(f);\n  thread.Run();\n}", "output": "class Function {\n  \n  var executed: bool\n  constructor()\n    ensures executed == false\n  {\n    executed := false;\n  }\n  \n  method Execute()\n    modifies this\n    ensures executed == true\n  {\n    executed := true;\n  }\n}\nclass BThread {\n  \n  var func: Function?\n  constructor(f: Function?)\n    ensures func == f  \n  {\n    func := f;\n  }\n  \n  method Run()\n    requires func != null  \n    modifies func\n    ensures func.executed == true  \n  {\n    func.Execute();\n  }\n}\nmethod Main() {\n  var f := new Function();\n  var thread := new BThread(f);\n  thread.Run();\n  assert f.executed == true;\n}", "name": "py2dfy_257", "id": 257}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype HttpMethod = GET | POST\ndatatype HttpResponse = Response(\n  statusCode: int,\n  body: string\n)\ndatatype User = User(\n  username: string,\n  password: string,\n  token: string\n)\nclass AuthSystem {\n  \n  var users: seq<User>\n  \n  var validTokens: set<string>\n  constructor()\n  {\n    users := [];\n    validTokens := {};\n  }\n  \n  method login(username: string, password: string) returns (response: HttpResponse)\n      (exists i :: 0 <= i < |old(users)| && \n        old(users)[i].username == username && \n        old(users)[i].password == password &&\n        old(users)[i].token in validTokens)\n  {\n    var found: bool;\n    var idx: int;\n    found, idx := findUser(username, password);\n    \n    if !found {\n      return Response(401, \"Invalid credentials\");\n    }\n    \n    validTokens := validTokens + {users[idx].token};\n    return Response(200, \"Login successful\");\n  }\n  \n  method findUser(username: string, password: string) returns (found: bool, index: int)\n      0 <= index < |users| && \n      users[index].username == username &&\n      users[index].password == password\n      forall i :: 0 <= i < |users| ==>\n        users[i].username != username ||\n        users[i].password != password\n  {\n    var i := 0;\n    while i < |users|\n        users[j].username != username ||\n        users[j].password != password\n    {\n      if users[i].username == username && users[i].password == password {\n        return true, i;\n      }\n      i := i + 1;\n    }\n    return false, -1;\n  }\n  \n  method logout(token: string) returns (response: HttpResponse)\n  {\n    if token !in validTokens {\n      return Response(401, \"Invalid token\");\n    }\n    validTokens := validTokens - {token};\n    return Response(200, \"Logout successful\");\n  }\n  \n  method register(username: string, password: string) returns (response: HttpResponse)\n      |users| == |old(users)| + 1 &&\n      users[|users|-1].username == username &&\n      users[|users|-1].password == password\n  {\n    var userExists := checkUserExists(username);\n    if userExists {\n      return Response(400, \"Username already exists\");\n    }\n    \n    var newUser := User(username, password, username + \"_token\");\n    users := users + [newUser];\n    return Response(201, \"User registered successfully\");\n  }\n  \n  method checkUserExists(username: string) returns (result: bool)\n      exists i :: 0 <= i < |users| && users[i].username == username\n      forall i :: 0 <= i < |users| ==> users[i].username != username\n  {\n    var i := 0;\n    while i < |users|\n    {\n      if users[i].username == username {\n        return true;\n      }\n      i := i + 1;\n    }\n    return false;\n  }\n}", "output": "datatype HttpMethod = GET | POST\ndatatype HttpResponse = Response(\n  statusCode: int,\n  body: string\n)\ndatatype User = User(\n  username: string,\n  password: string,\n  token: string\n)\nclass AuthSystem {\n  \n  var users: seq<User>\n  \n  var validTokens: set<string>\n  constructor()\n    ensures |users| == 0\n    ensures validTokens == {}\n  {\n    users := [];\n    validTokens := {};\n  }\n  \n  method login(username: string, password: string) returns (response: HttpResponse)\n    modifies this\n    requires username != \"\"\n    requires password != \"\" \n    ensures response.statusCode == 200 ==> \n      (exists i :: 0 <= i < |old(users)| && \n        old(users)[i].username == username && \n        old(users)[i].password == password &&\n        old(users)[i].token in validTokens)\n    ensures response.statusCode == 401 ==> validTokens == old(validTokens)\n  {\n    var found: bool;\n    var idx: int;\n    found, idx := findUser(username, password);\n    \n    if !found {\n      return Response(401, \"Invalid credentials\");\n    }\n    \n    validTokens := validTokens + {users[idx].token};\n    return Response(200, \"Login successful\");\n  }\n  \n  method findUser(username: string, password: string) returns (found: bool, index: int)\n    requires username != \"\"\n    requires password != \"\"\n    ensures found ==> \n      0 <= index < |users| && \n      users[index].username == username &&\n      users[index].password == password\n    ensures !found ==>\n      forall i :: 0 <= i < |users| ==>\n        users[i].username != username ||\n        users[i].password != password\n  {\n    var i := 0;\n    while i < |users|\n      invariant 0 <= i <= |users|\n      invariant forall j :: 0 <= j < i ==>\n        users[j].username != username ||\n        users[j].password != password\n    {\n      if users[i].username == username && users[i].password == password {\n        return true, i;\n      }\n      i := i + 1;\n    }\n    return false, -1;\n  }\n  \n  method logout(token: string) returns (response: HttpResponse)\n    modifies this\n    requires token != \"\"\n    ensures response.statusCode == 200 ==> token !in validTokens\n    ensures response.statusCode == 401 ==> validTokens == old(validTokens)\n  {\n    if token !in validTokens {\n      return Response(401, \"Invalid token\");\n    }\n    validTokens := validTokens - {token};\n    return Response(200, \"Logout successful\");\n  }\n  \n  method register(username: string, password: string) returns (response: HttpResponse)\n    modifies this\n    requires username != \"\"\n    requires password != \"\"\n    ensures response.statusCode == 201 ==> \n      |users| == |old(users)| + 1 &&\n      users[|users|-1].username == username &&\n      users[|users|-1].password == password\n    ensures response.statusCode == 400 ==> users == old(users)\n  {\n    var userExists := checkUserExists(username);\n    if userExists {\n      return Response(400, \"Username already exists\");\n    }\n    \n    var newUser := User(username, password, username + \"_token\");\n    users := users + [newUser];\n    return Response(201, \"User registered successfully\");\n  }\n  \n  method checkUserExists(username: string) returns (result: bool)\n    requires username != \"\"\n    ensures result ==> \n      exists i :: 0 <= i < |users| && users[i].username == username\n    ensures !result ==>\n      forall i :: 0 <= i < |users| ==> users[i].username != username\n  {\n    var i := 0;\n    while i < |users|\n      invariant 0 <= i <= |users|\n      invariant forall j :: 0 <= j < i ==> users[j].username != username\n    {\n      if users[i].username == username {\n        return true;\n      }\n      i := i + 1;\n    }\n    return false;\n  }\n}", "name": "py2dfy_206", "id": 206}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintAscendingPattern(n: nat)\n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n  {\n    var j := 0;\n    while j <= i\n    {\n      if 0 <= num < 128 {\n        print(((num) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      j := j + 1;\n    }\n    print(\"\\n\");\n    num := num + 1;\n    i := i + 1;\n  }\n}\nmethod PrintAscendingSequence(n: nat)\n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n  {\n    var j := 0;\n    while j <= i\n    {\n      if 0 <= num < 128 {\n        print(((num) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      num := num + 1;\n      j := j + 1;\n    }\n    print(\"\\n\");\n    i := i + 1;\n  }\n}\nmethod PrintDescendingPattern(n: nat) \n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n  {\n    var j := 0;\n    while j <= i\n    {\n      if 0 <= num - j < 128 {\n        print(((num - j) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      j := j + 1;\n    }\n    print(\"\\n\");\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  print(\"Pattern 1:\\n\");\n  PrintAscendingPattern(5);\n  print(\"\\nPattern 2:\\n\");\n  PrintAscendingSequence(5);\n  print(\"\\nPattern 3:\\n\");\n  PrintDescendingPattern(5);\n}", "output": "method PrintAscendingPattern(n: nat)\n  requires n > 0\n  ensures true  \n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 65 <= num <= 65 + n\n    invariant num == 65 + i  \n  {\n    var j := 0;\n    while j <= i\n      invariant 0 <= j <= i + 1\n    {\n      if 0 <= num < 128 {\n        print(((num) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      j := j + 1;\n    }\n    print(\"\\n\");\n    num := num + 1;\n    i := i + 1;\n  }\n}\nmethod PrintAscendingSequence(n: nat)\n  requires n > 0\n  ensures true\n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 65 <= num <= 65 + (n * (n + 1)) / 2\n    invariant num == 65 + (i * (i + 1)) / 2  \n  {\n    var j := 0;\n    while j <= i\n      invariant 0 <= j <= i + 1\n      invariant num == 65 + (i * (i + 1)) / 2 + j\n    {\n      if 0 <= num < 128 {\n        print(((num) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      num := num + 1;\n      j := j + 1;\n    }\n    print(\"\\n\");\n    i := i + 1;\n  }\n}\nmethod PrintDescendingPattern(n: nat) \n  requires n > 0\n  ensures true\n{\n  var num := 65;  \n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant num == 65  \n  {\n    var j := 0;\n    while j <= i\n      invariant 0 <= j <= i + 1\n      invariant num == 65  \n    {\n      if 0 <= num - j < 128 {\n        print(((num - j) as char), \" \");\n      } else {\n        print(\"? \");\n      }\n      j := j + 1;\n    }\n    print(\"\\n\");\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  print(\"Pattern 1:\\n\");\n  PrintAscendingPattern(5);\n  print(\"\\nPattern 2:\\n\");\n  PrintAscendingSequence(5);\n  print(\"\\nPattern 3:\\n\");\n  PrintDescendingPattern(5);\n}", "name": "py2dfy_223", "id": 223}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Formatter = TextFormatter | HTMLFormatter | CrossHTMLFormatter\nclass TableData {\n  var rows: seq<seq<string>>\n  var headers: seq<string>\n  \n  constructor()\n  {\n    rows := [];\n    headers := [];\n  }\n}\nclass {:autocontracts} TableFormatter {\n  var config: Formatter\n  \n  constructor(fmt: Formatter)\n  {\n    config := fmt;\n  }\n  \n  method Format(data: TableData) returns (result: string)\n  {\n    match config\n    case TextFormatter => \n      result := FormatAsText(data);\n    case HTMLFormatter =>\n      result := FormatAsHTML(data);\n    case CrossHTMLFormatter =>\n      result := FormatAsHTML(data);\n  }\n  \n  method FormatAsText(data: TableData) returns (result: string)\n  {\n    result := \"Text Table\\n\";\n    var i := 0;\n    while i < |data.rows|\n    {\n      var row := data.rows[i];\n      \n      if |row| > 0 && |row[0]| > 0 {\n        var rowStr := JoinStrings(row, \"|\");\n        result := result + rowStr + \"\\n\";\n      } else {\n        result := result + \"\\n\";\n      }\n      i := i + 1;\n    }\n  }\n  \n  method FormatAsHTML(data: TableData) returns (result: string)\n  {\n    result := \"<table>\\n\";\n    var i := 0;\n    while i < |data.rows|\n    {\n      var row := data.rows[i];\n      result := result + \"  <tr>\\n\";\n      var j := 0;\n      while j < |row|\n      {\n        result := result + \"    <td>\" + row[j] + \"</td>\\n\";\n        j := j + 1;\n      }\n      result := result + \"  </tr>\\n\";\n      i := i + 1;\n    }\n    result := result + \"</table>\";\n  }\n  \n  method JoinStrings(strings: seq<string>, separator: string) returns (result: string)\n  {\n    if |strings| == 0 {\n      return \"\";\n    }\n    result := strings[0];\n    var i := 1;\n    while i < |strings|\n    {\n      result := result + separator + strings[i];\n      i := i + 1;\n    }\n  }\n}\nmethod Main()\n{\n  var textFormatter := new TableFormatter(TextFormatter);\n  var htmlFormatter := new TableFormatter(HTMLFormatter);\n  var crossFormatter := new TableFormatter(CrossHTMLFormatter);\n  \n  var data := new TableData();\n  data.rows := [[\"Item1\", \"Value1\"], [\"Item2\", \"Value2\"]];\n  data.headers := [\"Item\", \"Value\"];\n  \n  var textOutput := textFormatter.Format(data);\n  var htmlOutput := htmlFormatter.Format(data);\n  \n  print textOutput;\n  print \"\\n\";\n  print htmlOutput;\n}", "output": "datatype Formatter = TextFormatter | HTMLFormatter | CrossHTMLFormatter\nclass TableData {\n  var rows: seq<seq<string>>\n  var headers: seq<string>\n  \n  constructor()\n    ensures rows == []\n    ensures headers == []\n  {\n    rows := [];\n    headers := [];\n  }\n}\nclass {:autocontracts} TableFormatter {\n  var config: Formatter\n  \n  constructor(fmt: Formatter)\n    ensures config == fmt\n  {\n    config := fmt;\n  }\n  \n  method Format(data: TableData) returns (result: string)\n    ensures |result| > 0\n  {\n    match config\n    case TextFormatter => \n      result := FormatAsText(data);\n    case HTMLFormatter =>\n      result := FormatAsHTML(data);\n    case CrossHTMLFormatter =>\n      result := FormatAsHTML(data);\n  }\n  \n  method FormatAsText(data: TableData) returns (result: string)\n    ensures |result| > 0\n  {\n    result := \"Text Table\\n\";\n    var i := 0;\n    while i < |data.rows|\n      invariant 0 <= i <= |data.rows|\n      invariant |result| > 0\n    {\n      var row := data.rows[i];\n      \n      if |row| > 0 && |row[0]| > 0 {\n        var rowStr := JoinStrings(row, \"|\");\n        result := result + rowStr + \"\\n\";\n      } else {\n        result := result + \"\\n\";\n      }\n      i := i + 1;\n    }\n  }\n  \n  method FormatAsHTML(data: TableData) returns (result: string)\n    ensures |result| > 0\n  {\n    result := \"<table>\\n\";\n    var i := 0;\n    while i < |data.rows|\n      invariant 0 <= i <= |data.rows|\n      invariant |result| > 0\n    {\n      var row := data.rows[i];\n      result := result + \"  <tr>\\n\";\n      var j := 0;\n      while j < |row|\n        invariant 0 <= j <= |row|\n        invariant |result| > 0\n      {\n        result := result + \"    <td>\" + row[j] + \"</td>\\n\";\n        j := j + 1;\n      }\n      result := result + \"  </tr>\\n\";\n      i := i + 1;\n    }\n    result := result + \"</table>\";\n  }\n  \n  method JoinStrings(strings: seq<string>, separator: string) returns (result: string)\n    requires |strings| > 0 ==> |strings[0]| > 0  \n    ensures |strings| == 0 ==> |result| == 0\n    ensures |strings| > 0 ==> |result| > 0\n  {\n    if |strings| == 0 {\n      return \"\";\n    }\n    result := strings[0];\n    var i := 1;\n    while i < |strings|\n      invariant 1 <= i <= |strings|\n      invariant |result| > 0\n    {\n      result := result + separator + strings[i];\n      i := i + 1;\n    }\n  }\n}\nmethod Main()\n{\n  var textFormatter := new TableFormatter(TextFormatter);\n  var htmlFormatter := new TableFormatter(HTMLFormatter);\n  var crossFormatter := new TableFormatter(CrossHTMLFormatter);\n  \n  var data := new TableData();\n  data.rows := [[\"Item1\", \"Value1\"], [\"Item2\", \"Value2\"]];\n  data.headers := [\"Item\", \"Value\"];\n  \n  var textOutput := textFormatter.Format(data);\n  var htmlOutput := htmlFormatter.Format(data);\n  \n  print textOutput;\n  print \"\\n\";\n  print htmlOutput;\n}", "name": "py2dfy_208", "id": 208}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ImagePair = ImagePair(pan: string, ms: string)\nmethod ListImagesInDataset(panFiles: seq<string>, msFiles: seq<string>) returns (result: seq<ImagePair>)\n    pair.pan in panFiles && pair.ms in msFiles\n{\n  result := [];\n  var i := 0;\n  while i < |msFiles|\n      pair.pan in panFiles && pair.ms in msFiles\n  {\n    var msDate := ExtractDate(msFiles[i]);\n    var matchingPan := FindMatchingPan(panFiles, msDate);\n    if matchingPan != \"\"\n    {\n      result := result + [ImagePair(matchingPan, msFiles[i])];\n    }\n    i := i + 1;\n  }\n}\nfunction ExtractDate(filename: string): string\n{\n  filename\n}\nmethod FindMatchingPan(panFiles: seq<string>, date: string) returns (result: string)\n{\n  result := \"\";\n  var i := 0;\n  while i < |panFiles|\n  {\n    if ExtractDate(panFiles[i]) == date\n    {\n      result := panFiles[i];\n      break;\n    }\n    i := i + 1;\n  }\n}", "output": "datatype ImagePair = ImagePair(pan: string, ms: string)\nmethod ListImagesInDataset(panFiles: seq<string>, msFiles: seq<string>) returns (result: seq<ImagePair>)\n  requires forall f :: f in panFiles ==> |f| > 0\n  requires forall f :: f in msFiles ==> |f| > 0\n  ensures |result| <= |msFiles|\n  ensures forall pair :: pair in result ==> \n    pair.pan in panFiles && pair.ms in msFiles\n{\n  result := [];\n  var i := 0;\n  while i < |msFiles|\n    invariant 0 <= i <= |msFiles|\n    invariant |result| <= i\n    invariant forall pair :: pair in result ==> \n      pair.pan in panFiles && pair.ms in msFiles\n  {\n    var msDate := ExtractDate(msFiles[i]);\n    var matchingPan := FindMatchingPan(panFiles, msDate);\n    if matchingPan != \"\"\n    {\n      result := result + [ImagePair(matchingPan, msFiles[i])];\n    }\n    i := i + 1;\n  }\n}\nfunction ExtractDate(filename: string): string\n  requires |filename| > 0\n  ensures |ExtractDate(filename)| >= 0\n{\n  filename\n}\nmethod FindMatchingPan(panFiles: seq<string>, date: string) returns (result: string)\n  requires forall f :: f in panFiles ==> |f| > 0\n  ensures result == \"\" || result in panFiles\n{\n  result := \"\";\n  var i := 0;\n  while i < |panFiles|\n    invariant 0 <= i <= |panFiles|\n    invariant result == \"\" || result in panFiles\n  {\n    if ExtractDate(panFiles[i]) == date\n    {\n      result := panFiles[i];\n      break;\n    }\n    i := i + 1;\n  }\n}", "name": "py2dfy_272", "id": 272}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class BucketList {\n    \n    var name: string\n    var status: string\n    \n    constructor(name: string, status: string)\n    {\n        this.name := name;\n        this.status := status;\n    }\n    \n    method CreateBucketList(name: string, status: string := \"In Progress\") returns (result: Either<BucketList, string>)\n    {\n        if name == \"\" {\n            return Right(\"Please provide a name for your bucket list\");\n        }\n        var newBucket := new BucketList(name, status);\n        return Left(newBucket);\n    }\n}\ndatatype Either<L, R> = Left(left: L) | Right(right: R) {\n    predicate IsLeft() {\n        this.Left?\n    }\n    \n    predicate IsRight() {\n        this.Right?\n    }\n}\nmethod TestCreateBucketListReturn()\n{\n    var bucket := new BucketList(\"\", \"\");\n    var result := bucket.CreateBucketList(\"Name\", \"Completed\");\n}\nmethod TestCreateBucketListEmptyName()\n{\n    var bucket := new BucketList(\"\", \"\");\n    var result := bucket.CreateBucketList(\"\");\n}", "output": "class BucketList {\n    \n    var name: string\n    var status: string\n    \n    constructor(name: string, status: string)\n        ensures this.name == name\n        ensures this.status == status\n    {\n        this.name := name;\n        this.status := status;\n    }\n    \n    method CreateBucketList(name: string, status: string := \"In Progress\") returns (result: Either<BucketList, string>)\n        ensures name == \"\" ==> result.IsRight() && result.right == \"Please provide a name for your bucket list\"\n        ensures name != \"\" ==> result.IsLeft() && result.left.name == name && result.left.status == status\n    {\n        if name == \"\" {\n            return Right(\"Please provide a name for your bucket list\");\n        }\n        var newBucket := new BucketList(name, status);\n        return Left(newBucket);\n    }\n}\ndatatype Either<L, R> = Left(left: L) | Right(right: R) {\n    predicate IsLeft() {\n        this.Left?\n    }\n    \n    predicate IsRight() {\n        this.Right?\n    }\n}\nmethod TestCreateBucketListReturn()\n    ensures true  \n{\n    var bucket := new BucketList(\"\", \"\");\n    var result := bucket.CreateBucketList(\"Name\", \"Completed\");\n    assert result.IsLeft();  \n}\nmethod TestCreateBucketListEmptyName()\n    ensures true  \n{\n    var bucket := new BucketList(\"\", \"\");\n    var result := bucket.CreateBucketList(\"\");\n    assert result.IsRight();  \n    assert result.right == \"Please provide a name for your bucket list\";\n}", "name": "py2dfy_275", "id": 275}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Capture {\n  var width: int\n  var height: int\n  var isActive: bool\n  constructor()\n  {\n    width := 0;\n    height := 0; \n    isActive := false;\n  }\n  \n  method size(w: int, h: int)\n  {\n    width := w;\n    height := h;\n  }\n}\nclass Canvas {\n  var width: int\n  var height: int\n  ghost var pixels: seq<int>  \n  constructor(w: int, h: int)\n  {\n    width := w;\n    height := h;\n    pixels := seq(w * h, i => 0);  \n  }\n  \n  method background(color: int)\n  {\n    pixels := seq(width * height, i => color);\n  }\n  \n  method drawImage(cap: Capture?, x: int, y: int, w: int, h: int)\n  {\n    \n    \n    pixels := pixels; \n  }\n}\nclass Program {\n  var canvas: Canvas?\n  var capture: Capture?\n  constructor()\n  {\n    canvas := null;\n    capture := null;\n  }\n  \n  method setup()\n  {\n    canvas := new Canvas(390, 240);\n    capture := new Capture();\n    capture.size(320, 240);\n  }\n  \n  method draw()\n  {\n    canvas.background(255);  \n    canvas.drawImage(capture, 0, 0, 320, 240);\n  }\n}", "output": "class Capture {\n  var width: int\n  var height: int\n  var isActive: bool\n  constructor()\n    ensures width == 0 && height == 0 && !isActive\n  {\n    width := 0;\n    height := 0; \n    isActive := false;\n  }\n  \n  method size(w: int, h: int)\n    requires w > 0 && h > 0  \n    modifies this\n    ensures width == w && height == h\n  {\n    width := w;\n    height := h;\n  }\n}\nclass Canvas {\n  var width: int\n  var height: int\n  ghost var pixels: seq<int>  \n  constructor(w: int, h: int)\n    requires w > 0 && h > 0  \n    ensures width == w && height == h\n    ensures |pixels| == w * h  \n  {\n    width := w;\n    height := h;\n    pixels := seq(w * h, i => 0);  \n  }\n  \n  method background(color: int)\n    requires 0 <= color <= 255  \n    requires width > 0 && height > 0\n    requires width * height > 0\n    modifies this`pixels\n    ensures forall i :: 0 <= i < |pixels| ==> pixels[i] == color\n    ensures |pixels| == width * height\n  {\n    pixels := seq(width * height, i => color);\n  }\n  \n  method drawImage(cap: Capture?, x: int, y: int, w: int, h: int)\n    requires cap != null\n    requires 0 <= x < width && 0 <= y < height  \n    requires w > 0 && h > 0  \n    requires x + w <= width && y + h <= height  \n    requires width > 0 && height > 0\n    requires width * height > 0\n    modifies this`pixels\n    ensures |pixels| == old(|pixels|)  \n  {\n    \n    \n    pixels := pixels; \n  }\n}\nclass Program {\n  var canvas: Canvas?\n  var capture: Capture?\n  constructor()\n    ensures canvas == null && capture == null\n  {\n    canvas := null;\n    capture := null;\n  }\n  \n  method setup()\n    modifies this\n    ensures canvas != null && capture != null\n    ensures canvas.width == 390 && canvas.height == 240\n    ensures capture.width == 320 && capture.height == 240\n  {\n    canvas := new Canvas(390, 240);\n    capture := new Capture();\n    capture.size(320, 240);\n  }\n  \n  method draw()\n    requires canvas != null && capture != null  \n    requires canvas.width >= 320 && canvas.height >= 240  \n    requires canvas.width > 0 && canvas.height > 0\n    requires canvas.width * canvas.height > 0\n    modifies canvas`pixels\n  {\n    canvas.background(255);  \n    canvas.drawImage(capture, 0, 0, 320, 240);\n  }\n}", "name": "py2dfy_216", "id": 216}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait AppConfig {\n    var name: string\n    predicate Valid()\n    {\n        name != \"\"\n    }\n    method Init(appName: string)\n    {\n        name := appName;\n    }\n    method GetName() returns (appName: string)\n    {\n        appName := name;\n    }\n}\nclass BizzConfig extends AppConfig {\n    constructor()\n    {\n        name := \"bizz\";\n    }\n}", "output": "trait AppConfig {\n    var name: string\n    predicate Valid()\n        reads this\n    {\n        name != \"\"\n    }\n    method Init(appName: string)\n        requires appName != \"\"\n        modifies this\n        ensures name == appName\n        ensures Valid()\n    {\n        name := appName;\n    }\n    method GetName() returns (appName: string)\n        requires Valid()\n        ensures appName == name\n        ensures appName != \"\"\n    {\n        appName := name;\n    }\n}\nclass BizzConfig extends AppConfig {\n    constructor()\n        ensures name == \"bizz\"\n        ensures Valid()\n    {\n        name := \"bizz\";\n    }\n}", "name": "py2dfy_248", "id": 248}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype DateTime = DateTime(timestamp: int)\ndatatype TripRecord = TripRecord(id: string, taxiId: string, endTime: DateTime)\ndatatype GroupedTrip = GroupedTrip(taxiId: string, trips: seq<TripRecord>)\nfunction IsLaterThan(d1: DateTime, d2: DateTime): bool {\n    d1.timestamp > d2.timestamp\n}\nfunction TimeDifference(d1: DateTime, d2: DateTime): int {\n    d1.timestamp - d2.timestamp\n}\nmethod CalculateLoss(trips: seq<TripRecord>) returns (loss: int)\n        !IsLaterThan(trips[i].endTime, trips[j].endTime)\n{\n    loss := 0;\n    var i := 1;\n    \n    while i < |trips|\n    {\n        var timeDiff := TimeDifference(\n            trips[i].endTime, \n            trips[i-1].endTime\n        );\n        \n        if timeDiff > 0 {\n            loss := loss + timeDiff;\n        }\n        i := i + 1;\n    }\n}\nfunction SumPositiveDeltas(trips: seq<TripRecord>, upTo: int): int\n{\n    if upTo == 1 then\n        0\n    else\n        var diff := TimeDifference(trips[upTo-1].endTime, trips[upTo-2].endTime);\n        SumPositiveDeltas(trips, upTo-1) + (if diff > 0 then diff else 0)\n}\nmethod GroupTripsByTaxi(trips: seq<TripRecord>) returns (grouped: seq<GroupedTrip>)\n{\n    \n    var allTrips := trips;\n    var taxiId := trips[0].taxiId;\n    grouped := [GroupedTrip(taxiId, allTrips)];\n}", "output": "datatype DateTime = DateTime(timestamp: int)\ndatatype TripRecord = TripRecord(id: string, taxiId: string, endTime: DateTime)\ndatatype GroupedTrip = GroupedTrip(taxiId: string, trips: seq<TripRecord>)\nfunction IsLaterThan(d1: DateTime, d2: DateTime): bool {\n    d1.timestamp > d2.timestamp\n}\nfunction TimeDifference(d1: DateTime, d2: DateTime): int {\n    d1.timestamp - d2.timestamp\n}\nmethod CalculateLoss(trips: seq<TripRecord>) returns (loss: int)\n    requires |trips| > 0  \n    requires forall i, j :: 0 <= i < j < |trips| ==>  \n        !IsLaterThan(trips[i].endTime, trips[j].endTime)\n    ensures loss >= 0  \n{\n    loss := 0;\n    var i := 1;\n    \n    while i < |trips|\n        invariant 1 <= i <= |trips|\n        invariant loss >= 0\n        invariant loss == SumPositiveDeltas(trips, i)\n        decreases |trips| - i\n    {\n        var timeDiff := TimeDifference(\n            trips[i].endTime, \n            trips[i-1].endTime\n        );\n        \n        if timeDiff > 0 {\n            loss := loss + timeDiff;\n        }\n        i := i + 1;\n    }\n}\nfunction SumPositiveDeltas(trips: seq<TripRecord>, upTo: int): int\n    requires 0 < upTo <= |trips|\n{\n    if upTo == 1 then\n        0\n    else\n        var diff := TimeDifference(trips[upTo-1].endTime, trips[upTo-2].endTime);\n        SumPositiveDeltas(trips, upTo-1) + (if diff > 0 then diff else 0)\n}\nmethod GroupTripsByTaxi(trips: seq<TripRecord>) returns (grouped: seq<GroupedTrip>)\n    requires |trips| > 0\n    ensures |grouped| > 0\n    ensures forall g :: g in grouped ==> |g.trips| > 0\n{\n    \n    var allTrips := trips;\n    var taxiId := trips[0].taxiId;\n    grouped := [GroupedTrip(taxiId, allTrips)];\n}", "name": "py2dfy_237", "id": 237}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Handler = PostTweetHandler | TweetPageHandler(id: int)\ndatatype URL = Url(path: string)\ndatatype Response = Response(status: int, content: string)\ndatatype Option<T> = None | Some(value: T)\nclass UrlRouter {\n  var routes: map<string, Handler>\n  constructor()\n  {\n    routes := map[];\n  }\n  method RegisterRoute(path: string, handler: Handler)\n            p in routes && routes[p] == old(routes[p])\n  {\n    routes := routes[path := handler];\n  }\n  method MatchUrl(url: URL) returns (handler: Option<Handler>)\n  {\n    if url.path in routes {\n      return Some(routes[url.path]);\n    }\n    return None;\n  }\n  method HandleRequest(url: URL) returns (response: Response)\n  {\n    var handlerOpt := MatchUrl(url);\n    \n    if handlerOpt.None? {\n      return Response(404, \"Not Found\");\n    } else {\n      var handler := handlerOpt.value;\n      match handler {\n        case PostTweetHandler => \n          return Response(200, \"Tweet Posted\");\n        case TweetPageHandler(id) => \n          return Response(200, \"Showing Tweet \" + IntToString(id));\n      }\n    }\n  }\n  \n  function IntToString(n: int): string\n  {\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n  }\n  \n  function IntToStringHelper(n: int): string\n  {\n    if n == 0 then \"\"\n    else IntToStringHelper(n/10) + [((n%10) + 48) as char]\n  }\n}\nmethod Main()\n{\n  var router := new UrlRouter();\n  \n  router.RegisterRoute(\"post_tweet/\", PostTweetHandler);\n  router.RegisterRoute(\"tweet_page/123/\", TweetPageHandler(123));\n  var response := router.HandleRequest(Url(\"post_tweet/\"));\n}", "output": "datatype Handler = PostTweetHandler | TweetPageHandler(id: int)\ndatatype URL = Url(path: string)\ndatatype Response = Response(status: int, content: string)\ndatatype Option<T> = None | Some(value: T)\nclass UrlRouter {\n  var routes: map<string, Handler>\n  constructor()\n    ensures fresh(this)\n    ensures routes == map[]\n  {\n    routes := map[];\n  }\n  method RegisterRoute(path: string, handler: Handler)\n    modifies this\n    requires path != \"\"\n    ensures path in routes\n    ensures routes[path] == handler\n    ensures forall p :: p in old(routes) && p != path ==> \n            p in routes && routes[p] == old(routes[p])\n  {\n    routes := routes[path := handler];\n  }\n  method MatchUrl(url: URL) returns (handler: Option<Handler>)\n    requires url.path != \"\"\n    ensures handler.Some? ==> url.path in routes && handler.value == routes[url.path]\n    ensures handler.None? ==> url.path !in routes\n  {\n    if url.path in routes {\n      return Some(routes[url.path]);\n    }\n    return None;\n  }\n  method HandleRequest(url: URL) returns (response: Response)\n    requires url.path != \"\"\n    ensures url.path !in routes ==> response.status == 404\n    ensures url.path in routes ==> response.status == 200\n  {\n    var handlerOpt := MatchUrl(url);\n    \n    if handlerOpt.None? {\n      return Response(404, \"Not Found\");\n    } else {\n      var handler := handlerOpt.value;\n      match handler {\n        case PostTweetHandler => \n          return Response(200, \"Tweet Posted\");\n        case TweetPageHandler(id) => \n          return Response(200, \"Showing Tweet \" + IntToString(id));\n      }\n    }\n  }\n  \n  function IntToString(n: int): string\n  {\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n  }\n  \n  function IntToStringHelper(n: int): string\n    requires n >= 0\n  {\n    if n == 0 then \"\"\n    else IntToStringHelper(n/10) + [((n%10) + 48) as char]\n  }\n}\nmethod Main()\n{\n  var router := new UrlRouter();\n  \n  router.RegisterRoute(\"post_tweet/\", PostTweetHandler);\n  router.RegisterRoute(\"tweet_page/123/\", TweetPageHandler(123));\n  var response := router.HandleRequest(Url(\"post_tweet/\"));\n  assert response.status == 200;\n}", "name": "py2dfy_227", "id": 227}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main() {\n  var inputValues := ReadFloatsFromStdin();\n  ProcessValues(inputValues);\n}\nmethod ReadFloatsFromStdin() returns (values: seq<real>)\n{\n  var result: seq<real> := [];\n  return result;\n}\nmethod ProcessValues(inputValues: seq<real>)\n{\n  var i := 0;\n  \n  while i < |inputValues|\n  {\n    var value := inputValues[i];\n    var key := ComputeKey(value);\n    OutputKeyValuePair(key, value);\n    i := i + 1;\n  }\n}\nmethod ComputeKey(value: real) returns (key: int)\n{\n  key := FloorFunction(value * 10.0);\n}\nfunction FloorFunction(x: real): int\n{\n  if x >= 0.0 then\n    x.Floor\n  else\n    if x == x.Floor as real then\n      x.Floor\n    else\n      x.Floor\n}\nmethod OutputKeyValuePair(key: int, value: real)\n{\n}", "output": "method Main() {\n  var inputValues := ReadFloatsFromStdin();\n  ProcessValues(inputValues);\n}\nmethod ReadFloatsFromStdin() returns (values: seq<real>)\n  ensures |values| >= 0\n{\n  var result: seq<real> := [];\n  return result;\n}\nmethod ProcessValues(inputValues: seq<real>)\n  requires |inputValues| >= 0\n  ensures true\n{\n  var i := 0;\n  \n  while i < |inputValues|\n    invariant 0 <= i <= |inputValues|\n  {\n    var value := inputValues[i];\n    var key := ComputeKey(value);\n    OutputKeyValuePair(key, value);\n    i := i + 1;\n  }\n}\nmethod ComputeKey(value: real) returns (key: int)\n  ensures key == FloorFunction(value * 10.0)\n{\n  key := FloorFunction(value * 10.0);\n}\nfunction FloorFunction(x: real): int\n{\n  if x >= 0.0 then\n    x.Floor\n  else\n    if x == x.Floor as real then\n      x.Floor\n    else\n      x.Floor\n}\nmethod OutputKeyValuePair(key: int, value: real)\n  ensures true\n{\n}", "name": "py2dfy_277", "id": 277}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Author {\n  var login: string\n  var password: string\n  \n  constructor()\n  {\n    login := \"\";\n    password := \"\";\n  }\n  \n  method Login(loginStr: string, pwd: string) returns (success: bool)\n  {\n    login := loginStr;\n    password := pwd;\n    success := true;\n  }\n}\nclass Article {\n  var title: string\n  var annotation: string\n  var categoryId: int\n  var templateId: int\n  var permissions: string\n  var source: string\n  \n  constructor()\n  {\n    title := \"\";\n    annotation := \"\";\n    categoryId := 0;\n    templateId := 0;\n    permissions := \"\";\n    source := \"\";\n  }\n  \n  method Save(author: Author, templatePath: string) returns (success: bool)\n  {\n    success := true;\n  }\n}\nclass ArticleTests {\n  method TestArticleSave() returns (success: bool)\n  {\n    var author := new Author();\n    var loginSuccess := author.Login(\"login_1\", \"login\");\n    \n    var article := new Article();\n    article.title := \"Test Article\";\n    article.annotation := \"Test Annotation\";\n    article.categoryId := 3;\n    article.templateId := 5;\n    article.permissions := \"sol\";\n    article.source := \"Long article text...\";\n    \n    var saveSuccess := article.Save(author, \"./tpl\");\n    \n    success := loginSuccess && saveSuccess;\n    return success;\n  }\n}", "output": "class Author {\n  var login: string\n  var password: string\n  \n  constructor()\n    ensures login == \"\"\n    ensures password == \"\"\n  {\n    login := \"\";\n    password := \"\";\n  }\n  \n  method Login(loginStr: string, pwd: string) returns (success: bool)\n    modifies this\n    ensures success \n    ensures login == loginStr && password == pwd\n  {\n    login := loginStr;\n    password := pwd;\n    success := true;\n  }\n}\nclass Article {\n  var title: string\n  var annotation: string\n  var categoryId: int\n  var templateId: int\n  var permissions: string\n  var source: string\n  \n  constructor()\n    ensures title == \"\"\n    ensures annotation == \"\"\n    ensures categoryId == 0\n    ensures templateId == 0\n    ensures permissions == \"\"\n    ensures source == \"\"\n  {\n    title := \"\";\n    annotation := \"\";\n    categoryId := 0;\n    templateId := 0;\n    permissions := \"\";\n    source := \"\";\n  }\n  \n  method Save(author: Author, templatePath: string) returns (success: bool)\n    requires templatePath != \"\"\n    modifies this\n    ensures success\n  {\n    success := true;\n  }\n}\nclass ArticleTests {\n  method TestArticleSave() returns (success: bool)\n    ensures success\n  {\n    var author := new Author();\n    var loginSuccess := author.Login(\"login_1\", \"login\");\n    \n    var article := new Article();\n    article.title := \"Test Article\";\n    article.annotation := \"Test Annotation\";\n    article.categoryId := 3;\n    article.templateId := 5;\n    article.permissions := \"sol\";\n    article.source := \"Long article text...\";\n    \n    var saveSuccess := article.Save(author, \"./tpl\");\n    \n    assert loginSuccess; \n    assert saveSuccess; \n    success := loginSuccess && saveSuccess;\n    assert success; \n    return success;\n  }\n}", "name": "py2dfy_271", "id": 271}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Point = Point(x: real, y: real, z: real)\ndatatype WeightedPoint = WeightedPoint(point: Point, weight: real, jackknife: int)\nclass Configuration {\n  var nrbins: int\n  var nmu_bins: int  \n  var mu_max: real\n  var periodic: bool\n  var nthreads: int\n  constructor(rb: int, mb: int, mm: real, p: bool, nt: int)\n  {\n    nrbins := rb;\n    nmu_bins := mb;\n    mu_max := mm;\n    periodic := p;\n    nthreads := nt;\n  }\n}\nmethod ReadWeightedPoints(filename: string) returns (points: seq<WeightedPoint>)\n{\n  var p := WeightedPoint(Point(0.0, 0.0, 0.0), 1.0, 0);\n  points := [p];\n}\nmethod CoordTransform(p: Point) returns (comDist: real, ra: real, dec: real)\n{\n  var xsq := p.x * p.x;\n  var ysq := p.y * p.y;\n  var zsq := p.z * p.z;\n  comDist := xsq + ysq + zsq;\n  var s := xsq + ysq;\n  ra := if p.x >= 0.0 then 45.0 else -45.0;\n  dec := if s >= 0.0 then 45.0 else -45.0;\n}\nmethod ComputePairCounts(config: Configuration, points1: seq<WeightedPoint>, points2: seq<WeightedPoint>) \n  returns (counts: array2<real>)\n{\n  counts := new real[config.nrbins, config.nmu_bins]((i,j) => 0.0);\n}", "output": "datatype Point = Point(x: real, y: real, z: real)\ndatatype WeightedPoint = WeightedPoint(point: Point, weight: real, jackknife: int)\nclass Configuration {\n  var nrbins: int\n  var nmu_bins: int  \n  var mu_max: real\n  var periodic: bool\n  var nthreads: int\n  constructor(rb: int, mb: int, mm: real, p: bool, nt: int)\n    requires rb > 0 && mb > 0\n    requires 0.0 < mm <= 1.0\n    requires nt > 0\n    ensures nrbins == rb && nmu_bins == mb\n    ensures mu_max == mm && periodic == p\n    ensures nthreads == nt\n  {\n    nrbins := rb;\n    nmu_bins := mb;\n    mu_max := mm;\n    periodic := p;\n    nthreads := nt;\n  }\n}\nmethod ReadWeightedPoints(filename: string) returns (points: seq<WeightedPoint>)\n  requires filename != \"\"\n  ensures |points| > 0\n  ensures forall i :: 0 <= i < |points| ==> points[i].weight > 0.0\n{\n  var p := WeightedPoint(Point(0.0, 0.0, 0.0), 1.0, 0);\n  points := [p];\n}\nmethod CoordTransform(p: Point) returns (comDist: real, ra: real, dec: real)\n  ensures comDist >= 0.0\n  ensures -180.0 <= ra <= 180.0 \n  ensures -90.0 <= dec <= 90.0\n{\n  var xsq := p.x * p.x;\n  var ysq := p.y * p.y;\n  var zsq := p.z * p.z;\n  comDist := xsq + ysq + zsq;\n  var s := xsq + ysq;\n  ra := if p.x >= 0.0 then 45.0 else -45.0;\n  dec := if s >= 0.0 then 45.0 else -45.0;\n}\nmethod ComputePairCounts(config: Configuration, points1: seq<WeightedPoint>, points2: seq<WeightedPoint>) \n  returns (counts: array2<real>)\n  requires config.nrbins > 0 && config.nmu_bins > 0\n  requires |points1| > 0 && |points2| > 0\n  ensures counts.Length0 == config.nrbins\n  ensures counts.Length1 == config.nmu_bins\n{\n  counts := new real[config.nrbins, config.nmu_bins]((i,j) => 0.0);\n}", "name": "py2dfy_247", "id": 247}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class EnergyReading {\n  var day: int\n  var energy: real\n  \n  constructor(d: int, e: real)\n  {\n    day := d;\n    energy := e;\n  }\n}\nclass WeeklyReading {\n  var weekStart: int\n  var totalEnergy: real\n  \n  constructor(w: int, e: real) \n  {\n    weekStart := w;\n    totalEnergy := e;\n  }\n}\nmethod AggregateEnergyReadings(dailyReadings: seq<EnergyReading>) returns (weeklyReadings: seq<WeeklyReading>)\n    weeklyReadings[i].weekStart < weeklyReadings[j].weekStart\n{\n  var currentWeek := GetWeekNumber(dailyReadings[0].day);\n  var weeklySum := dailyReadings[0].energy;\n  var result: seq<WeeklyReading> := [];\n  var i := 1;\n  \n  while i < |dailyReadings|\n      result[k].weekStart < result[l].weekStart\n      result[k].weekStart < currentWeek\n      result[k].totalEnergy >= 0.0\n      GetWeekNumber(dailyReadings[k].day) <= GetWeekNumber(dailyReadings[k+1].day)\n  {\n    var reading := dailyReadings[i];\n    var readingWeek := GetWeekNumber(reading.day);\n    \n    if readingWeek == currentWeek {\n      weeklySum := weeklySum + reading.energy;\n    } else {\n      var newReading := new WeeklyReading(currentWeek, weeklySum);\n      \n      result := result + [newReading];\n      \n      currentWeek := readingWeek;\n      weeklySum := reading.energy;\n    }\n    \n    i := i + 1;\n  }\n  \n  var finalReading := new WeeklyReading(currentWeek, weeklySum);\n  result := result + [finalReading];\n  weeklyReadings := result;\n    weeklyReadings[i].weekStart < weeklyReadings[j].weekStart;\n}\nfunction GetWeekNumber(day: int): int\n{\n  day / 7\n}", "output": "class EnergyReading {\n  var day: int\n  var energy: real\n  \n  constructor(d: int, e: real)\n  {\n    day := d;\n    energy := e;\n  }\n}\nclass WeeklyReading {\n  var weekStart: int\n  var totalEnergy: real\n  \n  constructor(w: int, e: real) \n    ensures weekStart == w && totalEnergy == e\n  {\n    weekStart := w;\n    totalEnergy := e;\n  }\n}\nmethod AggregateEnergyReadings(dailyReadings: seq<EnergyReading>) returns (weeklyReadings: seq<WeeklyReading>)\n  requires |dailyReadings| > 0\n  requires forall i :: 0 <= i < |dailyReadings| ==> dailyReadings[i].energy >= 0.0\n  requires forall i :: 0 <= i < |dailyReadings| ==> dailyReadings[i].day >= 0\n  requires forall i, j :: 0 <= i < j < |dailyReadings| ==> dailyReadings[i].day <= dailyReadings[j].day\n  ensures |weeklyReadings| > 0 \n  ensures forall i, j :: 0 <= i < j < |weeklyReadings| ==> \n    weeklyReadings[i].weekStart < weeklyReadings[j].weekStart\n  ensures forall i :: 0 <= i < |weeklyReadings| ==> weeklyReadings[i].totalEnergy >= 0.0\n{\n  var currentWeek := GetWeekNumber(dailyReadings[0].day);\n  var weeklySum := dailyReadings[0].energy;\n  var result: seq<WeeklyReading> := [];\n  var i := 1;\n  \n  while i < |dailyReadings|\n    invariant 1 <= i <= |dailyReadings|\n    invariant weeklySum >= 0.0\n    invariant currentWeek == GetWeekNumber(dailyReadings[i-1].day)\n    invariant forall k, l :: 0 <= k < l < |result| ==> \n      result[k].weekStart < result[l].weekStart\n    invariant forall k :: 0 <= k < |result| ==>\n      result[k].weekStart < currentWeek\n    invariant forall k :: 0 <= k < |result| ==>\n      result[k].totalEnergy >= 0.0\n    invariant forall k :: 0 <= k < i ==> GetWeekNumber(dailyReadings[k].day) <= currentWeek\n    invariant forall k :: 0 <= k < i-1 ==> \n      GetWeekNumber(dailyReadings[k].day) <= GetWeekNumber(dailyReadings[k+1].day)\n    decreases |dailyReadings| - i\n  {\n    var reading := dailyReadings[i];\n    var readingWeek := GetWeekNumber(reading.day);\n    \n    if readingWeek == currentWeek {\n      weeklySum := weeklySum + reading.energy;\n    } else {\n      assert readingWeek > currentWeek;\n      var newReading := new WeeklyReading(currentWeek, weeklySum);\n      \n      result := result + [newReading];\n      \n      currentWeek := readingWeek;\n      weeklySum := reading.energy;\n    }\n    \n    i := i + 1;\n  }\n  \n  var finalReading := new WeeklyReading(currentWeek, weeklySum);\n  result := result + [finalReading];\n  weeklyReadings := result;\n  assert |weeklyReadings| > 0;\n  assert forall i :: 0 <= i < |weeklyReadings| ==> weeklyReadings[i].totalEnergy >= 0.0;\n  assert forall i, j :: 0 <= i < j < |weeklyReadings| ==> \n    weeklyReadings[i].weekStart < weeklyReadings[j].weekStart;\n}\nfunction GetWeekNumber(day: int): int\n{\n  day / 7\n}", "name": "py2dfy_233", "id": 233}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module HashValidator {\n    \n    datatype ApiResponse = ApiResponse(success: bool, message: string, statusCode: int)\n    \n    method isValidMd5String(checkval: string) returns (isValid: bool)\n            ('0' <= checkval[i] <= '9') || ('a' <= checkval[i] <= 'f') || ('A' <= checkval[i] <= 'F')\n    {\n        isValid := |checkval| == 32 && forall i :: 0 <= i < |checkval| ==>\n            ('0' <= checkval[i] <= '9') || ('a' <= checkval[i] <= 'f') || ('A' <= checkval[i] <= 'F');\n    }\n    \n    method getHashResult(hash: string) returns (response: ApiResponse)\n    {\n        var isValid := isValidMd5String(hash);\n        if !isValid {\n            return ApiResponse(false, \"Invalid MD5 String\", 400);\n        }\n        \n        var inCache: bool;\n        var isClean: bool;\n        inCache := *;  \n        isClean := *;  \n        if inCache {\n            return ApiResponse(true, \"Hash found in cache\", 200);\n        } else {\n            \n            return ApiResponse(true, \"Hash checked externally\", 200);\n        }\n    }\n    \n    method clearAllCache() returns (response: ApiResponse)\n    {\n        \n        return ApiResponse(true, \"Cache Cleared\", 200);\n    }\n    \n    method Main()\n    {\n        var response := getHashResult(\"1234567890abcdef1234567890abcdef\");\n        print \"Hash check result: \", response, \"\\n\";\n        response := getHashResult(\"invalid_hash\");\n        print \"Invalid hash check result: \", response, \"\\n\";\n        response := clearAllCache();\n        print \"Cache clear result: \", response, \"\\n\";\n    }\n}", "output": "module HashValidator {\n    \n    datatype ApiResponse = ApiResponse(success: bool, message: string, statusCode: int)\n    \n    method isValidMd5String(checkval: string) returns (isValid: bool)\n        ensures isValid <==> |checkval| == 32 && forall i :: 0 <= i < |checkval| ==>\n            ('0' <= checkval[i] <= '9') || ('a' <= checkval[i] <= 'f') || ('A' <= checkval[i] <= 'F')\n    {\n        isValid := |checkval| == 32 && forall i :: 0 <= i < |checkval| ==>\n            ('0' <= checkval[i] <= '9') || ('a' <= checkval[i] <= 'f') || ('A' <= checkval[i] <= 'F');\n    }\n    \n    method getHashResult(hash: string) returns (response: ApiResponse)\n        requires |hash| > 0\n        ensures response.statusCode == 200 ==> response.success\n        ensures response.statusCode == 400 ==> !response.success\n    {\n        var isValid := isValidMd5String(hash);\n        if !isValid {\n            return ApiResponse(false, \"Invalid MD5 String\", 400);\n        }\n        \n        var inCache: bool;\n        var isClean: bool;\n        inCache := *;  \n        isClean := *;  \n        if inCache {\n            return ApiResponse(true, \"Hash found in cache\", 200);\n        } else {\n            \n            return ApiResponse(true, \"Hash checked externally\", 200);\n        }\n    }\n    \n    method clearAllCache() returns (response: ApiResponse)\n        ensures response.success\n        ensures response.statusCode == 200\n    {\n        \n        return ApiResponse(true, \"Cache Cleared\", 200);\n    }\n    \n    method Main()\n    {\n        var response := getHashResult(\"1234567890abcdef1234567890abcdef\");\n        print \"Hash check result: \", response, \"\\n\";\n        response := getHashResult(\"invalid_hash\");\n        print \"Invalid hash check result: \", response, \"\\n\";\n        response := clearAllCache();\n        print \"Cache clear result: \", response, \"\\n\";\n    }\n}", "name": "py2dfy_266", "id": 266}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method ConvertToDigitArray(n: int) returns (arr: array<int>)\n{\n    arr := new int[5];\n    arr[0] := n % 10;\n    arr[1] := (n / 10) % 10;\n    arr[2] := (n / 100) % 10;\n    arr[3] := (n / 1000) % 10;\n    arr[4] := (n / 10000) % 10;\n}\nmethod AddDigitArrays(a: array<int>, b: array<int>) returns (sum: array<int>)\n{\n    sum := new int[5];\n    var carry := 0;\n    var i := 0;\n    \n    while i < 5\n    {\n        var digitSum := a[i] + b[i] + carry;\n        sum[i] := digitSum % 10;\n        carry := digitSum / 10;\n        i := i + 1;\n    }\n}\nmethod Main() {\n    var a := 1234;\n    var b := 5678;\n    var arrA := ConvertToDigitArray(a);\n    var arrB := ConvertToDigitArray(b);\n    var sumArr := AddDigitArrays(arrA, arrB);\n    var sumResult := \n        sumArr[4] * 10000 + \n        sumArr[3] * 1000 + \n        sumArr[2] * 100 + \n        sumArr[1] * 10 + \n        sumArr[0];\n    print \"Sum of \", a, \" and \", b, \" is \", sumResult, \"\\n\";\n}", "output": "method ConvertToDigitArray(n: int) returns (arr: array<int>)\n    requires 0 <= n < 10000\n    ensures arr.Length == 5\n    ensures forall i :: 0 <= i < arr.Length ==> 0 <= arr[i] < 10\n    ensures arr[0] == n % 10\n    ensures arr[1] == (n / 10) % 10 \n    ensures arr[2] == (n / 100) % 10\n    ensures arr[3] == (n / 1000) % 10\n    ensures arr[4] == (n / 10000) % 10\n{\n    arr := new int[5];\n    arr[0] := n % 10;\n    arr[1] := (n / 10) % 10;\n    arr[2] := (n / 100) % 10;\n    arr[3] := (n / 1000) % 10;\n    arr[4] := (n / 10000) % 10;\n}\nmethod AddDigitArrays(a: array<int>, b: array<int>) returns (sum: array<int>)\n    requires a.Length == 5 && b.Length == 5\n    requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < 10\n    requires forall i :: 0 <= i < b.Length ==> 0 <= b[i] < 10\n    ensures sum.Length == 5\n    ensures forall i :: 0 <= i < sum.Length ==> 0 <= sum[i] < 10\n{\n    sum := new int[5];\n    var carry := 0;\n    var i := 0;\n    \n    while i < 5\n        invariant 0 <= i <= 5\n        invariant 0 <= carry <= 1\n        invariant forall j :: 0 <= j < i ==> 0 <= sum[j] < 10\n    {\n        var digitSum := a[i] + b[i] + carry;\n        sum[i] := digitSum % 10;\n        carry := digitSum / 10;\n        i := i + 1;\n    }\n}\nmethod Main() {\n    var a := 1234;\n    var b := 5678;\n    var arrA := ConvertToDigitArray(a);\n    var arrB := ConvertToDigitArray(b);\n    var sumArr := AddDigitArrays(arrA, arrB);\n    var sumResult := \n        sumArr[4] * 10000 + \n        sumArr[3] * 1000 + \n        sumArr[2] * 100 + \n        sumArr[1] * 10 + \n        sumArr[0];\n    print \"Sum of \", a, \" and \", b, \" is \", sumResult, \"\\n\";\n}", "name": "py2dfy_256", "id": 256}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module correctMaxExample{\n    predicate maxSpec(a:int,b:int,c:int)\n    {\n        c >= a\n        && c >= b\n        && (c == b || c ==a)\n    }\n    \n    \n    \n    \n    lemma max(a:int,b:int) returns (c:int)\n    {\n        if(a > b){\n            c := a;\n        }else{\n            c := b;\n        }\n    }\n}", "output": "module correctMaxExample{\n    predicate maxSpec(a:int,b:int,c:int)\n    {\n        c >= a\n        && c >= b\n        && (c == b || c ==a)\n    }\n    \n    \n    \n    \n    lemma max(a:int,b:int) returns (c:int)\n        ensures maxSpec(a,b,c)\n    {\n        if(a > b){\n            c := a;\n        }else{\n            c := b;\n        }\n    }\n}", "name": "py2dfy_286", "id": 286}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Position = Position(row: int, col: int)\nclass Grid {\n  var data: array2<char>\n  \n  constructor(rows: int, cols: int)\n  {\n    data := new char[rows, cols];\n  }\n}\npredicate IsValidPosition(grid: Grid, pos: Position, n: int)\n{\n  0 <= pos.row < grid.data.Length0 && \n  0 <= pos.col < grid.data.Length1 &&\n  grid.data[pos.row, pos.col] == '.'\n}\nmethod CountPaths(grid: Grid) returns (count: int)\n    0 <= i < grid.data.Length0 && 0 <= j < grid.data.Length1 ==> \n    (grid.data[i,j] == '.' || grid.data[i,j] == 'X')\n{\n  var n := grid.data.Length1;\n  \n  \n  var totalPaths := Pow2(n-1) - 1;\n  count := 0;\n  var pathNum := 0;\n  while pathNum <= totalPaths\n  {\n    var pos := Position(0, 0);\n    var valid := IsValidPosition(grid, pos, n);\n    \n    \n    var remainingMoves := pathNum;\n    var moveIndex := 0;\n    while moveIndex < n-1 && valid\n    {\n      var moveRight := remainingMoves % 2 == 1;\n      remainingMoves := remainingMoves / 2;\n      \n      if moveRight {\n        \n        var newPos := Position(pos.row, pos.col + 1);\n        if !IsValidPosition(grid, newPos, n) {\n          valid := false;\n        }\n        pos := newPos;\n      } else {\n        \n        var newRow := if pos.row == 0 then 1 else 0;\n        var newPos := Position(newRow, pos.col + 1);\n        if !IsValidPosition(grid, newPos, n) {\n          valid := false;\n        }\n        pos := newPos;\n      }\n      \n      moveIndex := moveIndex + 1;\n    }\n    \n    if valid && pos.row == 1 && pos.col == n-1 {\n      count := count + 1;\n    }\n    pathNum := pathNum + 1;\n  }\n  \n  if count == 0 {\n    count := -1;\n  }\n}\nfunction Pow2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Pow2(n-1)\n}", "output": "datatype Position = Position(row: int, col: int)\nclass Grid {\n  var data: array2<char>\n  \n  constructor(rows: int, cols: int)\n    requires rows > 0 && cols > 0\n    ensures data.Length0 == rows\n    ensures data.Length1 == cols\n  {\n    data := new char[rows, cols];\n  }\n}\npredicate IsValidPosition(grid: Grid, pos: Position, n: int)\n  reads grid, grid.data\n{\n  0 <= pos.row < grid.data.Length0 && \n  0 <= pos.col < grid.data.Length1 &&\n  grid.data[pos.row, pos.col] == '.'\n}\nmethod CountPaths(grid: Grid) returns (count: int)\n  requires grid.data.Length0 == 2  \n  requires grid.data.Length1 > 0   \n  requires forall i, j :: \n    0 <= i < grid.data.Length0 && 0 <= j < grid.data.Length1 ==> \n    (grid.data[i,j] == '.' || grid.data[i,j] == 'X')\n  ensures count >= -1  \n{\n  var n := grid.data.Length1;\n  \n  \n  var totalPaths := Pow2(n-1) - 1;\n  count := 0;\n  var pathNum := 0;\n  while pathNum <= totalPaths\n    invariant 0 <= pathNum <= totalPaths + 1\n    invariant count >= 0\n    decreases totalPaths - pathNum\n  {\n    var pos := Position(0, 0);\n    var valid := IsValidPosition(grid, pos, n);\n    \n    \n    var remainingMoves := pathNum;\n    var moveIndex := 0;\n    while moveIndex < n-1 && valid\n      invariant 0 <= moveIndex <= n-1\n      invariant valid ==> IsValidPosition(grid, pos, n)\n      invariant pos.col == moveIndex\n      decreases n-1 - moveIndex\n    {\n      var moveRight := remainingMoves % 2 == 1;\n      remainingMoves := remainingMoves / 2;\n      \n      if moveRight {\n        \n        var newPos := Position(pos.row, pos.col + 1);\n        if !IsValidPosition(grid, newPos, n) {\n          valid := false;\n        }\n        pos := newPos;\n      } else {\n        \n        var newRow := if pos.row == 0 then 1 else 0;\n        var newPos := Position(newRow, pos.col + 1);\n        if !IsValidPosition(grid, newPos, n) {\n          valid := false;\n        }\n        pos := newPos;\n      }\n      \n      moveIndex := moveIndex + 1;\n    }\n    \n    if valid && pos.row == 1 && pos.col == n-1 {\n      count := count + 1;\n    }\n    pathNum := pathNum + 1;\n  }\n  \n  if count == 0 {\n    count := -1;\n  }\n}\nfunction Pow2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Pow2(n-1)\n}", "name": "py2dfy_261", "id": 261}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class TrueToggleButton {\n  \n  var joystick: Joystick  \n  var buttonNum: nat      \n  var pressed: bool       \n  var released: bool      \n  var pressedLock: bool   \n  var releasedLock: bool  \n  \n  predicate Valid()\n  {\n    \n    buttonNum > 0 &&\n    \n    !(pressed && released) &&\n    \n    !(pressedLock && releasedLock)\n  }\n  constructor(j: Joystick, bNum: nat)\n  {\n    joystick := j;\n    buttonNum := bNum;\n    pressed := false;\n    released := false;\n    pressedLock := false;\n    releasedLock := false;\n  }\n  \n  method getRawButton() returns (isPressed: bool)\n  {\n    isPressed := joystick.getRawButton(buttonNum);\n  }\n  \n  method getPressed() returns (result: bool)\n  {\n    result := pressed;\n    pressed := false;\n  }\n  \n  method getReleased() returns (result: bool)\n  {\n    result := released;\n    released := false;\n  }\n  \n  method update()\n  {\n    var currentButtonState := getRawButton();\n    \n    if currentButtonState && !pressedLock {\n      pressed := true;\n      released := false;\n      pressedLock := true;\n      releasedLock := false;\n    } else if !currentButtonState && !releasedLock {\n      pressed := false;\n      released := true;\n      pressedLock := false;\n      releasedLock := true;\n    }\n  }\n}\nclass Joystick {\n  \n  method getRawButton(buttonNum: nat) returns (isPressed: bool)\n}", "output": "class TrueToggleButton {\n  \n  var joystick: Joystick  \n  var buttonNum: nat      \n  var pressed: bool       \n  var released: bool      \n  var pressedLock: bool   \n  var releasedLock: bool  \n  \n  predicate Valid()\n    reads this\n  {\n    \n    buttonNum > 0 &&\n    \n    !(pressed && released) &&\n    \n    !(pressedLock && releasedLock)\n  }\n  constructor(j: Joystick, bNum: nat)\n    requires bNum > 0\n    ensures Valid()\n    ensures joystick == j\n    ensures buttonNum == bNum\n    ensures !pressed && !released\n    ensures !pressedLock && !releasedLock\n  {\n    joystick := j;\n    buttonNum := bNum;\n    pressed := false;\n    released := false;\n    pressedLock := false;\n    releasedLock := false;\n  }\n  \n  method getRawButton() returns (isPressed: bool)\n    requires Valid()\n    ensures Valid()\n  {\n    isPressed := joystick.getRawButton(buttonNum);\n  }\n  \n  method getPressed() returns (result: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures result == old(pressed)\n    ensures !pressed  \n    ensures released == old(released)\n    ensures pressedLock == old(pressedLock)\n    ensures releasedLock == old(releasedLock)\n  {\n    result := pressed;\n    pressed := false;\n  }\n  \n  method getReleased() returns (result: bool)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures result == old(released)\n    ensures !released  \n    ensures pressed == old(pressed)\n    ensures pressedLock == old(pressedLock)\n    ensures releasedLock == old(releasedLock)\n  {\n    result := released;\n    released := false;\n  }\n  \n  method update()\n    requires Valid()\n    ensures Valid()\n    modifies this\n  {\n    var currentButtonState := getRawButton();\n    \n    if currentButtonState && !pressedLock {\n      pressed := true;\n      released := false;\n      pressedLock := true;\n      releasedLock := false;\n    } else if !currentButtonState && !releasedLock {\n      pressed := false;\n      released := true;\n      pressedLock := false;\n      releasedLock := true;\n    }\n  }\n}\nclass Joystick {\n  \n  method getRawButton(buttonNum: nat) returns (isPressed: bool)\n    requires buttonNum > 0\n}", "name": "py2dfy_252", "id": 252}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module LinearRegression {\n    \n    function DotProduct(v1: seq<real>, v2: seq<real>): real\n    {\n        if |v1| == 0 then 0.0\n        else v1[0] * v2[0] + DotProduct(v1[1..], v2[1..])\n    }\n    \n    function LinearFunction(X: seq<seq<real>>, Theta: seq<real>): seq<real>\n    {\n        if |X| == 0 then []\n        else [DotProduct(X[0], Theta)] + LinearFunction(X[1..], Theta)\n    }\n    \n    function MSELoss(X: seq<seq<real>>, Theta: seq<real>, y_true: seq<real>): real\n    {\n        var y_pred := LinearFunction(X, Theta);\n        SumOfSquaredDifferences(y_pred, y_true) / |y_true| as real\n    }\n    \n    function SumOfSquaredDifferences(v1: seq<real>, v2: seq<real>): real\n    {\n        if |v1| == 0 then 0.0\n        else (v1[0] - v2[0]) * (v1[0] - v2[0]) + SumOfSquaredDifferences(v1[1..], v2[1..])\n    }\n    \n    method GradientFunction(Theta: seq<real>, X: seq<seq<real>>, y_true: seq<real>) returns (grad: seq<real>)\n    {\n        var y_pred := LinearFunction(X, Theta);\n        grad := seq(|Theta|, i => 0.0);\n        \n        var n := |X|;\n        var m := |Theta|;\n        \n        var i := 0;\n        while i < m\n        {\n            var sum := 0.0;\n            var j := 0;\n            while j < n\n            {\n                sum := sum + (y_pred[j] - y_true[j]) * X[j][i];\n                j := j + 1;\n            }\n            grad := grad[i := 2.0 * sum / (n as real)];\n            i := i + 1;\n        }\n    }\n    \n    method GradientDescent(Theta: seq<real>, X: seq<seq<real>>, y: seq<real>, alpha: real, iters: nat) returns (theta: seq<real>)\n    {\n        theta := Theta;\n        var i := 0;\n        while i < iters\n        {\n            var grad := GradientFunction(theta, X, y);\n            var j := 0;\n            var new_theta := seq(|theta|, _ => 0.0);\n            while j < |theta|\n            {\n                new_theta := new_theta[j := theta[j] - alpha * grad[j]];\n                j := j + 1;\n            }\n            theta := new_theta;\n            i := i + 1;\n        }\n    }\n}", "output": "module LinearRegression {\n    \n    function DotProduct(v1: seq<real>, v2: seq<real>): real\n        requires |v1| == |v2|\n        ensures |v1| == 0 ==> DotProduct(v1, v2) == 0.0\n    {\n        if |v1| == 0 then 0.0\n        else v1[0] * v2[0] + DotProduct(v1[1..], v2[1..])\n    }\n    \n    function LinearFunction(X: seq<seq<real>>, Theta: seq<real>): seq<real>\n        requires forall i :: 0 <= i < |X| ==> |X[i]| == |Theta|\n        ensures |LinearFunction(X, Theta)| == |X|\n    {\n        if |X| == 0 then []\n        else [DotProduct(X[0], Theta)] + LinearFunction(X[1..], Theta)\n    }\n    \n    function MSELoss(X: seq<seq<real>>, Theta: seq<real>, y_true: seq<real>): real\n        requires |X| == |y_true|\n        requires |X| > 0\n        requires forall i :: 0 <= i < |X| ==> |X[i]| == |Theta|\n        ensures MSELoss(X, Theta, y_true) >= 0.0\n    {\n        var y_pred := LinearFunction(X, Theta);\n        SumOfSquaredDifferences(y_pred, y_true) / |y_true| as real\n    }\n    \n    function SumOfSquaredDifferences(v1: seq<real>, v2: seq<real>): real\n        requires |v1| == |v2|\n        ensures SumOfSquaredDifferences(v1, v2) >= 0.0\n    {\n        if |v1| == 0 then 0.0\n        else (v1[0] - v2[0]) * (v1[0] - v2[0]) + SumOfSquaredDifferences(v1[1..], v2[1..])\n    }\n    \n    method GradientFunction(Theta: seq<real>, X: seq<seq<real>>, y_true: seq<real>) returns (grad: seq<real>)\n        requires |X| > 0\n        requires forall i :: 0 <= i < |X| ==> |X[i]| == |Theta|\n        requires |X| == |y_true|\n        ensures |grad| == |Theta|\n    {\n        var y_pred := LinearFunction(X, Theta);\n        grad := seq(|Theta|, i => 0.0);\n        \n        var n := |X|;\n        var m := |Theta|;\n        \n        var i := 0;\n        while i < m\n            invariant 0 <= i <= m\n            invariant |grad| == m\n        {\n            var sum := 0.0;\n            var j := 0;\n            while j < n\n                invariant 0 <= j <= n\n            {\n                sum := sum + (y_pred[j] - y_true[j]) * X[j][i];\n                j := j + 1;\n            }\n            grad := grad[i := 2.0 * sum / (n as real)];\n            i := i + 1;\n        }\n    }\n    \n    method GradientDescent(Theta: seq<real>, X: seq<seq<real>>, y: seq<real>, alpha: real, iters: nat) returns (theta: seq<real>)\n        requires |X| > 0\n        requires forall i :: 0 <= i < |X| ==> |X[i]| == |Theta|\n        requires |X| == |y|\n        requires alpha > 0.0\n        ensures |theta| == |Theta|\n    {\n        theta := Theta;\n        var i := 0;\n        while i < iters\n            invariant 0 <= i <= iters\n            invariant |theta| == |Theta|\n        {\n            var grad := GradientFunction(theta, X, y);\n            var j := 0;\n            var new_theta := seq(|theta|, _ => 0.0);\n            while j < |theta|\n                invariant 0 <= j <= |theta|\n                invariant |new_theta| == |theta|\n            {\n                new_theta := new_theta[j := theta[j] - alpha * grad[j]];\n                j := j + 1;\n            }\n            theta := new_theta;\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_241", "id": 241}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype URL = URL(segments: seq<string>, params: map<string, string>)\ndatatype Response = Response(content: seq<int>) \ndatatype JSONValue = \n  | JNull\n  | JBool(b: bool)\n  | JNumber(n: int)\n  | JString(s: string)\n  | JArray(items: seq<JSONValue>)\n  | JObject(fields: map<string, JSONValue>)\nclass Request {\n  var url: URL\n  constructor(segments: seq<string>, params: map<string, string>)\n  {\n    this.url := URL(segments, params);\n  }\n  method Raw() returns (result: Result<Response, string>)\n  {\n    return Success(Response([]));\n  }\n  method ParseJSON(response: Response) returns (result: Result<JSONValue, string>)\n  {\n    return Success(JObject(map[]));\n  }\n  method ParseCSV(response: Response) returns (result: Result<seq<map<string, string>>, string>)\n  {\n    var lines := SplitLines(response.content);\n    if |lines| == 0 {\n      return Failure(\"Empty CSV\");\n    }\n    var headers := SplitCSVLine(lines[0]);\n    if |headers| == 0 {\n      return Failure(\"Invalid CSV header\");\n    }\n    var result_rows: seq<map<string, string>> := [];\n    var i := 1;\n    ghost var seen: set<string> := {};\n    while i < |lines|\n        forall key :: key in row ==> key in headers\n    {\n      var line := SplitCSVLine(lines[i]);\n      if |line| != |headers| {\n        return Failure(\"Mismatched column count\");\n      }\n      var row_map := BuildRowMap(headers, line);\n      result_rows := result_rows + [row_map];\n      i := i + 1;\n    }\n    \n    if |result_rows| == 0 {\n      var empty_row := BuildRowMap(headers, seq(|headers|, i => \"\"));\n      result_rows := [empty_row];\n    }\n    return Success(result_rows);\n  }\n  static method SplitLines(content: seq<int>) returns (lines: seq<seq<int>>)\n  {\n    return [];\n  }\n  static method SplitCSVLine(line: seq<int>) returns (fields: seq<string>)\n  {\n    return [];\n  }\n  static method BuildRowMap(headers: seq<string>, values: seq<string>) returns (row: map<string, string>)\n  {\n    row := map[];\n    var i := 0;\n    while i < |headers|\n    {\n      row := row[headers[i] := values[i]];\n      i := i + 1;\n    }\n  }\n}\ndatatype Result<T, E> = Success(value: T) | Failure(error: E) {\n  predicate IsSuccess() {\n    Success?\n  }\n  \n  predicate IsFailure() {\n    Failure?\n  }\n}", "output": "datatype URL = URL(segments: seq<string>, params: map<string, string>)\ndatatype Response = Response(content: seq<int>) \ndatatype JSONValue = \n  | JNull\n  | JBool(b: bool)\n  | JNumber(n: int)\n  | JString(s: string)\n  | JArray(items: seq<JSONValue>)\n  | JObject(fields: map<string, JSONValue>)\nclass Request {\n  var url: URL\n  constructor(segments: seq<string>, params: map<string, string>)\n    ensures this.url == URL(segments, params)\n  {\n    this.url := URL(segments, params);\n  }\n  method Raw() returns (result: Result<Response, string>)\n    ensures result.IsFailure() ==> |result.error| > 0\n  {\n    return Success(Response([]));\n  }\n  method ParseJSON(response: Response) returns (result: Result<JSONValue, string>)\n    requires |response.content| < 0x1_0000_0000\n    ensures result.IsFailure() ==> |result.error| > 0\n  {\n    return Success(JObject(map[]));\n  }\n  method ParseCSV(response: Response) returns (result: Result<seq<map<string, string>>, string>)\n    requires |response.content| < 0x1_0000_0000\n    ensures result.IsSuccess() ==> |result.value| > 0\n    ensures result.IsFailure() ==> |result.error| > 0\n  {\n    var lines := SplitLines(response.content);\n    if |lines| == 0 {\n      return Failure(\"Empty CSV\");\n    }\n    var headers := SplitCSVLine(lines[0]);\n    if |headers| == 0 {\n      return Failure(\"Invalid CSV header\");\n    }\n    var result_rows: seq<map<string, string>> := [];\n    var i := 1;\n    ghost var seen: set<string> := {};\n    while i < |lines|\n      invariant 1 <= i <= |lines|\n      invariant forall row :: row in result_rows ==> \n        forall key :: key in row ==> key in headers\n      decreases |lines| - i\n    {\n      var line := SplitCSVLine(lines[i]);\n      if |line| != |headers| {\n        return Failure(\"Mismatched column count\");\n      }\n      var row_map := BuildRowMap(headers, line);\n      result_rows := result_rows + [row_map];\n      i := i + 1;\n    }\n    \n    if |result_rows| == 0 {\n      var empty_row := BuildRowMap(headers, seq(|headers|, i => \"\"));\n      result_rows := [empty_row];\n    }\n    return Success(result_rows);\n  }\n  static method SplitLines(content: seq<int>) returns (lines: seq<seq<int>>)\n    ensures forall line :: line in lines ==> |line| <= |content|\n  {\n    return [];\n  }\n  static method SplitCSVLine(line: seq<int>) returns (fields: seq<string>)\n    ensures forall field :: field in fields ==> |field| <= |line|\n  {\n    return [];\n  }\n  static method BuildRowMap(headers: seq<string>, values: seq<string>) returns (row: map<string, string>)\n    requires |headers| == |values|\n    ensures forall key :: key in row ==> key in headers\n    ensures forall i :: 0 <= i < |headers| ==> headers[i] in row\n  {\n    row := map[];\n    var i := 0;\n    while i < |headers|\n      invariant 0 <= i <= |headers|\n      invariant forall key :: key in row ==> key in headers[..i]\n      invariant forall j :: 0 <= j < i ==> headers[j] in row\n    {\n      row := row[headers[i] := values[i]];\n      i := i + 1;\n    }\n  }\n}\ndatatype Result<T, E> = Success(value: T) | Failure(error: E) {\n  predicate IsSuccess() {\n    Success?\n  }\n  \n  predicate IsFailure() {\n    Failure?\n  }\n}", "name": "py2dfy_258", "id": 258}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "const FILTER_CONST: string := \"__filtered_out__crispum__\"\nmethod filterParser(options: seq<string>, data: string) returns (result: string)\n{\n  return FILTER_CONST;\n}\nmethod Main()\n{\n  var options := [\"option1\", \"option2\"];\n  var data := \"some data\";\n  var result := filterParser(options, data);\n  print \"Filter result: \", result, \"\\n\";\n}", "output": "const FILTER_CONST: string := \"__filtered_out__crispum__\"\nmethod filterParser(options: seq<string>, data: string) returns (result: string)\n  ensures result == FILTER_CONST\n{\n  return FILTER_CONST;\n}\nmethod Main()\n{\n  var options := [\"option1\", \"option2\"];\n  var data := \"some data\";\n  var result := filterParser(options, data);\n  assert result == FILTER_CONST;\n  print \"Filter result: \", result, \"\\n\";\n}", "name": "py2dfy_294", "id": 294}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Form {\n    var name: string\n    var content: string  \n    var isPublic: bool\n    var uuid: string\n    \n    var createdOn: int  \n    var modifiedOn: int\n    var createdBy: int  \n    var modifiedBy: int\n    \n    predicate ValidState()\n    {\n        name != \"\" &&\n        uuid != \"\" &&\n        createdOn >= 0 &&\n        modifiedOn >= createdOn &&\n        createdBy >= 0 &&\n        modifiedBy >= 0\n    }\n    \n    constructor(userName: string, userId: int, currentTime: int)\n    {\n        name := \"Example: Job Application\";\n        content := DefaultContent();\n        isPublic := false;\n        uuid := \"generated-uuid\"; \n        createdOn := currentTime;\n        modifiedOn := currentTime;\n        createdBy := userId;\n        modifiedBy := userId;\n    }\n    \n    method GenerateUUID() returns (uuid: string)\n    {\n        uuid := \"generated-uuid\";\n    }\n    \n    method UpdateContent(newContent: string, userId: int, currentTime: int)\n    {\n        content := newContent;\n        modifiedOn := currentTime;\n        modifiedBy := userId;\n    }\n    \n    method SetPublic(makePublic: bool)\n    {\n        isPublic := makePublic;\n    }\n    \n    static function DefaultContent(): string\n    {\n        \"# Job Application\\n\" +\n        \"## Instructions\\n\" +\n        \"- please complete the form\\n\" +\n        \"- export it in PDF\\n\" +\n        \"- print it\\n\" +\n        \"- sign it\\n\" +\n        \"- fax it to 111-111-1111\\n\" +\n        \"## Job Application Questionnaire\\n\" +\n        \"### Personal data\\n\"\n    }\n}", "output": "class Form {\n    var name: string\n    var content: string  \n    var isPublic: bool\n    var uuid: string\n    \n    var createdOn: int  \n    var modifiedOn: int\n    var createdBy: int  \n    var modifiedBy: int\n    \n    predicate ValidState()\n    reads this\n    {\n        name != \"\" &&\n        uuid != \"\" &&\n        createdOn >= 0 &&\n        modifiedOn >= createdOn &&\n        createdBy >= 0 &&\n        modifiedBy >= 0\n    }\n    \n    constructor(userName: string, userId: int, currentTime: int)\n    requires userId >= 0\n    requires currentTime >= 0\n    requires userName != \"\"\n    ensures ValidState()\n    ensures name == \"Example: Job Application\"\n    ensures createdBy == userId\n    ensures modifiedBy == userId\n    ensures createdOn == currentTime\n    ensures modifiedOn == currentTime\n    {\n        name := \"Example: Job Application\";\n        content := DefaultContent();\n        isPublic := false;\n        uuid := \"generated-uuid\"; \n        createdOn := currentTime;\n        modifiedOn := currentTime;\n        createdBy := userId;\n        modifiedBy := userId;\n    }\n    \n    method GenerateUUID() returns (uuid: string)\n    ensures uuid != \"\"\n    {\n        uuid := \"generated-uuid\";\n    }\n    \n    method UpdateContent(newContent: string, userId: int, currentTime: int)\n    requires ValidState()\n    requires userId >= 0\n    requires currentTime >= modifiedOn\n    modifies this\n    ensures ValidState()\n    ensures content == newContent\n    ensures modifiedBy == userId\n    ensures modifiedOn == currentTime\n    {\n        content := newContent;\n        modifiedOn := currentTime;\n        modifiedBy := userId;\n    }\n    \n    method SetPublic(makePublic: bool)\n    requires ValidState()\n    modifies this\n    ensures ValidState()\n    ensures isPublic == makePublic\n    {\n        isPublic := makePublic;\n    }\n    \n    static function DefaultContent(): string\n    {\n        \"# Job Application\\n\" +\n        \"## Instructions\\n\" +\n        \"- please complete the form\\n\" +\n        \"- export it in PDF\\n\" +\n        \"- print it\\n\" +\n        \"- sign it\\n\" +\n        \"- fax it to 111-111-1111\\n\" +\n        \"## Job Application Questionnaire\\n\" +\n        \"### Personal data\\n\"\n    }\n}", "name": "py2dfy_287", "id": 287}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function fib(n : nat ) : nat\n  {\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n  }\nmethod computeFib (n : nat) returns (x : nat)\n{\n  var i := 0;\n  x := 0;\n  var y := 1;\n  \n  while  i < n\n  {\n    x, y := y, x + y; \n    i := i + 1;\n  }\n}\nmethod Main() {\n  print \"hello, Dafny\\n\";\n  var x := computeFib(1);\n  print x;\n  print \"\\n\";\n  x := computeFib(2);\n  print x;\n  print \"\\n\";\n  x := computeFib(3);\n  print x;\n  print \"\\n\";\n  x := computeFib(4);\n  print x;\n  print \"\\n\";\n  x := computeFib(5);\n  print x;\n  print \"\\n\";\n  \n}", "output": "function fib(n : nat ) : nat\n  decreases n\n  {\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n  }\nmethod computeFib (n : nat) returns (x : nat)\nensures fib(n) == x\n{\n  var i := 0;\n  x := 0;\n  var y := 1;\n  \n  while  i < n\n    decreases n - i\n    invariant x == fib(i)\n    invariant y == fib(i + 1)\n    invariant i <= n\n  {\n    x, y := y, x + y; \n    i := i + 1;\n  }\n}\nmethod Main() {\n  print \"hello, Dafny\\n\";\n  var x := computeFib(1);\n  print x;\n  print \"\\n\";\n  x := computeFib(2);\n  print x;\n  print \"\\n\";\n  x := computeFib(3);\n  print x;\n  print \"\\n\";\n  x := computeFib(4);\n  print x;\n  print \"\\n\";\n  x := computeFib(5);\n  print x;\n  print \"\\n\";\n  \n}", "name": "py2dfy_291", "id": 291}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Login = Login(created: nat, loginAddr: seq<char>, hostname: seq<char>)\nfunction GetCurrentTimestamp(): nat\n{\n  1633046400000000 \n}\nfunction IsValidIpAddress(ip: seq<char>): bool\n{\n  0 <= |ip| && |ip| <= 45 \n}\nfunction IsValidHostname(hostname: seq<char>): bool\n{\n  0 <= |hostname| && |hostname| <= 200\n}\nmethod CreateLogin(loginAddr: seq<char>, hostname: seq<char>) returns (login: Login)\n{\n  var timestamp := GetCurrentTimestamp();\n  login := Login(timestamp, loginAddr, hostname);\n}", "output": "datatype Login = Login(created: nat, loginAddr: seq<char>, hostname: seq<char>)\nfunction GetCurrentTimestamp(): nat\n  ensures 0 <= GetCurrentTimestamp()\n{\n  1633046400000000 \n}\nfunction IsValidIpAddress(ip: seq<char>): bool\n  requires ip != []\n  ensures IsValidIpAddress(ip) ==> 0 <= |ip| <= 45\n{\n  0 <= |ip| && |ip| <= 45 \n}\nfunction IsValidHostname(hostname: seq<char>): bool\n  requires hostname != []\n  ensures IsValidHostname(hostname) ==> 0 <= |hostname| <= 200\n{\n  0 <= |hostname| && |hostname| <= 200\n}\nmethod CreateLogin(loginAddr: seq<char>, hostname: seq<char>) returns (login: Login)\n  requires loginAddr != [] && IsValidIpAddress(loginAddr)\n  requires hostname != [] && IsValidHostname(hostname)\n  ensures login.created >= 0\n  ensures login.loginAddr == loginAddr\n  ensures login.hostname == hostname\n{\n  var timestamp := GetCurrentTimestamp();\n  login := Login(timestamp, loginAddr, hostname);\n}", "name": "py2dfy_292", "id": 292}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Matrix {\n  var rows: nat\n  var cols: nat\n  var data: array2<real>\n  \n  constructor(r: nat, c: nat)\n  {\n    rows := r;\n    cols := c;\n    data := new real[r,c];\n  }\n}\nclass PRENHead {\n  var inChannels: nat\n  var outChannels: nat  \n  var weights: Matrix  \n  var bias: array<real>  \n  \n  constructor(in_ch: nat, out_ch: nat)\n  {\n    inChannels := in_ch;\n    outChannels := out_ch;\n    weights := new Matrix(out_ch, in_ch);\n    bias := new real[out_ch];\n  }\n  \n  method Forward(x: Matrix, isTraining: bool) returns (result: Matrix)\n  {\n    \n    result := new Matrix(x.rows, outChannels);\n    \n    \n    var i := 0;\n    while i < x.rows\n    {\n      var j := 0;\n      while j < outChannels\n      {\n        var sum := 0.0;\n        var k := 0;\n        while k < inChannels\n        {\n          sum := sum + x.data[i,k] * weights.data[j,k];\n          k := k + 1;\n        }\n        result.data[i,j] := sum + bias[j];\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    if !isTraining {\n      ApplySoftmax(result);\n    }\n  }\n  \n  method ApplySoftmax(matrix: Matrix)\n  {\n    var i := 0;\n    while i < matrix.rows\n    {\n      \n      var maxVal := matrix.data[i,0];\n      var j := 1;\n      while j < matrix.cols\n      {\n        if matrix.data[i,j] > maxVal {\n          maxVal := matrix.data[i,j];\n        }\n        j := j + 1;\n      }\n      \n      var sum := 0.0;\n      j := 0;\n      while j < matrix.cols\n      {\n        matrix.data[i,j] := Exp(matrix.data[i,j] - maxVal);\n        sum := sum + matrix.data[i,j];\n        j := j + 1;\n      }\n      \n      \n      j := 0;\n      while j < matrix.cols\n      {\n        matrix.data[i,j] := matrix.data[i,j] / sum;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  function Exp(x: real): real\n  {\n    \n    var result := 1.0 + x + (x * x) / 2.0 + (x * x * x) / 6.0 + (x * x * x * x) / 24.0;\n    if result <= 0.0 then 0.000001 else result\n  }\n}", "output": "class Matrix {\n  var rows: nat\n  var cols: nat\n  var data: array2<real>\n  \n  constructor(r: nat, c: nat)\n    requires r > 0 && c > 0 \n    ensures rows == r && cols == c\n    ensures fresh(data)\n    ensures data.Length0 == rows && data.Length1 == cols\n  {\n    rows := r;\n    cols := c;\n    data := new real[r,c];\n  }\n}\nclass PRENHead {\n  var inChannels: nat\n  var outChannels: nat  \n  var weights: Matrix  \n  var bias: array<real>  \n  \n  constructor(in_ch: nat, out_ch: nat)\n    requires in_ch > 0 && out_ch > 0\n    ensures inChannels == in_ch && outChannels == out_ch\n    ensures fresh(weights) && fresh(bias)\n    ensures weights.rows == outChannels && weights.cols == inChannels\n    ensures bias.Length == outChannels\n  {\n    inChannels := in_ch;\n    outChannels := out_ch;\n    weights := new Matrix(out_ch, in_ch);\n    bias := new real[out_ch];\n  }\n  \n  method Forward(x: Matrix, isTraining: bool) returns (result: Matrix)\n    requires x.cols == inChannels  \n    requires x.rows > 0 \n    requires outChannels > 0\n    requires x.data.Length0 == x.rows && x.data.Length1 == inChannels\n    requires weights.data.Length0 == outChannels && weights.data.Length1 == inChannels\n    requires bias.Length == outChannels\n    ensures fresh(result)\n    ensures result.rows == x.rows && result.cols == outChannels\n  {\n    \n    result := new Matrix(x.rows, outChannels);\n    \n    \n    var i := 0;\n    while i < x.rows\n      invariant 0 <= i <= x.rows\n      invariant result.rows == x.rows && result.cols == outChannels\n      invariant result.data.Length0 == x.rows && result.data.Length1 == outChannels\n      modifies result.data\n    {\n      var j := 0;\n      while j < outChannels\n        invariant 0 <= j <= outChannels\n        invariant 0 <= i < x.rows\n        invariant result.data.Length0 == x.rows && result.data.Length1 == outChannels\n        modifies result.data\n      {\n        var sum := 0.0;\n        var k := 0;\n        while k < inChannels\n          invariant 0 <= k <= inChannels\n          invariant 0 <= i < x.rows && 0 <= j < outChannels\n          invariant x.data.Length0 == x.rows && x.data.Length1 == inChannels\n          invariant weights.data.Length0 == outChannels && weights.data.Length1 == inChannels\n        {\n          sum := sum + x.data[i,k] * weights.data[j,k];\n          k := k + 1;\n        }\n        result.data[i,j] := sum + bias[j];\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    if !isTraining {\n      ApplySoftmax(result);\n    }\n  }\n  \n  method ApplySoftmax(matrix: Matrix)\n    requires matrix.rows > 0 && matrix.cols > 0\n    requires matrix.data.Length0 == matrix.rows && matrix.data.Length1 == matrix.cols\n    modifies matrix.data\n    ensures matrix.data.Length0 == old(matrix.data.Length0) && matrix.data.Length1 == old(matrix.data.Length1)\n  {\n    var i := 0;\n    while i < matrix.rows\n      invariant 0 <= i <= matrix.rows\n      invariant matrix.data.Length0 == old(matrix.data.Length0) && matrix.data.Length1 == old(matrix.data.Length1)\n      modifies matrix.data\n    {\n      \n      var maxVal := matrix.data[i,0];\n      var j := 1;\n      while j < matrix.cols\n        invariant 1 <= j <= matrix.cols\n        invariant 0 <= i < matrix.rows\n        invariant matrix.data.Length0 == matrix.rows && matrix.data.Length1 == matrix.cols\n      {\n        if matrix.data[i,j] > maxVal {\n          maxVal := matrix.data[i,j];\n        }\n        j := j + 1;\n      }\n      \n      var sum := 0.0;\n      j := 0;\n      while j < matrix.cols\n        invariant 0 <= j <= matrix.cols\n        invariant 0 <= i < matrix.rows\n        invariant matrix.data.Length0 == matrix.rows && matrix.data.Length1 == matrix.cols\n        invariant sum >= 0.0\n        invariant forall k :: 0 <= k < j ==> matrix.data[i,k] > 0.0\n        invariant j > 0 ==> sum > 0.0\n      {\n        matrix.data[i,j] := Exp(matrix.data[i,j] - maxVal);\n        sum := sum + matrix.data[i,j];\n        j := j + 1;\n      }\n      \n      assert matrix.cols > 0;  \n      assert sum > 0.0;        \n      \n      j := 0;\n      while j < matrix.cols\n        invariant 0 <= j <= matrix.cols\n        invariant 0 <= i < matrix.rows\n        invariant matrix.data.Length0 == matrix.rows && matrix.data.Length1 == matrix.cols\n        invariant sum > 0.0\n      {\n        matrix.data[i,j] := matrix.data[i,j] / sum;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  function Exp(x: real): real\n    ensures Exp(x) > 0.0\n  {\n    \n    var result := 1.0 + x + (x * x) / 2.0 + (x * x * x) / 6.0 + (x * x * x * x) / 24.0;\n    if result <= 0.0 then 0.000001 else result\n  }\n}", "name": "py2dfy_228", "id": 228}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype AuthResult = \n  | Success(userId: string, authProviderId: Option<string>, authProviderSessionId: Option<string>)\n  | Failure(error: string)\ndatatype Result<T,E> = Ok(value: T) | Err(error: E)\ndatatype Token = Token(value: string, expiryTime: int, userId: string)\nclass AuthHandler {\n  var tokens: map<string, Token>\n  var mauLimit: int\n  var currentMauCount: int\n  var limitUsageByMau: bool\n  var lastSeenTimes: map<string, int>\n  \n  constructor()\n  {\n    tokens := map[];\n    mauLimit := 50;\n    currentMauCount := 0;\n    limitUsageByMau := false;\n    lastSeenTimes := map[];\n  }\n  method CreateLoginToken(userId: string, durationMs: int, currentTimeMs: int, \n                         authProviderId: Option<string> := None, \n                         authProviderSessionId: Option<string> := None) \n    returns (result: Result<string,string>)\n  {\n    if limitUsageByMau && currentMauCount >= mauLimit && userId !in lastSeenTimes {\n      return Err(\"Monthly active user limit exceeded\");\n    }\n    var tokenValue := GenerateUniqueToken();\n    var expiryTime := currentTimeMs + durationMs;\n    \n    tokens := tokens[tokenValue := Token(tokenValue, expiryTime, userId)];\n    \n    return Ok(tokenValue);\n  }\n  method ConsumeLoginToken(token: string, currentTimeMs: int) \n    returns (result: AuthResult)\n            result.Success? && result.userId == old(tokens)[token].userId\n  {\n    if token !in tokens {\n      return AuthResult.Failure(\"Invalid token\");\n    }\n    var tokenData := tokens[token];\n    \n    if tokenData.expiryTime < currentTimeMs {\n      tokens := map k | k in tokens && k != token :: tokens[k];\n      return AuthResult.Failure(\"Token expired\");\n    }\n    tokens := map k | k in tokens && k != token :: tokens[k];\n    \n    return AuthResult.Success(tokenData.userId, None, None);\n  }\n  method GenerateUniqueToken() returns (token: string)\n  {\n    token := \"\";\n    while true\n    {\n      token := FreshString();\n      if token !in tokens && |token| > 0 {\n        return;\n      }\n    }\n  }\n  function FreshString(): string\n  method SetMauLimit(enabled: bool, limit: int)\n  {\n    limitUsageByMau := enabled;\n    mauLimit := limit;\n  }\n}", "output": "datatype Option<T> = None | Some(value: T)\ndatatype AuthResult = \n  | Success(userId: string, authProviderId: Option<string>, authProviderSessionId: Option<string>)\n  | Failure(error: string)\ndatatype Result<T,E> = Ok(value: T) | Err(error: E)\ndatatype Token = Token(value: string, expiryTime: int, userId: string)\nclass AuthHandler {\n  var tokens: map<string, Token>\n  var mauLimit: int\n  var currentMauCount: int\n  var limitUsageByMau: bool\n  var lastSeenTimes: map<string, int>\n  \n  constructor()\n    ensures tokens == map[]\n    ensures mauLimit > 0\n    ensures currentMauCount == 0\n    ensures limitUsageByMau == false\n    ensures lastSeenTimes == map[]\n  {\n    tokens := map[];\n    mauLimit := 50;\n    currentMauCount := 0;\n    limitUsageByMau := false;\n    lastSeenTimes := map[];\n  }\n  method CreateLoginToken(userId: string, durationMs: int, currentTimeMs: int, \n                         authProviderId: Option<string> := None, \n                         authProviderSessionId: Option<string> := None) \n    returns (result: Result<string,string>)\n    requires durationMs > 0\n    requires currentTimeMs >= 0\n    ensures result.Err? ==> limitUsageByMau && currentMauCount >= mauLimit && userId !in lastSeenTimes\n    ensures result.Ok? ==> userId in set t | t in tokens.Values :: t.userId\n    modifies this`tokens\n    decreases *\n  {\n    if limitUsageByMau && currentMauCount >= mauLimit && userId !in lastSeenTimes {\n      return Err(\"Monthly active user limit exceeded\");\n    }\n    var tokenValue := GenerateUniqueToken();\n    var expiryTime := currentTimeMs + durationMs;\n    \n    tokens := tokens[tokenValue := Token(tokenValue, expiryTime, userId)];\n    assert tokenValue in tokens;\n    assert tokens[tokenValue].userId == userId;\n    assert userId in set t | t in tokens.Values :: t.userId;\n    \n    return Ok(tokenValue);\n  }\n  method ConsumeLoginToken(token: string, currentTimeMs: int) \n    returns (result: AuthResult)\n    requires currentTimeMs >= 0\n    ensures token !in old(tokens) ==> result.Failure?\n    ensures token in old(tokens) && old(tokens)[token].expiryTime < currentTimeMs ==> result.Failure?\n    ensures token in old(tokens) && old(tokens)[token].expiryTime >= currentTimeMs ==> \n            result.Success? && result.userId == old(tokens)[token].userId\n    modifies this`tokens\n  {\n    if token !in tokens {\n      return AuthResult.Failure(\"Invalid token\");\n    }\n    var tokenData := tokens[token];\n    \n    if tokenData.expiryTime < currentTimeMs {\n      tokens := map k | k in tokens && k != token :: tokens[k];\n      return AuthResult.Failure(\"Token expired\");\n    }\n    tokens := map k | k in tokens && k != token :: tokens[k];\n    \n    return AuthResult.Success(tokenData.userId, None, None);\n  }\n  method GenerateUniqueToken() returns (token: string)\n    ensures token !in tokens\n    ensures |token| > 0\n    decreases *\n  {\n    token := \"\";\n    while true\n      invariant |token| >= 0\n      decreases *\n    {\n      token := FreshString();\n      if token !in tokens && |token| > 0 {\n        return;\n      }\n    }\n  }\n  function FreshString(): string\n  method SetMauLimit(enabled: bool, limit: int)\n    requires limit > 0\n    ensures limitUsageByMau == enabled\n    ensures mauLimit == limit\n    modifies this`limitUsageByMau, this`mauLimit\n  {\n    limitUsageByMau := enabled;\n    mauLimit := limit;\n  }\n}", "name": "py2dfy_259", "id": 259}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main()\n{\n    var data := [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]];\n    var scaled_data := StandardScaler(data);\n    var features := Transpose(scaled_data);\n    var cov_matrix := CovarianceMatrix(features);\n    var eigenvalues, eigenvectors := EigenDecomposition(cov_matrix);\n    \n    print \"Eigenvalues: \", eigenvalues, \"\\n\";\n}\nmethod StandardScaler(data: seq<seq<real>>) returns (scaled: seq<seq<real>>)\n{\n    scaled := data; \n}\nmethod Transpose(matrix: seq<seq<real>>) returns (transposed: seq<seq<real>>)\n            transposed[i][j] == matrix[j][i]\n{\n    var rows := |matrix|;\n    var cols := |matrix[0]|;\n    \n    \n    transposed := [];\n    var i := 0;\n    while i < cols\n                transposed[k][j] == matrix[j][k]\n    {\n        var newRow := [];\n        var j := 0;\n        while j < rows\n        {\n            newRow := newRow + [matrix[j][i]];\n            j := j + 1;\n        }\n        transposed := transposed + [newRow];\n        i := i + 1;\n    }\n}\nmethod CovarianceMatrix(features: seq<seq<real>>) returns (cov: seq<seq<real>>)\n{\n    var n := |features|;\n    var m := |features[0]|;\n    \n    \n    cov := [];\n    var i := 0;\n    while i < n\n    {\n        var row := [];\n        var j := 0;\n        while j < n\n        {\n            row := row + [0.0];\n            j := j + 1;\n        }\n        cov := cov + [row];\n        i := i + 1;\n    }\n    \n    \n    var means := [];\n    i := 0;\n    while i < n\n    {\n        var sum := 0.0;\n        var j := 0;\n        while j < m\n        {\n            sum := sum + features[i][j];\n            j := j + 1;\n        }\n        means := means + [sum / (m as real)];\n        i := i + 1;\n    }\n    \n    \n    i := 0;\n    while i < n\n    {\n        var j := 0;\n        while j < n\n        {\n            var sum := 0.0;\n            var k := 0;\n            while k < m\n            {\n                sum := sum + (features[i][k] - means[i]) * (features[j][k] - means[j]);\n                k := k + 1;\n            }\n            \n            var oldRow := cov[i];\n            var newRow := oldRow[j := sum / ((m - 1) as real)];\n            cov := cov[i := newRow];\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\nmethod EigenDecomposition(matrix: seq<seq<real>>) returns (eigenvalues: seq<real>, eigenvectors: seq<seq<real>>)\n{\n    var n := |matrix|;\n    \n    \n    eigenvalues := [];\n    var i := 0;\n    while i < n\n    {\n        eigenvalues := eigenvalues + [0.0];\n        i := i + 1;\n    }\n    \n    \n    eigenvectors := [];\n    i := 0;\n    while i < n\n    {\n        var row := [];\n        var j := 0;\n        while j < n\n        {\n            row := row + [0.0];\n            j := j + 1;\n        }\n        eigenvectors := eigenvectors + [row];\n        i := i + 1;\n    }\n}", "output": "method Main()\n{\n    var data := [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]];\n    var scaled_data := StandardScaler(data);\n    var features := Transpose(scaled_data);\n    var cov_matrix := CovarianceMatrix(features);\n    var eigenvalues, eigenvectors := EigenDecomposition(cov_matrix);\n    \n    print \"Eigenvalues: \", eigenvalues, \"\\n\";\n}\nmethod StandardScaler(data: seq<seq<real>>) returns (scaled: seq<seq<real>>)\n    requires |data| > 0 && |data[0]| > 0\n    requires forall i :: 0 <= i < |data| ==> |data[i]| == |data[0]|\n    ensures |scaled| == |data| && |scaled[0]| == |data[0]|\n    ensures forall i :: 0 <= i < |scaled| ==> |scaled[i]| == |scaled[0]|\n{\n    scaled := data; \n}\nmethod Transpose(matrix: seq<seq<real>>) returns (transposed: seq<seq<real>>)\n    requires |matrix| > 0 && |matrix[0]| > 0\n    requires forall i :: 0 <= i < |matrix| ==> |matrix[i]| == |matrix[0]|\n    ensures |transposed| == |matrix[0]| && |transposed[0]| == |matrix|\n    ensures forall i :: 0 <= i < |transposed| ==> |transposed[i]| == |matrix|\n    ensures forall i, j :: 0 <= i < |transposed| && 0 <= j < |transposed[0]| ==> \n            transposed[i][j] == matrix[j][i]\n{\n    var rows := |matrix|;\n    var cols := |matrix[0]|;\n    \n    \n    transposed := [];\n    var i := 0;\n    while i < cols\n        invariant 0 <= i <= cols\n        invariant |transposed| == i\n        invariant forall k :: 0 <= k < i ==> |transposed[k]| == rows\n        invariant forall k, j :: 0 <= k < i && 0 <= j < rows ==> \n                transposed[k][j] == matrix[j][k]\n    {\n        var newRow := [];\n        var j := 0;\n        while j < rows\n            invariant 0 <= j <= rows\n            invariant |newRow| == j\n            invariant forall k :: 0 <= k < j ==> newRow[k] == matrix[k][i]\n        {\n            newRow := newRow + [matrix[j][i]];\n            j := j + 1;\n        }\n        transposed := transposed + [newRow];\n        i := i + 1;\n    }\n}\nmethod CovarianceMatrix(features: seq<seq<real>>) returns (cov: seq<seq<real>>)\n    requires |features| > 0 && |features[0]| > 0\n    requires forall i :: 0 <= i < |features| ==> |features[i]| == |features[0]|\n    requires |features[0]| > 1 \n    ensures |cov| == |features| && |cov[0]| == |features|\n    ensures forall i :: 0 <= i < |cov| ==> |cov[i]| == |features|\n{\n    var n := |features|;\n    var m := |features[0]|;\n    \n    \n    cov := [];\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |cov| == i\n        invariant forall k :: 0 <= k < i ==> |cov[k]| == n\n    {\n        var row := [];\n        var j := 0;\n        while j < n\n            invariant 0 <= j <= n\n            invariant |row| == j\n        {\n            row := row + [0.0];\n            j := j + 1;\n        }\n        cov := cov + [row];\n        i := i + 1;\n    }\n    \n    \n    var means := [];\n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |means| == i\n    {\n        var sum := 0.0;\n        var j := 0;\n        while j < m\n            invariant 0 <= j <= m\n        {\n            sum := sum + features[i][j];\n            j := j + 1;\n        }\n        means := means + [sum / (m as real)];\n        i := i + 1;\n    }\n    \n    \n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |cov| == n\n        invariant forall k :: 0 <= k < n ==> |cov[k]| == n\n    {\n        var j := 0;\n        while j < n\n            invariant 0 <= j <= n\n            invariant |cov| == n\n            invariant forall k :: 0 <= k < n ==> |cov[k]| == n\n        {\n            var sum := 0.0;\n            var k := 0;\n            while k < m\n                invariant 0 <= k <= m\n            {\n                sum := sum + (features[i][k] - means[i]) * (features[j][k] - means[j]);\n                k := k + 1;\n            }\n            \n            var oldRow := cov[i];\n            var newRow := oldRow[j := sum / ((m - 1) as real)];\n            cov := cov[i := newRow];\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\nmethod EigenDecomposition(matrix: seq<seq<real>>) returns (eigenvalues: seq<real>, eigenvectors: seq<seq<real>>)\n    requires |matrix| > 0 && |matrix[0]| == |matrix|\n    requires forall i :: 0 <= i < |matrix| ==> |matrix[i]| == |matrix[0]|\n    ensures |eigenvalues| == |matrix|\n    ensures |eigenvectors| == |matrix| && forall i :: 0 <= i < |eigenvectors| ==> |eigenvectors[i]| == |matrix|\n{\n    var n := |matrix|;\n    \n    \n    eigenvalues := [];\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |eigenvalues| == i\n    {\n        eigenvalues := eigenvalues + [0.0];\n        i := i + 1;\n    }\n    \n    \n    eigenvectors := [];\n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |eigenvectors| == i\n        invariant forall k :: 0 <= k < i ==> |eigenvectors[k]| == n\n    {\n        var row := [];\n        var j := 0;\n        while j < n\n            invariant 0 <= j <= n\n            invariant |row| == j\n        {\n            row := row + [0.0];\n            j := j + 1;\n        }\n        eigenvectors := eigenvectors + [row];\n        i := i + 1;\n    }\n}", "name": "py2dfy_281", "id": 281}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type Option<T> = s: seq<T> | |s| <= 1 witness []\ndatatype ColumnConfig = ColumnConfig(\n  name: string,\n  mapsTo: string,\n  metaslot: Option<Metaslot>,\n  settings: Settings\n)\ndatatype Metaslot = Metaslot(name: string)\ndatatype Settings = Settings(curiePrefix: Option<string>)\ndatatype TableConfig = TableConfig(\n  columns: map<string, ColumnConfig>,\n  metatypeColumn: Option<string>\n)\ndatatype SchemaSheet = SchemaSheet(tableConfig: TableConfig)\nmethod ParseHeader(input: seq<map<string, string>>) returns (ss: SchemaSheet)\n    ss.tableConfig.columns[\"Info\"].name == \"Info\" &&\n    ss.tableConfig.columns[\"Info\"].mapsTo == \"description\" &&\n    |ss.tableConfig.columns[\"Info\"].metaslot| == 1\n    ss.tableConfig.columns[\"Record\"].name == \"Record\" &&\n    ss.tableConfig.columns[\"Record\"].mapsTo == \"class\" &&\n    |ss.tableConfig.columns[\"Record\"].metaslot| == 0\n{\n  var columns: map<string, ColumnConfig> := map[];\n  var metatypeColumn: Option<string> := [];\n  \n  columns := columns[\"Info\" := ColumnConfig(\"Info\", \"description\", [Metaslot(\"description\")], Settings([]))];\n  var i := 0;\n  while i < |input|\n      columns[\"Record\"].name == \"Record\" &&\n      columns[\"Record\"].mapsTo == \"class\" &&\n      |columns[\"Record\"].metaslot| == 0\n  {\n    var row := input[i];\n    \n    if \"Record\" in row {\n      columns := columns[\"Record\" := ColumnConfig(\"Record\", \"class\", [], Settings([]))];\n    }\n    if \"MetaType\" in row {\n      metatypeColumn := [\"MetaType\"];\n      columns := columns[\"MetaType\" := ColumnConfig(\"MetaType\", \"metatype\", [], Settings([]))];\n    }\n    i := i + 1;\n  }\n  ss := SchemaSheet(TableConfig(columns, metatypeColumn));\n}\nmethod TestParseHeader()\n{\n  var case1 := [\n    map[\"Record\" := \"> class\", \"Info\" := \" description\", \"schema.org\" := \"exact_mappings: {curie_prefix: sdo}\", \"wikidata\" := \"exact_mappings\"],\n    map[\"Record\" := \">\", \"wikidata\" := \"curie_prefix: wd\"]\n  ];\n  var ss := ParseHeader(case1);\n}", "output": "type Option<T> = s: seq<T> | |s| <= 1 witness []\ndatatype ColumnConfig = ColumnConfig(\n  name: string,\n  mapsTo: string,\n  metaslot: Option<Metaslot>,\n  settings: Settings\n)\ndatatype Metaslot = Metaslot(name: string)\ndatatype Settings = Settings(curiePrefix: Option<string>)\ndatatype TableConfig = TableConfig(\n  columns: map<string, ColumnConfig>,\n  metatypeColumn: Option<string>\n)\ndatatype SchemaSheet = SchemaSheet(tableConfig: TableConfig)\nmethod ParseHeader(input: seq<map<string, string>>) returns (ss: SchemaSheet)\n  requires |input| > 0\n  ensures \"Info\" in ss.tableConfig.columns\n  ensures \"Info\" in ss.tableConfig.columns ==>\n    ss.tableConfig.columns[\"Info\"].name == \"Info\" &&\n    ss.tableConfig.columns[\"Info\"].mapsTo == \"description\" &&\n    |ss.tableConfig.columns[\"Info\"].metaslot| == 1\n  ensures \"Record\" in ss.tableConfig.columns ==>\n    ss.tableConfig.columns[\"Record\"].name == \"Record\" &&\n    ss.tableConfig.columns[\"Record\"].mapsTo == \"class\" &&\n    |ss.tableConfig.columns[\"Record\"].metaslot| == 0\n  ensures \"Record\" in input[0] ==> \"Record\" in ss.tableConfig.columns\n{\n  var columns: map<string, ColumnConfig> := map[];\n  var metatypeColumn: Option<string> := [];\n  \n  columns := columns[\"Info\" := ColumnConfig(\"Info\", \"description\", [Metaslot(\"description\")], Settings([]))];\n  var i := 0;\n  while i < |input|\n    invariant 0 <= i <= |input|\n    invariant \"Info\" in columns\n    invariant columns[\"Info\"].name == \"Info\"\n    invariant columns[\"Info\"].mapsTo == \"description\"\n    invariant |columns[\"Info\"].metaslot| == 1\n    invariant \"Record\" in columns ==>\n      columns[\"Record\"].name == \"Record\" &&\n      columns[\"Record\"].mapsTo == \"class\" &&\n      |columns[\"Record\"].metaslot| == 0\n    invariant \"Record\" in input[0] && i > 0 ==> \"Record\" in columns\n  {\n    var row := input[i];\n    \n    if \"Record\" in row {\n      columns := columns[\"Record\" := ColumnConfig(\"Record\", \"class\", [], Settings([]))];\n    }\n    if \"MetaType\" in row {\n      metatypeColumn := [\"MetaType\"];\n      columns := columns[\"MetaType\" := ColumnConfig(\"MetaType\", \"metatype\", [], Settings([]))];\n    }\n    i := i + 1;\n  }\n  ss := SchemaSheet(TableConfig(columns, metatypeColumn));\n}\nmethod TestParseHeader()\n{\n  var case1 := [\n    map[\"Record\" := \"> class\", \"Info\" := \" description\", \"schema.org\" := \"exact_mappings: {curie_prefix: sdo}\", \"wikidata\" := \"exact_mappings\"],\n    map[\"Record\" := \">\", \"wikidata\" := \"curie_prefix: wd\"]\n  ];\n  var ss := ParseHeader(case1);\n  assert \"Info\" in ss.tableConfig.columns;\n  assert ss.tableConfig.columns[\"Info\"].name == \"Info\";\n  assert ss.tableConfig.columns[\"Info\"].mapsTo == \"description\";\n  assert |ss.tableConfig.columns[\"Info\"].metaslot| == 1;\n  assert \"Record\" in case1[0];  \n  assert \"Record\" in ss.tableConfig.columns;\n  assert ss.tableConfig.columns[\"Record\"].name == \"Record\";\n  assert ss.tableConfig.columns[\"Record\"].mapsTo == \"class\";\n  assert |ss.tableConfig.columns[\"Record\"].metaslot| == 0;\n}", "name": "py2dfy_250", "id": 250}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module SystemInfo {\n    \n    class {:autocontracts} CommandLineArgs {\n        var args: seq<string>\n        \n        constructor(input: seq<string>)\n        {\n            args := input;\n        }\n        \n        method GetLength() returns (length: nat)\n        {\n            length := |args|;\n        }\n        \n        method GetArgs() returns (result: seq<string>)\n        {\n            result := args;\n        }\n    }\n    \n    class {:autocontracts} SystemEnvironment {\n        const osName: string\n        const pythonVersion: string  \n        const processId: nat\n        const workingDirectory: string\n        const loginName: string\n        ghost predicate Valid()\n        {\n            osName != \"\" && pythonVersion != \"\" && \n            workingDirectory != \"\" && loginName != \"\"\n        }\n        \n        constructor(os: string, version: string, pid: nat, dir: string, user: string)\n        {\n            osName := os;\n            pythonVersion := version;\n            processId := pid;\n            workingDirectory := dir;\n            loginName := user;\n        }\n        \n        method GetOSPlatform() returns (platform: string)\n        {\n            platform := osName;\n        }\n        \n        method GetPythonVersion() returns (version: string)\n        {\n            version := pythonVersion;\n        }\n        \n        method GetProcessId() returns (pid: nat)\n        {\n            pid := processId;\n        }\n        \n        method GetWorkingDirectory() returns (dir: string)\n        {\n            dir := workingDirectory;\n        }\n        \n        method GetLoginName() returns (name: string)\n        {\n            name := loginName;\n        }\n    }\n    \n    method PrintSystemInfo(env: SystemEnvironment?)\n    {\n        var platform := env.GetOSPlatform();\n        var version := env.GetPythonVersion();\n        var pid := env.GetProcessId();\n        var dir := env.GetWorkingDirectory();\n        var login := env.GetLoginName();\n        print \"Operating System: \", platform, \"\\n\";\n        print \"Python Version: \", version, \"\\n\";\n        print \"Process ID: \", pid, \"\\n\";\n        print \"Working Directory: \", dir, \"\\n\";\n        print \"Login Name: \", login, \"\\n\";\n    }\n    \n    method Main()\n    {\n        \n        var cmdArgs := new CommandLineArgs([\"program.dfy\", \"arg1\", \"arg2\"]);\n        var length := cmdArgs.GetLength();\n        var args := cmdArgs.GetArgs();\n        \n        print \"Length of Command Line Arguments: \", length, \"\\n\";\n        print \"Command Line Arguments: \", args, \"\\n\";\n        var sysEnv := new SystemEnvironment(\n            \"Windows\",           \n            \"Dafny 3.0.0\",      \n            12345,              \n            \"/home/user\",       \n            \"username\"          \n        );\n        PrintSystemInfo(sysEnv);\n    }\n}", "output": "module SystemInfo {\n    \n    class {:autocontracts} CommandLineArgs {\n        var args: seq<string>\n        \n        constructor(input: seq<string>)\n            requires |input| > 0  \n            ensures args == input\n        {\n            args := input;\n        }\n        \n        method GetLength() returns (length: nat)\n            ensures length == |args|\n        {\n            length := |args|;\n        }\n        \n        method GetArgs() returns (result: seq<string>)\n            ensures result == args\n        {\n            result := args;\n        }\n    }\n    \n    class {:autocontracts} SystemEnvironment {\n        const osName: string\n        const pythonVersion: string  \n        const processId: nat\n        const workingDirectory: string\n        const loginName: string\n        ghost predicate Valid()\n        {\n            osName != \"\" && pythonVersion != \"\" && \n            workingDirectory != \"\" && loginName != \"\"\n        }\n        \n        constructor(os: string, version: string, pid: nat, dir: string, user: string)\n            requires os != \"\" && version != \"\" && dir != \"\" && user != \"\"\n            ensures osName == os\n            ensures pythonVersion == version\n            ensures processId == pid\n            ensures workingDirectory == dir\n            ensures loginName == user\n            ensures Valid()\n        {\n            osName := os;\n            pythonVersion := version;\n            processId := pid;\n            workingDirectory := dir;\n            loginName := user;\n        }\n        \n        method GetOSPlatform() returns (platform: string)\n            ensures platform == osName\n        {\n            platform := osName;\n        }\n        \n        method GetPythonVersion() returns (version: string)\n            ensures version == pythonVersion\n        {\n            version := pythonVersion;\n        }\n        \n        method GetProcessId() returns (pid: nat)\n            ensures pid == processId\n        {\n            pid := processId;\n        }\n        \n        method GetWorkingDirectory() returns (dir: string)\n            ensures dir == workingDirectory\n        {\n            dir := workingDirectory;\n        }\n        \n        method GetLoginName() returns (name: string)\n            ensures name == loginName\n        {\n            name := loginName;\n        }\n    }\n    \n    method PrintSystemInfo(env: SystemEnvironment?)\n        requires env != null && env.Valid()\n    {\n        var platform := env.GetOSPlatform();\n        var version := env.GetPythonVersion();\n        var pid := env.GetProcessId();\n        var dir := env.GetWorkingDirectory();\n        var login := env.GetLoginName();\n        print \"Operating System: \", platform, \"\\n\";\n        print \"Python Version: \", version, \"\\n\";\n        print \"Process ID: \", pid, \"\\n\";\n        print \"Working Directory: \", dir, \"\\n\";\n        print \"Login Name: \", login, \"\\n\";\n    }\n    \n    method Main()\n    {\n        \n        var cmdArgs := new CommandLineArgs([\"program.dfy\", \"arg1\", \"arg2\"]);\n        var length := cmdArgs.GetLength();\n        var args := cmdArgs.GetArgs();\n        \n        print \"Length of Command Line Arguments: \", length, \"\\n\";\n        print \"Command Line Arguments: \", args, \"\\n\";\n        var sysEnv := new SystemEnvironment(\n            \"Windows\",           \n            \"Dafny 3.0.0\",      \n            12345,              \n            \"/home/user\",       \n            \"username\"          \n        );\n        PrintSystemInfo(sysEnv);\n    }\n}", "name": "py2dfy_278", "id": 278}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module GeoData {\n  class GeoDataFrame {\n    var data: array<real>\n    var size: nat\n    \n    constructor(size: nat)\n    {\n      this.size := size;\n      this.data := new real[size];\n    }\n    \n    method ReadFromFile(filename: string) returns (success: bool)\n    {\n      var i := 0;\n      while i < size\n      {\n        data[i] := i as real + 1.0;\n        i := i + 1;\n      }\n      return true;\n    }\n    \n    method ComputeMean() returns (mean: real)\n    {\n      var sum := 0.0;\n      var i := 0;\n      \n      while i < size\n      {\n        sum := sum + data[i];\n        i := i + 1;\n      }\n      \n      return sum / size as real;\n    }\n    \n    function Sum(arr: array<real>, upTo: nat): real\n    {\n      if upTo == 0 then 0.0 else Sum(arr, upTo-1) + arr[upTo-1]\n    }\n  }\n  \n  method GenerateRandomArray(size: nat) returns (arr: array<real>)\n  {\n    arr := new real[size];\n    var i := 0;\n    \n    while i < size\n    {\n      arr[i] := i as real / size as real;\n      i := i + 1;\n    }\n  }\n}\nmethod Main()\n{\n  var gdf := new GeoData.GeoDataFrame(10);\n  var success := gdf.ReadFromFile(\"sample.csv\");\n  \n  if success {\n    var mean := gdf.ComputeMean();\n    print \"Mean value: \", mean, \"\\n\";\n  }\n  \n  var randomData := GeoData.GenerateRandomArray(5);\n  print \"Random array generated\\n\";\n}", "output": "module GeoData {\n  class GeoDataFrame {\n    var data: array<real>\n    var size: nat\n    \n    constructor(size: nat)\n      ensures this.size == size\n      ensures fresh(data)\n      ensures data.Length == size\n    {\n      this.size := size;\n      this.data := new real[size];\n    }\n    \n    method ReadFromFile(filename: string) returns (success: bool)\n      modifies this.data\n      requires filename != \"\"\n      requires data.Length == size\n      ensures success ==> forall i :: 0 <= i < data.Length ==> data[i] != 0.0\n    {\n      var i := 0;\n      while i < size\n        invariant 0 <= i <= size\n        invariant forall j :: 0 <= j < i ==> data[j] != 0.0\n        invariant data.Length == size\n        modifies this.data\n      {\n        data[i] := i as real + 1.0;\n        i := i + 1;\n      }\n      return true;\n    }\n    \n    method ComputeMean() returns (mean: real)\n      requires size > 0\n      requires data.Length == size\n      ensures mean == Sum(data, size) / size as real\n    {\n      var sum := 0.0;\n      var i := 0;\n      \n      while i < size\n        invariant 0 <= i <= size\n        invariant sum == Sum(data, i)\n        invariant data.Length == size\n      {\n        sum := sum + data[i];\n        i := i + 1;\n      }\n      \n      return sum / size as real;\n    }\n    \n    function Sum(arr: array<real>, upTo: nat): real\n      reads arr\n      requires upTo <= arr.Length\n    {\n      if upTo == 0 then 0.0 else Sum(arr, upTo-1) + arr[upTo-1]\n    }\n  }\n  \n  method GenerateRandomArray(size: nat) returns (arr: array<real>)\n    ensures arr.Length == size\n    ensures fresh(arr)\n  {\n    arr := new real[size];\n    var i := 0;\n    \n    while i < size\n      invariant 0 <= i <= size\n      invariant arr.Length == size\n      modifies arr\n    {\n      arr[i] := i as real / size as real;\n      i := i + 1;\n    }\n  }\n}\nmethod Main()\n{\n  var gdf := new GeoData.GeoDataFrame(10);\n  var success := gdf.ReadFromFile(\"sample.csv\");\n  \n  if success {\n    var mean := gdf.ComputeMean();\n    print \"Mean value: \", mean, \"\\n\";\n  }\n  \n  var randomData := GeoData.GenerateRandomArray(5);\n  print \"Random array generated\\n\";\n}", "name": "py2dfy_249", "id": 249}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module BlurDetection {\n  \n  type GrayscaleImage = array2<int>\n  \n  \n  type RGBImage = array3<int>\n  \n  \n  method ConvertToGrayscale(image: RGBImage) returns (gray: GrayscaleImage)\n      (0 <= i < image.Length0 && 0 <= j < image.Length1 && \n       0 <= k < image.Length2) ==> 0 <= image[i,j,k] <= 255\n      (0 <= i < gray.Length0 && 0 <= j < gray.Length1) ==> \n      0 <= gray[i,j] <= 255\n  {\n    gray := new int[image.Length0, image.Length1];\n    \n    var i := 0;\n    while i < image.Length0\n        (0 <= m < i && 0 <= n < image.Length1) ==> \n        0 <= gray[m,n] <= 255\n    {\n      var j := 0;\n      while j < image.Length1\n          ((0 <= m < i && 0 <= n < image.Length1) || \n           (m == i && 0 <= n < j)) ==> \n          0 <= gray[m,n] <= 255\n      {\n        var r := image[i,j,0];\n        var g := image[i,j,1];\n        var b := image[i,j,2];\n        \n        \n        gray[i,j] := (299*r + 587*g + 114*b) / 1000;\n        \n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  \n  method CalculateLaplacian(gray: GrayscaleImage, i: int, j: int) returns (laplacian: int)\n      (0 <= m < gray.Length0 && 0 <= n < gray.Length1) ==> \n      0 <= gray[m,n] <= 255\n  {\n    \n    \n    \n    \n    laplacian := 4 * gray[i,j] - \n                 gray[i-1,j] - gray[i+1,j] - \n                 gray[i,j-1] - gray[i,j+1];\n  }\n  \n  \n  method CalculateFocusMeasure(gray: GrayscaleImage) returns (focusMeasure: real)\n      (0 <= i < gray.Length0 && 0 <= j < gray.Length1) ==> \n      0 <= gray[i,j] <= 255\n  {\n    \n    var laplacianSum := 0;\n    var validPixels := 0;\n    \n    var i := 1;\n    while i < gray.Length0 - 1\n    {\n      var j := 1;\n      while j < gray.Length1 - 1\n      {\n        var lap := CalculateLaplacian(gray, i, j);\n        laplacianSum := laplacianSum + lap;\n        validPixels := validPixels + 1;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    var mean: real := 0.0;\n    if validPixels > 0 {\n      mean := laplacianSum as real / validPixels as real;\n    }\n    \n    \n    var sumSquaredDifferences: real := 0.0;\n    \n    i := 1;\n    while i < gray.Length0 - 1\n    {\n      var j := 1;\n      while j < gray.Length1 - 1\n      {\n        var lap := CalculateLaplacian(gray, i, j);\n        var diff: real := lap as real - mean;\n        sumSquaredDifferences := sumSquaredDifferences + diff * diff;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    if validPixels > 0 {\n      focusMeasure := sumSquaredDifferences / validPixels as real;\n    } else {\n      focusMeasure := 0.0;\n    }\n  }\n  \n  \n  method DetectBlur(image: RGBImage, blurThreshold: real) returns (isBlurry: bool, focusMeasure: real)\n      (0 <= i < image.Length0 && 0 <= j < image.Length1 && \n       0 <= k < image.Length2) ==> 0 <= image[i,j,k] <= 255\n  {\n    var gray := ConvertToGrayscale(image);\n    focusMeasure := CalculateFocusMeasure(gray);\n    isBlurry := focusMeasure < blurThreshold;\n  }\n  \n  \n  method Main()\n  {\n    \n    \n    var sampleImage := new int[5, 5, 3];\n    \n    \n    var i := 0;\n    while i < 5\n        (0 <= m < i && 0 <= n < 5 && 0 <= k < 3) ==>\n        0 <= sampleImage[m,n,k] <= 255\n    {\n      var j := 0;\n      while j < 5\n          ((0 <= m < i && 0 <= n < 5 && 0 <= k < 3) ||\n           (m == i && 0 <= n < j && 0 <= k < 3)) ==>\n          0 <= sampleImage[m,n,k] <= 255\n      {\n        \n        sampleImage[i,j,0] := 100;  \n        sampleImage[i,j,1] := 150;  \n        sampleImage[i,j,2] := 200;  \n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    \n    var blurThreshold := 100.0;\n    \n    \n    var isBlurry, focusMeasure := DetectBlur(sampleImage, blurThreshold);\n    \n    \n    \n    print \"Focus Measure: \", focusMeasure, \"\\n\";\n    if isBlurry {\n      print \"Image is blurry\\n\";\n    } else {\n      print \"Image is clear\\n\";\n    }\n  }\n}", "output": "module BlurDetection {\n  \n  type GrayscaleImage = array2<int>\n  \n  \n  type RGBImage = array3<int>\n  \n  \n  method ConvertToGrayscale(image: RGBImage) returns (gray: GrayscaleImage)\n    requires image.Length0 > 0 && image.Length1 > 0 && image.Length2 == 3\n    requires forall i, j, k :: \n      (0 <= i < image.Length0 && 0 <= j < image.Length1 && \n       0 <= k < image.Length2) ==> 0 <= image[i,j,k] <= 255\n    ensures gray.Length0 == image.Length0 && gray.Length1 == image.Length1\n    ensures forall i, j :: \n      (0 <= i < gray.Length0 && 0 <= j < gray.Length1) ==> \n      0 <= gray[i,j] <= 255\n  {\n    gray := new int[image.Length0, image.Length1];\n    \n    var i := 0;\n    while i < image.Length0\n      invariant 0 <= i <= image.Length0\n      invariant forall m, n :: \n        (0 <= m < i && 0 <= n < image.Length1) ==> \n        0 <= gray[m,n] <= 255\n    {\n      var j := 0;\n      while j < image.Length1\n        invariant 0 <= j <= image.Length1\n        invariant forall m, n :: \n          ((0 <= m < i && 0 <= n < image.Length1) || \n           (m == i && 0 <= n < j)) ==> \n          0 <= gray[m,n] <= 255\n      {\n        var r := image[i,j,0];\n        var g := image[i,j,1];\n        var b := image[i,j,2];\n        \n        \n        gray[i,j] := (299*r + 587*g + 114*b) / 1000;\n        \n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  \n  method CalculateLaplacian(gray: GrayscaleImage, i: int, j: int) returns (laplacian: int)\n    requires gray.Length0 > 2 && gray.Length1 > 2  \n    requires 1 <= i < gray.Length0 - 1 && 1 <= j < gray.Length1 - 1  \n    requires forall m, n :: \n      (0 <= m < gray.Length0 && 0 <= n < gray.Length1) ==> \n      0 <= gray[m,n] <= 255\n    ensures -1020 <= laplacian <= 1020  \n  {\n    \n    \n    \n    \n    laplacian := 4 * gray[i,j] - \n                 gray[i-1,j] - gray[i+1,j] - \n                 gray[i,j-1] - gray[i,j+1];\n  }\n  \n  \n  method CalculateFocusMeasure(gray: GrayscaleImage) returns (focusMeasure: real)\n    requires gray.Length0 > 2 && gray.Length1 > 2\n    requires forall i, j :: \n      (0 <= i < gray.Length0 && 0 <= j < gray.Length1) ==> \n      0 <= gray[i,j] <= 255\n    ensures focusMeasure >= 0.0  \n  {\n    \n    var laplacianSum := 0;\n    var validPixels := 0;\n    \n    var i := 1;\n    while i < gray.Length0 - 1\n      invariant 1 <= i <= gray.Length0 - 1\n      invariant validPixels == (i - 1) * (gray.Length1 - 2)  \n    {\n      var j := 1;\n      while j < gray.Length1 - 1\n        invariant 1 <= j <= gray.Length1 - 1\n        invariant validPixels == (i - 1) * (gray.Length1 - 2) + (j - 1)\n      {\n        var lap := CalculateLaplacian(gray, i, j);\n        laplacianSum := laplacianSum + lap;\n        validPixels := validPixels + 1;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    var mean: real := 0.0;\n    if validPixels > 0 {\n      mean := laplacianSum as real / validPixels as real;\n    }\n    \n    \n    var sumSquaredDifferences: real := 0.0;\n    \n    i := 1;\n    while i < gray.Length0 - 1\n      invariant 1 <= i <= gray.Length0 - 1\n      invariant sumSquaredDifferences >= 0.0\n    {\n      var j := 1;\n      while j < gray.Length1 - 1\n        invariant 1 <= j <= gray.Length1 - 1\n        invariant sumSquaredDifferences >= 0.0\n      {\n        var lap := CalculateLaplacian(gray, i, j);\n        var diff: real := lap as real - mean;\n        sumSquaredDifferences := sumSquaredDifferences + diff * diff;\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    if validPixels > 0 {\n      focusMeasure := sumSquaredDifferences / validPixels as real;\n    } else {\n      focusMeasure := 0.0;\n    }\n  }\n  \n  \n  method DetectBlur(image: RGBImage, blurThreshold: real) returns (isBlurry: bool, focusMeasure: real)\n    requires image.Length0 > 2 && image.Length1 > 2 && image.Length2 == 3\n    requires blurThreshold > 0.0\n    requires forall i, j, k :: \n      (0 <= i < image.Length0 && 0 <= j < image.Length1 && \n       0 <= k < image.Length2) ==> 0 <= image[i,j,k] <= 255\n    ensures focusMeasure >= 0.0\n    ensures isBlurry <==> focusMeasure < blurThreshold\n  {\n    var gray := ConvertToGrayscale(image);\n    focusMeasure := CalculateFocusMeasure(gray);\n    isBlurry := focusMeasure < blurThreshold;\n  }\n  \n  \n  method Main()\n  {\n    \n    \n    var sampleImage := new int[5, 5, 3];\n    \n    \n    var i := 0;\n    while i < 5\n      invariant 0 <= i <= 5\n      invariant forall m, n, k ::\n        (0 <= m < i && 0 <= n < 5 && 0 <= k < 3) ==>\n        0 <= sampleImage[m,n,k] <= 255\n    {\n      var j := 0;\n      while j < 5\n        invariant 0 <= j <= 5\n        invariant forall m, n, k ::\n          ((0 <= m < i && 0 <= n < 5 && 0 <= k < 3) ||\n           (m == i && 0 <= n < j && 0 <= k < 3)) ==>\n          0 <= sampleImage[m,n,k] <= 255\n      {\n        \n        sampleImage[i,j,0] := 100;  \n        sampleImage[i,j,1] := 150;  \n        sampleImage[i,j,2] := 200;  \n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    \n    \n    var blurThreshold := 100.0;\n    \n    \n    var isBlurry, focusMeasure := DetectBlur(sampleImage, blurThreshold);\n    \n    \n    \n    print \"Focus Measure: \", focusMeasure, \"\\n\";\n    if isBlurry {\n      print \"Image is blurry\\n\";\n    } else {\n      print \"Image is clear\\n\";\n    }\n  }\n}", "name": "py2dfy_254", "id": 254}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class GAN {\n  var resolution: int\n  var channels: int  \n  var discriminator: array<real>\n  var generator: array<real>\n  constructor(res: int, ch: int)\n  {\n    resolution := res;\n    channels := ch;\n    discriminator := new real[100];\n    generator := new real[100];\n  }\n  method Discriminator(input: array<real>) returns (output: real)\n  {\n    var sum: real := 0.0;\n    for i := 0 to input.Length\n    {\n      sum := sum + input[i];\n    }\n    output := Sigmoid(sum / (input.Length as real));\n  }\n  method Generator(seed: array<real>) returns (output: array<real>)\n  {\n    var size := resolution * resolution * channels;\n    output := new real[size];\n    var factor := SumArray(seed, seed.Length) / (seed.Length as real);\n    for i := 0 to output.Length\n    {\n      output[i] := Tanh(factor * (i as real) / (output.Length as real));\n    }\n  }\n  method DiscriminatorLoss(realOutput: real, fakeOutput: real) returns (loss: real)\n  {\n    loss := -Log(realOutput) - Log(1.0 - fakeOutput);\n  }\n  method GeneratorLoss(fakeOutput: real) returns (loss: real)\n  {\n    loss := -Log(fakeOutput);\n  }\n  function Sigmoid(x: real): real\n  {\n    1.0 / (1.0 + Exp(x))\n  }\n  function Tanh(x: real): real\n  {\n    var ex := Exp(x);\n    var enx := Exp(-x);\n      calc {\n        (ex - enx) / (ex + enx);\n        < ex / (ex + enx);\n        <= 1.0;\n      }\n      calc {\n        (ex - enx) / (ex + enx);\n        > -enx / (ex + enx);\n        >= -1.0;\n      }\n    }\n    (ex - enx) / (ex + enx)\n  }\n  function Exp(x: real): real\n  {\n    if x < 0.0 then \n      1.0 / (1.0 + (-x))\n    else \n      1.0 + x\n  }\n  function Log(x: real): real\n  {\n    x - 1.0\n  }\n  function SumArray(arr: array<real>, upTo: int): real\n  {\n    if upTo == 0 then 0.0 else SumArray(arr, upTo-1) + arr[upTo-1]\n  }\n}", "output": "class GAN {\n  var resolution: int\n  var channels: int  \n  var discriminator: array<real>\n  var generator: array<real>\n  constructor(res: int, ch: int)\n    requires res > 0 && ch > 0\n    ensures resolution == res && channels == ch\n    ensures discriminator.Length > 0 && generator.Length > 0\n  {\n    resolution := res;\n    channels := ch;\n    discriminator := new real[100];\n    generator := new real[100];\n  }\n  method Discriminator(input: array<real>) returns (output: real)\n    requires input.Length == resolution * resolution * channels\n    requires input.Length > 0\n    ensures 0.0 <= output <= 1.0\n  {\n    var sum: real := 0.0;\n    for i := 0 to input.Length\n      invariant 0 <= i <= input.Length\n      invariant sum == SumArray(input, i)\n    {\n      sum := sum + input[i];\n    }\n    output := Sigmoid(sum / (input.Length as real));\n  }\n  method Generator(seed: array<real>) returns (output: array<real>)\n    requires seed.Length > 0\n    requires resolution > 0 && channels > 0\n    ensures output.Length == resolution * resolution * channels\n  {\n    var size := resolution * resolution * channels;\n    output := new real[size];\n    var factor := SumArray(seed, seed.Length) / (seed.Length as real);\n    for i := 0 to output.Length\n      invariant 0 <= i <= output.Length\n      invariant forall j :: 0 <= j < i ==> -1.0 <= output[j] <= 1.0\n    {\n      output[i] := Tanh(factor * (i as real) / (output.Length as real));\n    }\n  }\n  method DiscriminatorLoss(realOutput: real, fakeOutput: real) returns (loss: real)\n    requires 0.0 < realOutput < 1.0 && 0.0 < fakeOutput < 1.0\n    ensures loss >= 0.0\n  {\n    loss := -Log(realOutput) - Log(1.0 - fakeOutput);\n  }\n  method GeneratorLoss(fakeOutput: real) returns (loss: real)\n    requires 0.0 < fakeOutput < 1.0\n    ensures loss >= 0.0\n  {\n    loss := -Log(fakeOutput);\n  }\n  function Sigmoid(x: real): real\n    ensures 0.0 < Sigmoid(x) < 1.0\n  {\n    1.0 / (1.0 + Exp(x))\n  }\n  function Tanh(x: real): real\n    ensures -1.0 < Tanh(x) < 1.0\n  {\n    var ex := Exp(x);\n    var enx := Exp(-x);\n    assert ex > 0.0 && enx > 0.0;\n    assert ex + enx > 0.0;\n    assert ex > 0.0 ==> ex - enx < ex + enx;\n    assert enx > 0.0 ==> -(ex - enx) < ex + enx;\n    assert -1.0 < (ex - enx) / (ex + enx) < 1.0 by {\n      calc {\n        (ex - enx) / (ex + enx);\n        < ex / (ex + enx);\n        <= 1.0;\n      }\n      calc {\n        (ex - enx) / (ex + enx);\n        > -enx / (ex + enx);\n        >= -1.0;\n      }\n    }\n    (ex - enx) / (ex + enx)\n  }\n  function Exp(x: real): real\n    ensures Exp(x) > 0.0\n  {\n    if x < 0.0 then \n      1.0 / (1.0 + (-x))\n    else \n      1.0 + x\n  }\n  function Log(x: real): real\n    requires x > 0.0\n    requires x < 1.0\n    ensures Log(x) < 0.0\n  {\n    x - 1.0\n  }\n  function SumArray(arr: array<real>, upTo: int): real\n    requires 0 <= upTo <= arr.Length\n    reads arr\n  {\n    if upTo == 0 then 0.0 else SumArray(arr, upTo-1) + arr[upTo-1]\n  }\n}", "name": "py2dfy_288", "id": 288}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method MinimumSteps(n: int, m: int, x: int, y: int) returns (result: int)\n    \n    \n    \n{\n    \n    var newX := x;\n    if m < n {\n        if m - x < x && m - x >= 0 {\n            newX := m - x;\n        }\n    } else {\n        if n - x < x && n - x >= 0 {\n            newX := n - x;\n        }\n    }\n    \n    var newY := y;\n    if m < n {\n        if n - y < y && n - y >= 0 {\n            newY := n - y;\n        }\n    } else {\n        if m - y < y && m - y >= 0 {\n            newY := m - y;\n        }\n    }\n    \n    if newX < newY {\n        result := newX;\n    } else {\n        result := newY;\n    }\n}\nfunction max(a: int, b: int): int\n{\n    if a > b then a else b\n}", "output": "method MinimumSteps(n: int, m: int, x: int, y: int) returns (result: int)\n    \n    requires n > 0 && m > 0  \n    requires 0 <= x <= max(n, m)  \n    requires 0 <= y <= max(n, m)  \n    \n    \n    ensures result >= 0  \n    ensures result <= x && result <= y  \n{\n    \n    var newX := x;\n    if m < n {\n        if m - x < x && m - x >= 0 {\n            newX := m - x;\n        }\n    } else {\n        if n - x < x && n - x >= 0 {\n            newX := n - x;\n        }\n    }\n    \n    var newY := y;\n    if m < n {\n        if n - y < y && n - y >= 0 {\n            newY := n - y;\n        }\n    } else {\n        if m - y < y && m - y >= 0 {\n            newY := m - y;\n        }\n    }\n    \n    if newX < newY {\n        result := newX;\n    } else {\n        result := newY;\n    }\n}\nfunction max(a: int, b: int): int\n{\n    if a > b then a else b\n}", "name": "py2dfy_293", "id": 293}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type CharSet = seq<bool>\nmethod CharToIndex(c: char) returns (idx: int)\n{\n  idx := c as int - 'a' as int;\n}\nmethod EmptyCharSet() returns (s: CharSet)\n{\n  s := seq(26, i => false);\n}\nmethod FullCharSet() returns (s: CharSet)\n{\n  s := seq(26, i => true);\n}\nmethod AddChar(s: CharSet, c: char) returns (newS: CharSet)\n          forall i :: 0 <= i < 26 ==> \n            if i == idx then newS[i] else newS[i] == s[i]\n{\n  var idx := c as int - 'a' as int;\n  newS := s[idx := true];\n}\nmethod Intersect(s1: CharSet, s2: CharSet) returns (result: CharSet)\n{\n  var temp := seq(26, i requires 0 <= i < 26 => s1[i] && s2[i]);\n  result := temp;\n}\nmethod CountSet(s: CharSet) returns (count: int)\n{\n  count := 0;\n  var i := 0;\n  ghost var seen := {};\n  \n  while i < 26\n  {\n    if s[i] {\n      count := count + 1;\n      seen := seen + {i};\n    }\n    i := i + 1;\n  }\n}\nmethod ProcessGroupPart1(group: seq<char>) returns (count: int)\n    (group[i] >= 'a' && group[i] <= 'z') || group[i] == '\\n'\n{\n  var answers := EmptyCharSet();\n  count := 0;\n  \n  var i := 0;\n  while i < |group|\n  {\n    if group[i] != '\\n' {\n      answers := AddChar(answers, group[i]);\n    }\n    i := i + 1;\n  }\n  \n  count := CountSet(answers);\n}\nmethod ProcessGroupPart2(group: seq<char>) returns (count: int)\n    (group[i] >= 'a' && group[i] <= 'z') || group[i] == '\\n'\n{\n  var answers := FullCharSet();\n  var currentPerson := EmptyCharSet();\n  \n  var i := 0;\n  while i < |group|\n  {\n    if group[i] != '\\n' {\n      currentPerson := AddChar(currentPerson, group[i]);\n    } else {\n      answers := Intersect(answers, currentPerson);\n      currentPerson := EmptyCharSet();\n    }\n    i := i + 1;\n  }\n  \n  \n  if |group| > 0 && group[|group|-1] != '\\n' {\n    answers := Intersect(answers, currentPerson);\n  }\n  \n  count := CountSet(answers);\n}", "output": "type CharSet = seq<bool>\nmethod CharToIndex(c: char) returns (idx: int)\n  requires c >= 'a' && c <= 'z'\n  ensures 0 <= idx < 26\n  ensures idx == c as int - 'a' as int\n{\n  idx := c as int - 'a' as int;\n}\nmethod EmptyCharSet() returns (s: CharSet)\n  ensures |s| == 26\n  ensures forall i :: 0 <= i < 26 ==> !s[i]\n{\n  s := seq(26, i => false);\n}\nmethod FullCharSet() returns (s: CharSet)\n  ensures |s| == 26\n  ensures forall i :: 0 <= i < 26 ==> s[i]\n{\n  s := seq(26, i => true);\n}\nmethod AddChar(s: CharSet, c: char) returns (newS: CharSet)\n  requires |s| == 26\n  requires c >= 'a' && c <= 'z'\n  ensures |newS| == 26\n  ensures var idx := c as int - 'a' as int;\n          forall i :: 0 <= i < 26 ==> \n            if i == idx then newS[i] else newS[i] == s[i]\n{\n  var idx := c as int - 'a' as int;\n  newS := s[idx := true];\n}\nmethod Intersect(s1: CharSet, s2: CharSet) returns (result: CharSet)\n  requires |s1| == 26 && |s2| == 26\n  ensures |result| == 26\n  ensures forall i :: 0 <= i < 26 ==> result[i] == (s1[i] && s2[i])\n{\n  var temp := seq(26, i requires 0 <= i < 26 => s1[i] && s2[i]);\n  result := temp;\n}\nmethod CountSet(s: CharSet) returns (count: int)\n  requires |s| == 26\n  ensures 0 <= count <= 26\n  ensures count == |set i | 0 <= i < 26 && s[i]|\n{\n  count := 0;\n  var i := 0;\n  ghost var seen := {};\n  \n  while i < 26\n    invariant 0 <= i <= 26\n    invariant 0 <= count <= i\n    invariant seen == set j | 0 <= j < i && s[j]\n    invariant count == |seen|\n    decreases 26 - i\n  {\n    if s[i] {\n      count := count + 1;\n      seen := seen + {i};\n    }\n    i := i + 1;\n  }\n}\nmethod ProcessGroupPart1(group: seq<char>) returns (count: int)\n  requires forall i :: 0 <= i < |group| ==> \n    (group[i] >= 'a' && group[i] <= 'z') || group[i] == '\\n'\n  ensures count >= 0\n{\n  var answers := EmptyCharSet();\n  count := 0;\n  \n  var i := 0;\n  while i < |group|\n    invariant 0 <= i <= |group|\n    invariant |answers| == 26\n    decreases |group| - i\n  {\n    if group[i] != '\\n' {\n      answers := AddChar(answers, group[i]);\n    }\n    i := i + 1;\n  }\n  \n  count := CountSet(answers);\n}\nmethod ProcessGroupPart2(group: seq<char>) returns (count: int)\n  requires forall i :: 0 <= i < |group| ==> \n    (group[i] >= 'a' && group[i] <= 'z') || group[i] == '\\n'\n  ensures count >= 0\n{\n  var answers := FullCharSet();\n  var currentPerson := EmptyCharSet();\n  \n  var i := 0;\n  while i < |group|\n    invariant 0 <= i <= |group|\n    invariant |answers| == 26\n    invariant |currentPerson| == 26\n    decreases |group| - i\n  {\n    if group[i] != '\\n' {\n      currentPerson := AddChar(currentPerson, group[i]);\n    } else {\n      answers := Intersect(answers, currentPerson);\n      currentPerson := EmptyCharSet();\n    }\n    i := i + 1;\n  }\n  \n  \n  if |group| > 0 && group[|group|-1] != '\\n' {\n    answers := Intersect(answers, currentPerson);\n  }\n  \n  count := CountSet(answers);\n}", "name": "py2dfy_283", "id": 283}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type Process(==) = int  \ndatatype CState = Thinking | Hungry | Eating  \nclass TicketSystem\n{\n  var ticket: int  \n  var serving: int  \n  const P: set<Process>  \n  \n  var cs: map<Process, CState>  \n  var t: map<Process, int>  \n  \n  \n  predicate Valid()\n  {\n    && cs.Keys == t.Keys == P  \n    && serving <= ticket\n    && (forall p ::  \n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  \n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  \n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n  \n  constructor (processes: set<Process>)\n  {\n    P := processes;\n    ticket, serving := 0, 0;  \n    \n    cs := map p | p in processes :: Thinking;  \n    t := map p | p in processes :: 0;\n  }\n  \n  \n  method Request(p: Process)\n  {\n    t, ticket := t[p := ticket], ticket + 1;  \n    cs := cs[p := Hungry];  \n  }\n  \n  method Enter(p: Process)\n  {\n    if t[p] == serving  \n    {\n      cs := cs[p := Eating];  \n    }\n  }\n  \n  method Leave(p: Process)\n  {\n    \n    serving := serving + 1;  \n    cs := cs[p := Thinking];  \n  }\n  \n  lemma MutualExclusion(p: Process, q: Process)\n    \n    \n  {\n  }\n}\nmethod Run(processes: set<Process>)\n{\n  var ts := new TicketSystem(processes);\n  var schedule := [];  \n  var trace := [(ts.ticket, ts.serving, ts.cs, ts.t)];  \n  \n  while true\n  {\n    var p :| p in ts.P;  \n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    schedule := schedule + [p];\n    trace:=trace + [(ts.ticket, ts.serving, ts.cs, ts.t)];\n  }\n}\nmethod RunFromSchedule(processes: set<Process>, schedule: nat -> Process)\n{\n  var ts := new TicketSystem(processes);\n  var n := 0;\n  \n  while true\n  {\n    var p := schedule(n);\n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    n := n + 1;\n  }\n}", "output": "type Process(==) = int  \ndatatype CState = Thinking | Hungry | Eating  \nclass TicketSystem\n{\n  var ticket: int  \n  var serving: int  \n  const P: set<Process>  \n  \n  var cs: map<Process, CState>  \n  var t: map<Process, int>  \n  \n  \n  predicate Valid()\n    reads this  \n  {\n    && cs.Keys == t.Keys == P  \n    && serving <= ticket\n    && (forall p ::  \n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  \n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  \n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n  \n  constructor (processes: set<Process>)\n    ensures Valid()  \n    ensures P == processes  \n  {\n    P := processes;\n    ticket, serving := 0, 0;  \n    \n    cs := map p | p in processes :: Thinking;  \n    t := map p | p in processes :: 0;\n  }\n  \n  \n  method Request(p: Process)\n    requires Valid() && p in P && cs[p] == Thinking  \n    modifies this  \n    ensures Valid()  \n  {\n    t, ticket := t[p := ticket], ticket + 1;  \n    cs := cs[p := Hungry];  \n  }\n  \n  method Enter(p: Process)\n    requires Valid() && p in P && cs[p] == Hungry  \n    modifies this  \n    ensures Valid()  \n  {\n    if t[p] == serving  \n    {\n      cs := cs[p := Eating];  \n    }\n  }\n  \n  method Leave(p: Process)\n    requires Valid() && p in P && cs[p] == Eating  \n    modifies this  \n    ensures Valid()  \n  {\n    \n    serving := serving + 1;  \n    cs := cs[p := Thinking];  \n  }\n  \n  lemma MutualExclusion(p: Process, q: Process)\n    \n    requires Valid() && p in P && q in P\n    requires cs[p] == Eating && cs[q] == Eating\n    \n    ensures p == q\n  {\n  }\n}\nmethod Run(processes: set<Process>)\n  requires processes != {}  \n  decreases *  \n{\n  var ts := new TicketSystem(processes);\n  var schedule := [];  \n  var trace := [(ts.ticket, ts.serving, ts.cs, ts.t)];  \n  \n  while true\n    invariant ts.Valid()\n    decreases *  \n  {\n    var p :| p in ts.P;  \n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    schedule := schedule + [p];\n    trace:=trace + [(ts.ticket, ts.serving, ts.cs, ts.t)];\n  }\n}\nmethod RunFromSchedule(processes: set<Process>, schedule: nat -> Process)\n  requires processes != {}\n  requires forall n :: schedule(n) in processes\n  decreases *\n{\n  var ts := new TicketSystem(processes);\n  var n := 0;\n  \n  while true\n    invariant ts.Valid()\n    decreases *  \n  {\n    var p := schedule(n);\n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    n := n + 1;\n  }\n}", "name": "py2dfy_273", "id": 273}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class A {\n  var a: array<array<int>>\n  constructor(b: array<array<int>>) {\n    var c := b;\n    a := b;\n  }\n}\nmethod sub(a: array<array<int>>)\n{\n  print a[0][0], \" \";\n  var b := a;\n  print b[0][0], \"\\n\";\n}\nmethod Main() {\n  var a := new array<int>[2];\n  a[0] := new int[2];\n  a[0][0] := 42;\n  print a[0][0], \" \";\n  sub(a);\n  var b := new A(a);\n  MoreTests();\n}\nmethod MoreTests() {\n  TestA();\n  TestB();\n  TestC();\n  TestD();\n  TestE();\n}\nmethod TestA() {\n  var a := new int[2];\n  var b := new array<int>[2];\n  var c := new array<array2<int>>[2];\n  var d := new array2<array<int>>[2];\n  var e := new array4<array3<int>>[2];\n  a[0] := 5000;\n  b[0] := new int[10];\n  b[0][4] := 5000;\n  c[0] := new array2<int>[10];\n  c[0][4] := new int[70,80];\n  c[0][4][63,73] := 5000;\n  d[0] := new array<int>[70,80];\n  d[0][63,73] := new int[10];\n  d[0][63,73][4] := 5000;\n  e[0] := new array3<int>[12,2,3,15];\n  e[0][11,1,2,14] := new int[20,1,1];\n  e[0][11,1,2,14][18,0,0] := 5000;\n  print a[0], \" \", b[0][4], \" \";\n  print c[0][4][63,73], \" \", d[0][63,73][4], \" \";\n  print e[0][11,1,2,14][18,0,0], \"\\n\";\n}\nmethod TestB() {\n  var a := new int[2,3];\n  var b := new array<int>[2,3];\n  var c := new array<array2<int>>[2,3];\n  var d := new array2<array<int>>[2,3];\n  var e := new array4<array3<int>>[2,3];\n}\nmethod TestC() {\n  var a := new int[2];\n  var b := new array?<int>[2];\n  var c := new array?<array2?<int>>[2];\n  var d := new array2?<array?<int>>[2];\n  var e := new array4?<array3?<int>>[2];\n}\nmethod TestD() {\n  var a: array2<int> := new int[3,2];\n  var b: array<array2<int>> := new array2<int>[5];\n  b := new array2<int>[5][a, a, a, a, a];\n  b := new array2<int>[5](_ => a);\n  var c: array3<array<array2<int>>> := new array<array2<int>>[5,4,3];\n  c := new array<array2<int>>[5,4,3]((_,_,_) => b);\n}\nmethod TestE() {\n  var a: array2?<int> := new int[3,2];\n  var b: array?<array2?<int>> := new array2?<int>[5];\n  b := new array2?<int>[5][a, a, a, a, a];\n  b := new array2?<int>[5](_ => a);\n  var c: array3?<array?<array2?<int>>> := new array?<array2?<int>>[5,4,3];\n  c := new array?<array2?<int>>[5,4,3]((_,_,_) => b);\n  var d: array15?<int>;\n  var e: array16<int>;\n}", "output": "class A {\n  var a: array<array<int>>\n  constructor(b: array<array<int>>) {\n    var c := b;\n    a := b;\n  }\n}\nmethod sub(a: array<array<int>>)\n  requires a.Length > 0\n  requires a[0].Length > 0\n{\n  print a[0][0], \" \";\n  var b := a;\n  print b[0][0], \"\\n\";\n}\nmethod Main() {\n  var a := new array<int>[2];\n  a[0] := new int[2];\n  a[0][0] := 42;\n  print a[0][0], \" \";\n  sub(a);\n  var b := new A(a);\n  MoreTests();\n}\nmethod MoreTests() {\n  TestA();\n  TestB();\n  TestC();\n  TestD();\n  TestE();\n}\nmethod TestA() {\n  var a := new int[2];\n  var b := new array<int>[2];\n  var c := new array<array2<int>>[2];\n  var d := new array2<array<int>>[2];\n  var e := new array4<array3<int>>[2];\n  a[0] := 5000;\n  b[0] := new int[10];\n  b[0][4] := 5000;\n  c[0] := new array2<int>[10];\n  c[0][4] := new int[70,80];\n  c[0][4][63,73] := 5000;\n  d[0] := new array<int>[70,80];\n  d[0][63,73] := new int[10];\n  d[0][63,73][4] := 5000;\n  e[0] := new array3<int>[12,2,3,15];\n  e[0][11,1,2,14] := new int[20,1,1];\n  e[0][11,1,2,14][18,0,0] := 5000;\n  print a[0], \" \", b[0][4], \" \";\n  print c[0][4][63,73], \" \", d[0][63,73][4], \" \";\n  print e[0][11,1,2,14][18,0,0], \"\\n\";\n}\nmethod TestB() {\n  var a := new int[2,3];\n  var b := new array<int>[2,3];\n  var c := new array<array2<int>>[2,3];\n  var d := new array2<array<int>>[2,3];\n  var e := new array4<array3<int>>[2,3];\n}\nmethod TestC() {\n  var a := new int[2];\n  var b := new array?<int>[2];\n  var c := new array?<array2?<int>>[2];\n  var d := new array2?<array?<int>>[2];\n  var e := new array4?<array3?<int>>[2];\n}\nmethod TestD() {\n  var a: array2<int> := new int[3,2];\n  var b: array<array2<int>> := new array2<int>[5];\n  b := new array2<int>[5][a, a, a, a, a];\n  b := new array2<int>[5](_ => a);\n  var c: array3<array<array2<int>>> := new array<array2<int>>[5,4,3];\n  c := new array<array2<int>>[5,4,3]((_,_,_) => b);\n}\nmethod TestE() {\n  var a: array2?<int> := new int[3,2];\n  var b: array?<array2?<int>> := new array2?<int>[5];\n  b := new array2?<int>[5][a, a, a, a, a];\n  b := new array2?<int>[5](_ => a);\n  var c: array3?<array?<array2?<int>>> := new array?<array2?<int>>[5,4,3];\n  c := new array?<array2?<int>>[5,4,3]((_,_,_) => b);\n  var d: array15?<int>;\n  var e: array16<int>;\n}", "name": "py2dfy_236", "id": 236}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class ListOperations {\n    \n    var elements: seq<int>  \n    constructor()\n    {\n        elements := [];\n    }\n    \n    method Append(value: int)  \n    {\n        elements := elements + [value];\n    }\n    \n    method CreateRangeList(start: int, end: int) returns (result: seq<int>)\n    {\n        var current := start;\n        result := [];\n        \n        while current < end\n        {\n            result := result + [current];\n            current := current + 1;\n        }\n    }\n    \n    method Pop() returns (value: int)  \n    {\n        value := elements[|elements|-1];\n        elements := elements[..|elements|-1];\n    }\n    \n    method PopAt(index: int) returns (value: int)  \n    {\n        value := elements[index];\n        elements := elements[..index] + elements[index+1..];\n    }\n    \n    method UpdateAt(index: int, value: int)  \n    {\n        elements := elements[..index] + [value] + elements[index+1..];\n    }\n    \n    method Extend(other: seq<int>)  \n    {\n        elements := elements + other;\n    }\n    \n    method Insert(index: int, value: int)  \n    {\n        elements := elements[..index] + [value] + elements[index..];\n    }\n    \n    method Clear()\n    {\n        elements := [];\n    }\n    \n    method Length() returns (len: int)\n    {\n        return |elements|;\n    }\n}\nmethod Main()\n{\n    var ops := new ListOperations();\n    \n    \n    var rangeList := ops.CreateRangeList(0, 5);\n    \n    \n    ops.Append(1);\n    ops.Append(2);\n    \n    \n    var lastElement := ops.Pop();\n    \n    \n    ops.Insert(1, 3);\n}", "output": "class ListOperations {\n    \n    var elements: seq<int>  \n    constructor()\n    ensures elements == []\n    {\n        elements := [];\n    }\n    \n    method Append(value: int)  \n    modifies this\n    ensures elements == old(elements) + [value]\n    ensures |elements| == |old(elements)| + 1\n    {\n        elements := elements + [value];\n    }\n    \n    method CreateRangeList(start: int, end: int) returns (result: seq<int>)\n    requires start <= end\n    ensures |result| == end - start\n    ensures forall i :: 0 <= i < |result| ==> result[i] == start + i\n    {\n        var current := start;\n        result := [];\n        \n        while current < end\n        invariant start <= current <= end\n        invariant |result| == current - start\n        invariant forall i :: 0 <= i < |result| ==> result[i] == start + i\n        {\n            result := result + [current];\n            current := current + 1;\n        }\n    }\n    \n    method Pop() returns (value: int)  \n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements)[..|old(elements)|-1]\n    ensures value == old(elements)[|old(elements)|-1]\n    ensures |elements| == |old(elements)| - 1\n    {\n        value := elements[|elements|-1];\n        elements := elements[..|elements|-1];\n    }\n    \n    method PopAt(index: int) returns (value: int)  \n    requires 0 <= index < |elements|\n    modifies this\n    ensures elements == old(elements)[..index] + old(elements)[index+1..]\n    ensures value == old(elements)[index]\n    ensures |elements| == |old(elements)| - 1\n    {\n        value := elements[index];\n        elements := elements[..index] + elements[index+1..];\n    }\n    \n    method UpdateAt(index: int, value: int)  \n    requires 0 <= index < |elements|\n    modifies this\n    ensures |elements| == |old(elements)|\n    ensures elements == old(elements)[..index] + [value] + old(elements)[index+1..]\n    {\n        elements := elements[..index] + [value] + elements[index+1..];\n    }\n    \n    method Extend(other: seq<int>)  \n    modifies this\n    ensures elements == old(elements) + other\n    ensures |elements| == |old(elements)| + |other|\n    {\n        elements := elements + other;\n    }\n    \n    method Insert(index: int, value: int)  \n    requires 0 <= index <= |elements|\n    modifies this\n    ensures elements == old(elements)[..index] + [value] + old(elements)[index..]\n    ensures |elements| == |old(elements)| + 1\n    {\n        elements := elements[..index] + [value] + elements[index..];\n    }\n    \n    method Clear()\n    modifies this\n    ensures elements == []\n    {\n        elements := [];\n    }\n    \n    method Length() returns (len: int)\n    ensures len == |elements|\n    {\n        return |elements|;\n    }\n}\nmethod Main()\n{\n    var ops := new ListOperations();\n    \n    \n    var rangeList := ops.CreateRangeList(0, 5);\n    assert |rangeList| == 5;\n    \n    \n    ops.Append(1);\n    ops.Append(2);\n    \n    \n    var lastElement := ops.Pop();\n    \n    \n    ops.Insert(1, 3);\n}", "name": "py2dfy_295", "id": 295}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Tag {\n  var title: string\n  constructor(t: string)\n  {\n    title := t;\n  }\n}\nclass Category {\n  var title: string\n  constructor(t: string)\n  {\n    title := t;\n  }\n}\nclass Blog {\n  var title: string\n  var context: string  \n  var tags: seq<Tag>\n  var category: Category?\n  constructor(t: string)\n  {\n    title := t;\n    context := \"\";\n    tags := [];\n    category := null;\n  }\n}\nclass Database {\n  var blogs: seq<Blog>\n  var tags: seq<Tag>\n  var categories: seq<Category>\n  constructor()\n  {\n    blogs := [];\n    tags := [];\n    categories := [];\n  }\n  \n  method InitTestData()\n  {\n    \n    var t1 := new Tag(\"emacs\");\n    var t2 := new Tag(\"python\");\n    tags := [t1, t2];\n    \n    var c1 := new Category(\"program\");\n    var c2 := new Category(\"edit\");\n    categories := [c1, c2];\n    \n    var b1 := new Blog(\"first blog\");\n    b1.context := \"this is my first blog, hello world\";\n    var b2 := new Blog(\"second blog\"); \n    b2.context := \"this is my second blog, hello python\";\n    b2.tags := [t1, t2];\n    var b3 := new Blog(\"third blog\");\n    b3.context := \"this is my third blog, hello python\";\n    b3.tags := [t1];\n    b3.category := c2;\n    var b4 := new Blog(\"fourth blog\");\n    b4.context := \"this is my fourth blog, hello python\";\n    b4.tags := [t2];\n    b4.category := c1;\n    blogs := [b1, b2, b3, b4];\n  }\n  \n  method FindBlogsByTag(searchTag: Tag?) returns (result: seq<Blog>)\n  {\n    result := [];\n    var i := 0;\n    while i < |blogs|\n    {\n      var blog := blogs[i];\n      if searchTag != null && searchTag in blog.tags {\n        result := result + [blog];\n      }\n      i := i + 1;\n    }\n  }\n}", "output": "class Tag {\n  var title: string\n  constructor(t: string)\n    ensures title == t\n  {\n    title := t;\n  }\n}\nclass Category {\n  var title: string\n  constructor(t: string)\n    ensures title == t\n  {\n    title := t;\n  }\n}\nclass Blog {\n  var title: string\n  var context: string  \n  var tags: seq<Tag>\n  var category: Category?\n  constructor(t: string)\n    ensures title == t\n    ensures context == \"\"\n    ensures tags == []\n    ensures category == null\n  {\n    title := t;\n    context := \"\";\n    tags := [];\n    category := null;\n  }\n}\nclass Database {\n  var blogs: seq<Blog>\n  var tags: seq<Tag>\n  var categories: seq<Category>\n  constructor()\n    ensures blogs == []\n    ensures tags == []\n    ensures categories == []\n  {\n    blogs := [];\n    tags := [];\n    categories := [];\n  }\n  \n  method InitTestData()\n    modifies this\n    ensures |tags| == 2\n    ensures |categories| == 2\n    ensures |blogs| == 4\n  {\n    \n    var t1 := new Tag(\"emacs\");\n    var t2 := new Tag(\"python\");\n    tags := [t1, t2];\n    \n    var c1 := new Category(\"program\");\n    var c2 := new Category(\"edit\");\n    categories := [c1, c2];\n    \n    var b1 := new Blog(\"first blog\");\n    b1.context := \"this is my first blog, hello world\";\n    var b2 := new Blog(\"second blog\"); \n    b2.context := \"this is my second blog, hello python\";\n    b2.tags := [t1, t2];\n    var b3 := new Blog(\"third blog\");\n    b3.context := \"this is my third blog, hello python\";\n    b3.tags := [t1];\n    b3.category := c2;\n    var b4 := new Blog(\"fourth blog\");\n    b4.context := \"this is my fourth blog, hello python\";\n    b4.tags := [t2];\n    b4.category := c1;\n    blogs := [b1, b2, b3, b4];\n  }\n  \n  method FindBlogsByTag(searchTag: Tag?) returns (result: seq<Blog>)\n    modifies this\n    ensures forall b :: b in result ==> b in blogs\n    ensures searchTag != null ==> forall b :: b in result ==> searchTag in b.tags\n  {\n    result := [];\n    var i := 0;\n    while i < |blogs|\n      invariant 0 <= i <= |blogs|\n      invariant forall b :: b in result ==> b in blogs\n      invariant searchTag != null ==> forall b :: b in result ==> searchTag in b.tags\n    {\n      var blog := blogs[i];\n      if searchTag != null && searchTag in blog.tags {\n        result := result + [blog];\n      }\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_226", "id": 226}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method {:extern} Print(s: string)\nmethod {:extern} PrintLine(s: string) \nmethod {:extern} ReadLine() returns (s: string)\nmethod {:extern} Sleep(ms: int)\nmethod {:extern} ClearScreen()\nfunction ToUpper(s: string): string\nfunction Contains(s: string, c: char): bool\n{\n  exists i :: 0 <= i < |s| && s[i] == c\n}\nmethod SexoVerificacao(x: string) returns (result: string)\n{\n  var current := x;\n  \n  \n  while current != \"M\" && current != \"F\"\n  {\n    Print(\"===Entre com um valor válido!===\");\n    Sleep(1000);  \n    Print(\"Sexo[M/F]: \");\n    current := ReadLine();\n    current := ToUpper(current);\n  }\n  \n  return current;\n}\nmethod DesejaContinuar() returns (result: string)\n{\n  var v: string;\n  Print(\"Deseja continuar[S/N]? \");\n  v := ReadLine();\n  v := ToUpper(v);\n  \n  while v != \"S\" && v != \"N\"\n  {\n    PrintLine(\"ERRO! ENTRE COM UM VALOR VÁLIDO\");\n    Sleep(1000);\n    Print(\"Deseja continuar[S/N]? \");\n    v := ReadLine();\n    v := ToUpper(v);\n  }\n  \n  return v;\n}\nmethod Topo(msg: string)\n{\n  var separator := RepeatChar('=', 60);\n  PrintLine(separator);\n  PrintLine(CenterString(msg, 60));\n  PrintLine(separator);\n  PrintLine(\"\");\n}\nmethod Menu() returns (result: int)\n{\n  var opt: string;\n  \n  while true\n  {\n    Sleep(1000);\n    ClearScreen();\n    Topo(\"MENU PRINCIPAL\");\n    PrintLine(\"[1] NOVO CADASTRO\");\n    PrintLine(\"[2] EXIBIR TODOS OS CADASTROS\");\n    PrintLine(\"[3] EXCLUIR UM CADASTRO\");\n    PrintLine(\"[4] GERAR ARQUIVO COM TODOS OS CADASTROS\");\n    PrintLine(\"[5] SAIR\");\n    Print(\"\\nESCOLHA UMA DAS OPÇÕES DO MENU... \");\n    \n    opt := ReadLine();\n    if opt == \"1\" { result := 1; break; }\n    else if opt == \"2\" { result := 2; break; }\n    else if opt == \"3\" { result := 3; break; }\n    else if opt == \"4\" { result := 4; break; }\n    else if opt == \"5\" { result := 5; break; }\n    \n    PrintLine(\"ERRO!!! Entre com um valor válido!\");\n    Sleep(1500);\n  }\n  \n  return result;\n}\nfunction RepeatChar(c: char, n: int): (output: string)\n{\n  if n == 0 then \"\"\n  else [c] + RepeatChar(c, n-1)\n}\nfunction CenterString(s: string, width: int): (output: string)\n{\n  s + RepeatChar(' ', width - |s|)  \n}", "output": "method {:extern} Print(s: string)\nmethod {:extern} PrintLine(s: string) \nmethod {:extern} ReadLine() returns (s: string)\nmethod {:extern} Sleep(ms: int)\nmethod {:extern} ClearScreen()\nfunction ToUpper(s: string): string\nfunction Contains(s: string, c: char): bool\n{\n  exists i :: 0 <= i < |s| && s[i] == c\n}\nmethod SexoVerificacao(x: string) returns (result: string)\n  ensures result == \"M\" || result == \"F\"  \n  decreases *  \n{\n  var current := x;\n  \n  \n  while current != \"M\" && current != \"F\"\n    invariant true  \n    decreases *  \n  {\n    Print(\"===Entre com um valor válido!===\");\n    Sleep(1000);  \n    Print(\"Sexo[M/F]: \");\n    current := ReadLine();\n    current := ToUpper(current);\n  }\n  \n  return current;\n}\nmethod DesejaContinuar() returns (result: string)\n  ensures result == \"S\" || result == \"N\"  \n  decreases *  \n{\n  var v: string;\n  Print(\"Deseja continuar[S/N]? \");\n  v := ReadLine();\n  v := ToUpper(v);\n  \n  while v != \"S\" && v != \"N\"\n    invariant true  \n    decreases *  \n  {\n    PrintLine(\"ERRO! ENTRE COM UM VALOR VÁLIDO\");\n    Sleep(1000);\n    Print(\"Deseja continuar[S/N]? \");\n    v := ReadLine();\n    v := ToUpper(v);\n  }\n  \n  return v;\n}\nmethod Topo(msg: string)\n  requires |msg| <= 60  \n{\n  var separator := RepeatChar('=', 60);\n  PrintLine(separator);\n  PrintLine(CenterString(msg, 60));\n  PrintLine(separator);\n  PrintLine(\"\");\n}\nmethod Menu() returns (result: int)\n  ensures 1 <= result <= 5  \n  decreases *  \n{\n  var opt: string;\n  \n  while true\n    invariant true  \n    decreases *  \n  {\n    Sleep(1000);\n    ClearScreen();\n    Topo(\"MENU PRINCIPAL\");\n    PrintLine(\"[1] NOVO CADASTRO\");\n    PrintLine(\"[2] EXIBIR TODOS OS CADASTROS\");\n    PrintLine(\"[3] EXCLUIR UM CADASTRO\");\n    PrintLine(\"[4] GERAR ARQUIVO COM TODOS OS CADASTROS\");\n    PrintLine(\"[5] SAIR\");\n    Print(\"\\nESCOLHA UMA DAS OPÇÕES DO MENU... \");\n    \n    opt := ReadLine();\n    if opt == \"1\" { result := 1; break; }\n    else if opt == \"2\" { result := 2; break; }\n    else if opt == \"3\" { result := 3; break; }\n    else if opt == \"4\" { result := 4; break; }\n    else if opt == \"5\" { result := 5; break; }\n    \n    PrintLine(\"ERRO!!! Entre com um valor válido!\");\n    Sleep(1500);\n  }\n  \n  return result;\n}\nfunction RepeatChar(c: char, n: int): (output: string)\n  requires n >= 0\n  ensures |output| == n\n  ensures forall i :: 0 <= i < n ==> output[i] == c\n{\n  if n == 0 then \"\"\n  else [c] + RepeatChar(c, n-1)\n}\nfunction CenterString(s: string, width: int): (output: string)\n  requires width >= |s|\n  ensures |output| == width\n{\n  s + RepeatChar(' ', width - |s|)  \n}", "name": "py2dfy_296", "id": 296}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Dimensions {\n  var width: int\n  var height: int\n  constructor(w: int, h: int)\n  {\n    width := w;\n    height := h;\n  }\n}\nclass Image {\n  var dimensions: Dimensions\n  var format: string\n  var mode: string\n  var pixelData: array2<int>  \n  constructor(fmt: string, w: int, h: int, m: string)\n  {\n    format := fmt;\n    mode := m;\n    dimensions := new Dimensions(w, h);\n    pixelData := new int[h, w];\n  }\n  \n  static method Open(filename: string) returns (img: Image?)\n  {\n    \n    \n    img := new Image(\"JPEG\", 1920, 1080, \"RGB\");\n  }\n  \n  method Thumbnail(maxWidth: int, maxHeight: int)\n  {\n    var originalWidth := dimensions.width;\n    var originalHeight := dimensions.height;\n    \n    \n    var widthRatio := (maxWidth as real) / (originalWidth as real);\n    var heightRatio := (maxHeight as real) / (originalHeight as real);\n    \n    \n    var ratio := if widthRatio < heightRatio then widthRatio else heightRatio;\n    \n    var newWidth := ((originalWidth as real * ratio).Floor) as int;\n    var newHeight := ((originalHeight as real * ratio).Floor) as int;\n    \n    \n    if newWidth < 1 { newWidth := 1; }\n    if newHeight < 1 { newHeight := 1; }\n    \n    \n    dimensions := new Dimensions(newWidth, newHeight);\n    \n    pixelData := new int[newHeight, newWidth];\n  }\n  \n  method Save(filename: string, format: string)\n  {\n    \n  }\n}\nmethod Main() {\n  var img := Image.Open(\"IMG_4597.JPG\");\n  if img != null {\n    print img.format, \" \", img.dimensions.width, \"x\", img.dimensions.height, \" \", img.mode, \"\\n\";\n    img.Thumbnail(800, 600);\n    img.Save(\"thumb2.jpg\", \"JPEG\");\n  }\n}", "output": "class Dimensions {\n  var width: int\n  var height: int\n  constructor(w: int, h: int)\n    requires w > 0 && h > 0  \n    ensures width == w && height == h\n  {\n    width := w;\n    height := h;\n  }\n}\nclass Image {\n  var dimensions: Dimensions\n  var format: string\n  var mode: string\n  var pixelData: array2<int>  \n  constructor(fmt: string, w: int, h: int, m: string)\n    requires w > 0 && h > 0  \n    ensures format == fmt\n    ensures mode == m\n    ensures fresh(dimensions)\n    ensures dimensions.width == w\n    ensures dimensions.height == h\n    ensures fresh(pixelData)\n    ensures pixelData.Length0 == h && pixelData.Length1 == w\n  {\n    format := fmt;\n    mode := m;\n    dimensions := new Dimensions(w, h);\n    pixelData := new int[h, w];\n  }\n  \n  static method Open(filename: string) returns (img: Image?)\n    requires |filename| > 0\n    ensures img != null ==> fresh(img)\n    ensures img != null ==> img.dimensions.width > 0\n    ensures img != null ==> img.dimensions.height > 0\n  {\n    \n    \n    img := new Image(\"JPEG\", 1920, 1080, \"RGB\");\n  }\n  \n  method Thumbnail(maxWidth: int, maxHeight: int)\n    requires maxWidth > 0 && maxHeight > 0\n    requires dimensions.width > 0 && dimensions.height > 0\n    modifies this`dimensions, this`pixelData\n    ensures dimensions.width <= maxWidth\n    ensures dimensions.height <= maxHeight\n    ensures dimensions.width > 0 && dimensions.height > 0\n  {\n    var originalWidth := dimensions.width;\n    var originalHeight := dimensions.height;\n    \n    \n    var widthRatio := (maxWidth as real) / (originalWidth as real);\n    var heightRatio := (maxHeight as real) / (originalHeight as real);\n    \n    \n    var ratio := if widthRatio < heightRatio then widthRatio else heightRatio;\n    \n    var newWidth := ((originalWidth as real * ratio).Floor) as int;\n    var newHeight := ((originalHeight as real * ratio).Floor) as int;\n    \n    \n    if newWidth < 1 { newWidth := 1; }\n    if newHeight < 1 { newHeight := 1; }\n    \n    \n    dimensions := new Dimensions(newWidth, newHeight);\n    \n    pixelData := new int[newHeight, newWidth];\n  }\n  \n  method Save(filename: string, format: string)\n    requires |filename| > 0\n    requires |format| > 0\n    requires dimensions.width > 0 && dimensions.height > 0\n  {\n    \n  }\n}\nmethod Main() {\n  var img := Image.Open(\"IMG_4597.JPG\");\n  if img != null {\n    print img.format, \" \", img.dimensions.width, \"x\", img.dimensions.height, \" \", img.mode, \"\\n\";\n    img.Thumbnail(800, 600);\n    img.Save(\"thumb2.jpg\", \"JPEG\");\n  }\n}", "name": "py2dfy_298", "id": 298}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Contact {\n  var contact: seq<char>\n  \n  constructor()\n  {\n    contact := [];\n  }\n}\nclass ContactDatabase {\n  var contacts: seq<Contact>\n  \n  constructor()\n  {\n    contacts := [];\n  }\n  \n  \n  method MigrateContactField(maxLength: nat) returns (success: bool)\n  {\n    success := true;\n    var i := 0;\n    \n    \n    while i < |contacts|\n    {\n      var currentContact := contacts[i];\n      \n      if |currentContact.contact| > maxLength {\n        \n        currentContact.contact := currentContact.contact[..maxLength];\n      }\n      \n      i := i + 1;\n    }\n  }\n}", "output": "class Contact {\n  var contact: seq<char>\n  \n  constructor()\n    ensures contact == []\n  {\n    contact := [];\n  }\n}\nclass ContactDatabase {\n  var contacts: seq<Contact>\n  \n  constructor()\n    ensures contacts == []\n  {\n    contacts := [];\n  }\n  \n  \n  method MigrateContactField(maxLength: nat) returns (success: bool)\n    requires maxLength == 512  \n    requires |contacts| > 0  \n    modifies contacts, this`contacts\n    modifies contacts[..]  \n    ensures success ==> forall c :: c in contacts ==> |c.contact| <= maxLength\n    ensures |contacts| == old(|contacts|)  \n  {\n    success := true;\n    var i := 0;\n    \n    \n    while i < |contacts|\n      invariant 0 <= i <= |contacts|\n      invariant forall j :: 0 <= j < i ==> |contacts[j].contact| <= maxLength\n      invariant |contacts| == old(|contacts|)\n      invariant forall c :: c in contacts ==> c in old(contacts)\n      modifies contacts[..]\n    {\n      var currentContact := contacts[i];\n      \n      if |currentContact.contact| > maxLength {\n        \n        currentContact.contact := currentContact.contact[..maxLength];\n      }\n      \n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_303", "id": 303}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class InterfaceData {\n  var data: seq<real>\n  constructor()\n  {\n    data := [];\n  }\n  method GetData() returns (result: seq<real>)\n  {\n    return data;\n  }\n  method SetData(newData: seq<real>)\n  {\n    data := newData;\n  }\n}\nclass CoSimulationConvergenceAccelerator {\n  var interfaceData: InterfaceData?\n  var inputData: seq<real>\n  var echoLevel: int\n  constructor(echoLevel: int, interfaceData: InterfaceData?)\n  {\n    this.echoLevel := echoLevel;\n    this.interfaceData := interfaceData;\n    this.inputData := [];\n  }\n  method Initialize()\n  {\n    \n  }\n  method Finalize()\n  {\n    \n  }\n  method InitializeSolutionStep()\n  {\n    \n  }\n  method FinalizeSolutionStep()\n  {\n    \n  }\n  method InitializeCouplingIteration()\n  {\n    inputData := interfaceData.GetData();\n  }\n  method FinalizeCouplingIteration()\n  {\n    \n  }\n  method ComputeAndApplyUpdate()\n  {\n    var currentData := interfaceData.GetData();\n    \n    \n    if |currentData| == |inputData| {\n      var residual := SubtractSequences(currentData, inputData);\n      var update := ComputeUpdate(residual, inputData);\n      var updatedData := AddSequences(inputData, update);\n      interfaceData.SetData(updatedData);\n    } else {\n      \n      interfaceData.SetData(inputData);\n    }\n  }\n  \n  method SubtractSequences(seq1: seq<real>, seq2: seq<real>) returns (result: seq<real>)\n  {\n    result := [];\n    var i := 0;\n    while i < |seq1|\n    {\n      result := result + [seq1[i] - seq2[i]];\n      i := i + 1;\n    }\n  }\n  \n  method AddSequences(seq1: seq<real>, seq2: seq<real>) returns (result: seq<real>)\n  {\n    result := [];\n    var i := 0;\n    while i < |seq1|\n    {\n      result := result + [seq1[i] + seq2[i]];\n      i := i + 1;\n    }\n  }\n  \n  method {:axiom} ComputeUpdate(residual: seq<real>, previousData: seq<real>) returns (result: seq<real>)\n}", "output": "class InterfaceData {\n  var data: seq<real>\n  constructor()\n    ensures data == []\n  {\n    data := [];\n  }\n  method GetData() returns (result: seq<real>)\n    ensures result == data\n  {\n    return data;\n  }\n  method SetData(newData: seq<real>)\n    modifies this\n    ensures data == newData\n  {\n    data := newData;\n  }\n}\nclass CoSimulationConvergenceAccelerator {\n  var interfaceData: InterfaceData?\n  var inputData: seq<real>\n  var echoLevel: int\n  constructor(echoLevel: int, interfaceData: InterfaceData?)\n    requires interfaceData != null\n    requires echoLevel >= 0\n    ensures this.echoLevel == echoLevel\n    ensures this.interfaceData == interfaceData\n    ensures this.inputData == []\n  {\n    this.echoLevel := echoLevel;\n    this.interfaceData := interfaceData;\n    this.inputData := [];\n  }\n  method Initialize()\n  {\n    \n  }\n  method Finalize()\n  {\n    \n  }\n  method InitializeSolutionStep()\n  {\n    \n  }\n  method FinalizeSolutionStep()\n  {\n    \n  }\n  method InitializeCouplingIteration()\n    requires interfaceData != null\n    modifies this\n    ensures interfaceData != null\n    ensures |inputData| == |interfaceData.data|\n  {\n    inputData := interfaceData.GetData();\n  }\n  method FinalizeCouplingIteration()\n  {\n    \n  }\n  method ComputeAndApplyUpdate()\n    requires interfaceData != null\n    requires |inputData| > 0\n    modifies interfaceData\n    ensures interfaceData != null\n    ensures |interfaceData.data| == |inputData|\n  {\n    var currentData := interfaceData.GetData();\n    assert |currentData| == |interfaceData.data|;\n    \n    \n    if |currentData| == |inputData| {\n      var residual := SubtractSequences(currentData, inputData);\n      var update := ComputeUpdate(residual, inputData);\n      var updatedData := AddSequences(inputData, update);\n      interfaceData.SetData(updatedData);\n    } else {\n      \n      interfaceData.SetData(inputData);\n    }\n  }\n  \n  method SubtractSequences(seq1: seq<real>, seq2: seq<real>) returns (result: seq<real>)\n    requires |seq1| == |seq2|\n    ensures |result| == |seq1|\n  {\n    result := [];\n    var i := 0;\n    while i < |seq1|\n      invariant 0 <= i <= |seq1|\n      invariant |result| == i\n    {\n      result := result + [seq1[i] - seq2[i]];\n      i := i + 1;\n    }\n  }\n  \n  method AddSequences(seq1: seq<real>, seq2: seq<real>) returns (result: seq<real>)\n    requires |seq1| == |seq2|\n    ensures |result| == |seq1|\n  {\n    result := [];\n    var i := 0;\n    while i < |seq1|\n      invariant 0 <= i <= |seq1|\n      invariant |result| == i\n    {\n      result := result + [seq1[i] + seq2[i]];\n      i := i + 1;\n    }\n  }\n  \n  method {:axiom} ComputeUpdate(residual: seq<real>, previousData: seq<real>) returns (result: seq<real>)\n    requires |residual| == |previousData|\n    ensures |result| == |residual|\n}", "name": "py2dfy_308", "id": 308}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Coordinate {\n  var lat: real\n  var lon: real\n  \n  constructor(lat: real, lon: real)\n  {\n    this.lat := lat;\n    this.lon := lon;\n  }\n}\nclass BoundingBox {\n  var minLon: real\n  var maxLon: real\n  var minLat: real\n  var maxLat: real\n  \n  constructor(minLon: real, maxLon: real, minLat: real, maxLat: real)\n  {\n    this.minLon := minLon;\n    this.maxLon := maxLon;\n    this.minLat := minLat;\n    this.maxLat := maxLat;\n  }\n  method Buffer(amount: real) returns (newBox: BoundingBox)\n  {\n    newBox := new BoundingBox(\n      minLon - amount,\n      maxLon + amount,\n      minLat - amount,\n      maxLat + amount\n    );\n  }\n}\nclass Event {}\nclass Simulation {\n  var name: string\n  var bbox: BoundingBox?\n  var numAgents: nat\n  var events: seq<Event>\n  \n  constructor(name: string, bbox: BoundingBox?)\n  {\n    this.name := name;\n    this.bbox := bbox;\n    this.numAgents := 0;\n    this.events := [];\n  }\n  method SetNumAgents(n: nat)\n  {\n    numAgents := n;\n  }\n  method InitializeDestinations()\n  {\n    \n  }\n  method InitializeScenario(scenarioType: string)\n  {\n    \n  }\n  method LoadEvents() returns (success: bool)\n  {\n    events := [];\n    success := false;\n  }\n}\nclass Viewer {\n  var sim: Simulation?\n  var bbox: BoundingBox?\n  var isVideo: bool\n  \n  constructor(sim: Simulation?, bbox: BoundingBox?, isVideo: bool)\n  {\n    this.sim := sim;\n    this.bbox := bbox;\n    this.isVideo := isVideo;\n  }\n  method RenderPath(pathType: string)\n  {\n    \n  }\n}", "output": "class Coordinate {\n  var lat: real\n  var lon: real\n  \n  constructor(lat: real, lon: real)\n    requires -90.0 <= lat <= 90.0\n    requires -180.0 <= lon <= 180.0\n    ensures this.lat == lat && this.lon == lon\n  {\n    this.lat := lat;\n    this.lon := lon;\n  }\n}\nclass BoundingBox {\n  var minLon: real\n  var maxLon: real\n  var minLat: real\n  var maxLat: real\n  \n  constructor(minLon: real, maxLon: real, minLat: real, maxLat: real)\n    requires minLon <= maxLon\n    requires minLat <= maxLat\n    requires -180.0 <= minLon <= 180.0\n    requires -180.0 <= maxLon <= 180.0\n    requires -90.0 <= minLat <= 90.0\n    requires -90.0 <= maxLat <= 90.0\n    ensures this.minLon == minLon && this.maxLon == maxLon\n    ensures this.minLat == minLat && this.maxLat == maxLat\n  {\n    this.minLon := minLon;\n    this.maxLon := maxLon;\n    this.minLat := minLat;\n    this.maxLat := maxLat;\n  }\n  method Buffer(amount: real) returns (newBox: BoundingBox)\n    requires amount >= 0.0\n    requires minLon - amount >= -180.0 && maxLon + amount <= 180.0\n    requires minLat - amount >= -90.0 && maxLat + amount <= 90.0\n    requires minLon <= maxLon \n    requires minLat <= maxLat \n    ensures newBox.minLon == minLon - amount\n    ensures newBox.maxLon == maxLon + amount\n    ensures newBox.minLat == minLat - amount\n    ensures newBox.maxLat == maxLat + amount\n  {\n    newBox := new BoundingBox(\n      minLon - amount,\n      maxLon + amount,\n      minLat - amount,\n      maxLat + amount\n    );\n  }\n}\nclass Event {}\nclass Simulation {\n  var name: string\n  var bbox: BoundingBox?\n  var numAgents: nat\n  var events: seq<Event>\n  \n  constructor(name: string, bbox: BoundingBox?)\n    requires bbox != null\n    ensures this.name == name\n    ensures this.bbox == bbox\n    ensures this.numAgents == 0\n    ensures |this.events| == 0\n  {\n    this.name := name;\n    this.bbox := bbox;\n    this.numAgents := 0;\n    this.events := [];\n  }\n  method SetNumAgents(n: nat)\n    modifies this\n    ensures numAgents == n\n  {\n    numAgents := n;\n  }\n  method InitializeDestinations()\n    modifies this\n    ensures old(numAgents) == numAgents\n  {\n    \n  }\n  method InitializeScenario(scenarioType: string)\n    requires scenarioType == \"ia\"\n    modifies this\n    ensures old(numAgents) == numAgents\n  {\n    \n  }\n  method LoadEvents() returns (success: bool)\n    modifies this\n    ensures success ==> |events| > 0\n    ensures !success ==> |events| == 0\n  {\n    events := [];\n    success := false;\n  }\n}\nclass Viewer {\n  var sim: Simulation?\n  var bbox: BoundingBox?\n  var isVideo: bool\n  \n  constructor(sim: Simulation?, bbox: BoundingBox?, isVideo: bool)\n    requires sim != null && bbox != null\n    ensures this.sim == sim\n    ensures this.bbox == bbox\n    ensures this.isVideo == isVideo\n  {\n    this.sim := sim;\n    this.bbox := bbox;\n    this.isVideo := isVideo;\n  }\n  method RenderPath(pathType: string)\n    requires pathType == \"speed\"\n    requires sim != null\n    requires bbox != null\n  {\n    \n  }\n}", "name": "py2dfy_305", "id": 305}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Print(s: string)\n{\n  \n  \n}\nmethod ReadLine() returns (result: string)\n{\n  \n  \n  result := \"\";  \n}\nmethod Greeting()\n  \n{\n  \n  Print(\"我的第一隻Python程式\");\n  \n  \n  Print(\"what is your name\");\n  var name := ReadLine();\n  \n  \n  var greeting := \"hi,\" + name + \".\";\n  Print(greeting);\n}\nmethod Main()\n{\n  Greeting();\n}", "output": "method Print(s: string)\n{\n  \n  \n}\nmethod ReadLine() returns (result: string)\n  ensures |result| >= 0  \n{\n  \n  \n  result := \"\";  \n}\nmethod Greeting()\n  \n  ensures true  \n{\n  \n  Print(\"我的第一隻Python程式\");\n  \n  \n  Print(\"what is your name\");\n  var name := ReadLine();\n  \n  \n  var greeting := \"hi,\" + name + \".\";\n  Print(greeting);\n}\nmethod Main()\n{\n  Greeting();\n}", "name": "py2dfy_311", "id": 311}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type MyArray = array<int>\ntype MyMatrix = m: array2<int> | m.Length0 == m.Length1 witness *\nclass State\n{  \n  var arr: MyArray\n  var m: MyMatrix\n  var count: nat\n  constructor () {\n    arr, m := new int[100], new int[100, 100];\n  }\n  method Process(i: nat)\n  {\n    \n    arr[i], m[i, i], count := 0, 0, 0;\n  }\n}", "output": "type MyArray = array<int>\ntype MyMatrix = m: array2<int> | m.Length0 == m.Length1 witness *\nclass State\n{  \n  var arr: MyArray\n  var m: MyMatrix\n  var count: nat\n  constructor () {\n    arr, m := new int[100], new int[100, 100];\n  }\n  method Process(i: nat)\n    requires i < arr.Length < m.Length0\n    modifies this, arr, m\n  {\n    \n    arr[i], m[i, i], count := 0, 0, 0;\n  }\n}", "name": "py2dfy_309", "id": 309}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main()\n{\n    WriteMessage(\"hi\");\n}\nmethod WriteMessage(message: string)\n{\n    print message;\n}\nmethod {:main} Run()\n{\n    Main();\n}", "output": "method Main()\n{\n    WriteMessage(\"hi\");\n}\nmethod WriteMessage(message: string)\n    requires message != \"\"\n    ensures true  \n{\n    print message;\n}\nmethod {:main} Run()\n{\n    Main();\n}", "name": "py2dfy_327", "id": 327}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class MesCode {\n  static const success: int := 0\n  static const fail: int := 1\n}\ntrait HttpBasicHandler {\n  method send_response_data(code: int, data: map<string, int>, message: string)\n  \n}\nclass SimulatorHandler extends HttpBasicHandler {\n  method send_response_data(code: int, data: map<string, int>, message: string) {\n    \n  }\n  method SetInit(product_line: string) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method SendResetFlag(product_line: string) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method ChangeStatus(product_line: string, process_code_list: seq<string>, status: string) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method SendChangeFlag(product_line: string, process_code_list: seq<string>, status: string) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method CountStart(process_code_list: seq<string>) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method SetHandler(product_line: string) returns (response_code: int, response_data: map<string, int>, response_message: string)\n  {\n    var init_success := SetInit(product_line);\n    var reset_success := SendResetFlag(product_line);\n    if init_success && reset_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to initialize or reset\";\n    }\n  }\n  method ChangeStatusHandler(product_line: string, process_code_list: seq<string>, status: string) returns (response_code: int, response_data: map<string, int>, response_message: string)\n  {\n    var change_success := ChangeStatus(product_line, process_code_list, status);\n    var flag_success := SendChangeFlag(product_line, process_code_list, status);\n    if change_success && flag_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to change status or send flag\";\n    }\n  }\n  method CountHandler(product_line: string, process_code_list: seq<string>) returns (response_code: int, response_data: map<string, int>, response_message: string)\n  {\n    var count_success := CountStart(process_code_list);\n    if count_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to start count\";\n    }\n  }\n}", "output": "class MesCode {\n  static const success: int := 0\n  static const fail: int := 1\n}\ntrait HttpBasicHandler {\n  method send_response_data(code: int, data: map<string, int>, message: string)\n  \n}\nclass SimulatorHandler extends HttpBasicHandler {\n  method send_response_data(code: int, data: map<string, int>, message: string) {\n    \n  }\n  method SetInit(product_line: string) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  method SendResetFlag(product_line: string) returns (success: bool)\n    requires product_line != \"\"\n  {\n    \n    success := true;\n  }\n  method ChangeStatus(product_line: string, process_code_list: seq<string>, status: string) returns (success: bool)\n    requires product_line != \"\"\n    requires |process_code_list| > 0\n    requires status in {\"active\", \"inactive\"}\n  {\n    \n    success := true;\n  }\n  method SendChangeFlag(product_line: string, process_code_list: seq<string>, status: string) returns (success: bool)\n    requires product_line != \"\"\n    requires |process_code_list| > 0\n    requires status in {\"active\", \"inactive\"}\n  {\n    \n    success := true;\n  }\n  method CountStart(process_code_list: seq<string>) returns (success: bool)\n    requires |process_code_list| > 0\n  {\n    \n    success := true;\n  }\n  method SetHandler(product_line: string) returns (response_code: int, response_data: map<string, int>, response_message: string)\n    requires product_line != \"\"\n    ensures response_code == MesCode.success ==> response_data == map[]\n    ensures response_code == MesCode.fail ==> response_data == map[]\n  {\n    var init_success := SetInit(product_line);\n    var reset_success := SendResetFlag(product_line);\n    if init_success && reset_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to initialize or reset\";\n    }\n  }\n  method ChangeStatusHandler(product_line: string, process_code_list: seq<string>, status: string) returns (response_code: int, response_data: map<string, int>, response_message: string)\n    requires product_line != \"\"\n    requires |process_code_list| > 0\n    requires status in {\"active\", \"inactive\"}\n    ensures response_code == MesCode.success ==> response_data == map[]\n    ensures response_code == MesCode.fail ==> response_data == map[]\n  {\n    var change_success := ChangeStatus(product_line, process_code_list, status);\n    var flag_success := SendChangeFlag(product_line, process_code_list, status);\n    if change_success && flag_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to change status or send flag\";\n    }\n  }\n  method CountHandler(product_line: string, process_code_list: seq<string>) returns (response_code: int, response_data: map<string, int>, response_message: string)\n    requires product_line != \"\"\n    requires |process_code_list| > 0\n    ensures response_code == MesCode.success ==> response_data == map[]\n    ensures response_code == MesCode.fail ==> response_data == map[]\n  {\n    var count_success := CountStart(process_code_list);\n    if count_success {\n      response_code := MesCode.success;\n      response_data := map[];\n      response_message := \"success get data\";\n    } else {\n      response_code := MesCode.fail;\n      response_data := map[];\n      response_message := \"Failed to start count\";\n    }\n  }\n}", "name": "py2dfy_341", "id": 341}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = None | Some(value: T)\ndatatype Tag = Tag(key: string, value: string)\nclass Dashboard {\n  \n  var dashboardArn: string\n  var dashboardDefinition: string  \n  var dashboardDescription: string\n  var dashboardId: string\n  var dashboardName: string\n  var projectId: Option<string>\n  var tags: seq<Tag>\n  \n  predicate Valid()\n  {\n    |dashboardDefinition| > 0 && \n    |dashboardDescription| > 0 &&\n    |dashboardName| >= 0 &&\n    (projectId.Some? ==> |projectId.value| > 0) &&\n    |dashboardArn| > 0\n  }\n  \n  constructor(\n    definition: string, \n    description: string, \n    name: Option<string>, \n    project: Option<string>, \n    tagList: seq<Tag>)\n  {\n    dashboardDefinition := definition;\n    dashboardDescription := description;\n    dashboardName := if name.Some? then name.value else \"\";\n    projectId := project;\n    tags := tagList;\n    dashboardArn := \"arn:aws:iotsitewise:dashboard\";  \n    dashboardId := \"\";   \n  }\n  \n  method UpdateDashboard(\n    definition: string, \n    description: string, \n    name: Option<string>)\n  {\n    dashboardDefinition := definition;\n    dashboardDescription := description;\n    if name.Some? {\n      dashboardName := name.value;\n    }\n  }\n  \n  method AddTags(newTags: seq<Tag>)\n  {\n    tags := tags + newTags;\n  }\n  \n  method GetDashboardArn() returns (arn: string)\n  {\n    return dashboardArn;\n  }\n}", "output": "datatype Option<T> = None | Some(value: T)\ndatatype Tag = Tag(key: string, value: string)\nclass Dashboard {\n  \n  var dashboardArn: string\n  var dashboardDefinition: string  \n  var dashboardDescription: string\n  var dashboardId: string\n  var dashboardName: string\n  var projectId: Option<string>\n  var tags: seq<Tag>\n  \n  predicate Valid()\n    reads this\n  {\n    |dashboardDefinition| > 0 && \n    |dashboardDescription| > 0 &&\n    |dashboardName| >= 0 &&\n    (projectId.Some? ==> |projectId.value| > 0) &&\n    |dashboardArn| > 0\n  }\n  \n  constructor(\n    definition: string, \n    description: string, \n    name: Option<string>, \n    project: Option<string>, \n    tagList: seq<Tag>)\n    requires |definition| > 0\n    requires |description| > 0\n    requires name.Some? ==> |name.value| > 0\n    requires project.Some? ==> |project.value| > 0\n    ensures Valid()\n    ensures dashboardDefinition == definition\n    ensures dashboardDescription == description\n    ensures name.Some? ==> dashboardName == name.value\n    ensures projectId == project\n    ensures tags == tagList\n  {\n    dashboardDefinition := definition;\n    dashboardDescription := description;\n    dashboardName := if name.Some? then name.value else \"\";\n    projectId := project;\n    tags := tagList;\n    dashboardArn := \"arn:aws:iotsitewise:dashboard\";  \n    dashboardId := \"\";   \n  }\n  \n  method UpdateDashboard(\n    definition: string, \n    description: string, \n    name: Option<string>)\n    requires |definition| > 0\n    requires |description| > 0\n    requires name.Some? ==> |name.value| > 0\n    requires Valid()\n    modifies this\n    ensures dashboardDefinition == definition\n    ensures dashboardDescription == description\n    ensures name.Some? ==> dashboardName == name.value\n    ensures Valid()\n  {\n    dashboardDefinition := definition;\n    dashboardDescription := description;\n    if name.Some? {\n      dashboardName := name.value;\n    }\n  }\n  \n  method AddTags(newTags: seq<Tag>)\n    requires Valid() \n    modifies this\n    ensures tags == old(tags) + newTags\n    ensures Valid()\n  {\n    tags := tags + newTags;\n  }\n  \n  method GetDashboardArn() returns (arn: string)\n    requires Valid()\n    ensures |arn| > 0\n    ensures arn == dashboardArn\n  {\n    return dashboardArn;\n  }\n}", "name": "py2dfy_313", "id": 313}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class MonteCarloPI {\n    function RandomDouble(): real\n    {\n      0.5\n    }\n    method SingleIteration() returns (inCircle: bool)\n    {\n      var x := RandomDouble();\n      var y := RandomDouble();\n      inCircle := x * x + y * y < 1.0;\n    }\n    method CalculatePI(n: nat) returns (pi: real)\n    {\n      var circleCount := 0;\n      var i := 0;\n      while i < n\n      {\n        var isInCircle := SingleIteration();\n        if isInCircle {\n          circleCount := circleCount + 1;\n        }\n        i := i + 1;\n      }\n      pi := (circleCount as real / n as real) * 4.0;\n    }\n    method RunSimulation(batchSize: nat) decreases *\n    {\n      var iterations := 0;\n      \n      while true\n      {\n        var approx := CalculatePI(batchSize);\n        iterations := iterations + batchSize;\n        print \"Iterations: \", iterations, \" π ≈ \", approx, \"\\n\";\n      }\n    }\n}", "output": "class MonteCarloPI {\n    function RandomDouble(): real\n      ensures 0.0 <= RandomDouble() < 1.0\n    {\n      0.5\n    }\n    method SingleIteration() returns (inCircle: bool)\n      ensures true\n    {\n      var x := RandomDouble();\n      var y := RandomDouble();\n      inCircle := x * x + y * y < 1.0;\n    }\n    method CalculatePI(n: nat) returns (pi: real)\n      requires n > 0\n      ensures 0.0 <= pi <= 4.0\n    {\n      var circleCount := 0;\n      var i := 0;\n      while i < n\n        invariant 0 <= i <= n\n        invariant 0 <= circleCount <= i\n      {\n        var isInCircle := SingleIteration();\n        if isInCircle {\n          circleCount := circleCount + 1;\n        }\n        i := i + 1;\n      }\n      pi := (circleCount as real / n as real) * 4.0;\n    }\n    method RunSimulation(batchSize: nat) decreases *\n      requires batchSize > 0\n    {\n      var iterations := 0;\n      \n      while true\n        decreases *\n      {\n        var approx := CalculatePI(batchSize);\n        iterations := iterations + batchSize;\n        print \"Iterations: \", iterations, \" π ≈ \", approx, \"\\n\";\n      }\n    }\n}", "name": "py2dfy_301", "id": 301}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Maximum(values: seq<int>) returns (max: int)\n{\n  max := values[0];\n  var idx := 0;\n  while (idx < |values|)\n  {\n    if (values[idx] > max) {\n      max := values[idx];\n    }\n    idx := idx + 1;\n  }\n}", "output": "method Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n{\n  max := values[0];\n  var idx := 0;\n  while (idx < |values|)\n    invariant max in values\n    invariant idx <= |values|\n    invariant forall j | 0 <= j < idx :: values[j] <= max\n  {\n    if (values[idx] > max) {\n      max := values[idx];\n    }\n    idx := idx + 1;\n  }\n}", "name": "py2dfy_336", "id": 336}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module LogicalOperationsDemo {\n    \n    method BasicComparisons() \n        \n    {\n        \n        print \"Is 5 less than 3? \", 5 < 3, \"\\n\";\n        print \"Is 5 greater than 3? \", 5 > 3, \"\\n\";\n        print \"Is 5 greater than or equal to 3? \", 5 >= 3, \"\\n\";\n        print \"Is 5 greater than 5? \", 5 > 5, \"\\n\";\n        print \"Is 5 greater than or equal to 5? \", 5 >= 5, \"\\n\";\n        print \"Is 5 equal to 5? \", 5 == 5, \"\\n\";\n        print \"Is 5 equal to 3? \", 5 == 3, \"\\n\";\n        print \"Is 5 not equal to 3? \", 5 != 3, \"\\n\";\n    }\n    \n    method BooleanOperations()\n    {\n        var a := true;\n        var b := false;\n        \n        print \"a is \", a, \"\\n\";\n        print \"b is \", b, \"\\n\";\n        \n        \n        print \"a and a: \", a && a, \"\\n\";\n        print \"a and b: \", a && b, \"\\n\";\n        print \"b and b: \", b && b, \"\\n\";\n        \n        \n        print \"a or a: \", a || a, \"\\n\";\n        print \"a or b: \", a || b, \"\\n\";\n        print \"b or b: \", b || b, \"\\n\";\n        \n        \n        print \"not (a or b): \", !(a || b), \"\\n\";\n        print \"not (b or b): \", !(b || b), \"\\n\";\n    }\n    \n    method ControlFlow()\n    {\n        var a := true;\n        var b := false;\n        \n        if a {\n            print \"Hello!\\n\";\n        } else {\n            print \"Goodbye!\\n\";\n        }\n        \n        if b {\n            print \"Hello!\\n\";\n        } else {\n            print \"Goodbye!\\n\";\n        }\n    }\n    \n    method CategorizeNumber(data: int) returns (category: string)\n    {\n        if data > 10 {\n            category := \"Too big!\";\n        } else if data > 7 {\n            category := \"Just right!\";\n        } else if data > 3 {\n            category := \"Almost!\";\n        } else {\n            category := \"Too small!\";\n        }\n    }\n    \n    method Main()\n    {\n        BasicComparisons();\n        print \"\\n~~~ Now joining statements together ~~~\\n\\n\";\n        BooleanOperations();\n        print \"\\n~~~ Now demonstrating if-else ~~~\\n\\n\";\n        ControlFlow();\n        \n        print \"\\n~~~ Now let's look at more practical use of if-else ~~~\\n\\n\";\n        var data := 3;\n        print \"Data is: \", data, \"\\n\";\n        var result := CategorizeNumber(data);\n        print result, \"\\n\";\n    }\n}", "output": "module LogicalOperationsDemo {\n    \n    method BasicComparisons() \n        \n        ensures true  \n    {\n        \n        print \"Is 5 less than 3? \", 5 < 3, \"\\n\";\n        print \"Is 5 greater than 3? \", 5 > 3, \"\\n\";\n        print \"Is 5 greater than or equal to 3? \", 5 >= 3, \"\\n\";\n        print \"Is 5 greater than 5? \", 5 > 5, \"\\n\";\n        print \"Is 5 greater than or equal to 5? \", 5 >= 5, \"\\n\";\n        print \"Is 5 equal to 5? \", 5 == 5, \"\\n\";\n        print \"Is 5 equal to 3? \", 5 == 3, \"\\n\";\n        print \"Is 5 not equal to 3? \", 5 != 3, \"\\n\";\n    }\n    \n    method BooleanOperations()\n        ensures true  \n    {\n        var a := true;\n        var b := false;\n        \n        print \"a is \", a, \"\\n\";\n        print \"b is \", b, \"\\n\";\n        \n        \n        print \"a and a: \", a && a, \"\\n\";\n        print \"a and b: \", a && b, \"\\n\";\n        print \"b and b: \", b && b, \"\\n\";\n        \n        \n        print \"a or a: \", a || a, \"\\n\";\n        print \"a or b: \", a || b, \"\\n\";\n        print \"b or b: \", b || b, \"\\n\";\n        \n        \n        print \"not (a or b): \", !(a || b), \"\\n\";\n        print \"not (b or b): \", !(b || b), \"\\n\";\n    }\n    \n    method ControlFlow()\n        ensures true  \n    {\n        var a := true;\n        var b := false;\n        \n        if a {\n            print \"Hello!\\n\";\n        } else {\n            print \"Goodbye!\\n\";\n        }\n        \n        if b {\n            print \"Hello!\\n\";\n        } else {\n            print \"Goodbye!\\n\";\n        }\n    }\n    \n    method CategorizeNumber(data: int) returns (category: string)\n        ensures category in {\"Too big!\", \"Just right!\", \"Almost!\", \"Too small!\"}\n        ensures data > 10 ==> category == \"Too big!\"\n        ensures (data <= 10 && data > 7) ==> category == \"Just right!\"\n        ensures (data <= 7 && data > 3) ==> category == \"Almost!\"\n        ensures data <= 3 ==> category == \"Too small!\"\n    {\n        if data > 10 {\n            category := \"Too big!\";\n        } else if data > 7 {\n            category := \"Just right!\";\n        } else if data > 3 {\n            category := \"Almost!\";\n        } else {\n            category := \"Too small!\";\n        }\n    }\n    \n    method Main()\n    {\n        BasicComparisons();\n        print \"\\n~~~ Now joining statements together ~~~\\n\\n\";\n        BooleanOperations();\n        print \"\\n~~~ Now demonstrating if-else ~~~\\n\\n\";\n        ControlFlow();\n        \n        print \"\\n~~~ Now let's look at more practical use of if-else ~~~\\n\\n\";\n        var data := 3;\n        print \"Data is: \", data, \"\\n\";\n        var result := CategorizeNumber(data);\n        print result, \"\\n\";\n    }\n}", "name": "py2dfy_345", "id": 345}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Date = Date(year: int, month: int)\ndatatype Account = Account(\n  pesel: string,\n  firstName: string,\n  lastName: string,\n  income: real,\n  baseCurrency: string\n)\ndatatype CreditParameters = CreditParameters(\n  currency: string,\n  cost: real,\n  startDate: Date,\n  endDate: Date\n)\nconst VALID_CURRENCIES: seq<string> := [\"PLN\", \"USD\", \"EUR\", \"CHF\", \"GBP\"]\npredicate IsValidDate(d: Date)\n{\n  && d.month >= 1 \n  && d.month <= 12\n  && d.year >= 1900  \n  && d.year <= 2100  \n}\npredicate IsValidCurrency(currency: string)\n{\n  exists i :: 0 <= i < |VALID_CURRENCIES| && VALID_CURRENCIES[i] == currency\n}\npredicate IsValidPesel(pesel: string)\n{\n  |pesel| == 11 && forall i :: 0 <= i < |pesel| ==> '0' <= pesel[i] <= '9'\n}\ndatatype Option<T> = Some(value: T) | None\nclass BankSystem {\n  \n  var accounts: map<string, Account>\n  \n  constructor()\n  {\n    accounts := map[];\n  }\n  method CreateAccount(acc: Account) returns (response: bool)\n  {\n    if acc.pesel in accounts {\n      return false;\n    }\n    accounts := accounts[acc.pesel := acc];\n    return true;\n  }\n  method GetAccountDetails(pesel: string) returns (acc: Option<Account>)\n  {\n    if pesel in accounts {\n      return Some(accounts[pesel]);\n    }\n    return None;\n  }\n  method GetCreditCosts(pesel: string, params: CreditParameters) returns (cost: real)\n          (params.endDate.year == params.startDate.year && \n           params.endDate.month >= params.startDate.month)\n  {\n    \n    var account := accounts[pesel];\n    var monthDiff := (params.endDate.year - params.startDate.year) * 12 +\n                     params.endDate.month - params.startDate.month;\n    \n    \n    var interestRate := if account.income > 5000.0 then 0.05 else 0.08;\n    \n    \n    \n    var multiplier := 1.0 + interestRate * (monthDiff as real / 12.0);\n    \n    \n    cost := params.cost * multiplier;\n  }\n}", "output": "datatype Date = Date(year: int, month: int)\ndatatype Account = Account(\n  pesel: string,\n  firstName: string,\n  lastName: string,\n  income: real,\n  baseCurrency: string\n)\ndatatype CreditParameters = CreditParameters(\n  currency: string,\n  cost: real,\n  startDate: Date,\n  endDate: Date\n)\nconst VALID_CURRENCIES: seq<string> := [\"PLN\", \"USD\", \"EUR\", \"CHF\", \"GBP\"]\npredicate IsValidDate(d: Date)\n{\n  && d.month >= 1 \n  && d.month <= 12\n  && d.year >= 1900  \n  && d.year <= 2100  \n}\npredicate IsValidCurrency(currency: string)\n{\n  exists i :: 0 <= i < |VALID_CURRENCIES| && VALID_CURRENCIES[i] == currency\n}\npredicate IsValidPesel(pesel: string)\n{\n  |pesel| == 11 && forall i :: 0 <= i < |pesel| ==> '0' <= pesel[i] <= '9'\n}\ndatatype Option<T> = Some(value: T) | None\nclass BankSystem {\n  \n  var accounts: map<string, Account>\n  \n  constructor()\n  ensures fresh(this)\n  ensures accounts == map[]\n  {\n    accounts := map[];\n  }\n  method CreateAccount(acc: Account) returns (response: bool)\n  requires IsValidPesel(acc.pesel)\n  requires IsValidCurrency(acc.baseCurrency)\n  requires acc.income >= 0.0\n  modifies this\n  ensures acc.pesel !in old(accounts) ==> accounts == old(accounts)[acc.pesel := acc]\n  ensures acc.pesel in old(accounts) ==> accounts == old(accounts)\n  ensures response <==> (acc.pesel !in old(accounts))\n  {\n    if acc.pesel in accounts {\n      return false;\n    }\n    accounts := accounts[acc.pesel := acc];\n    return true;\n  }\n  method GetAccountDetails(pesel: string) returns (acc: Option<Account>)\n  requires IsValidPesel(pesel)\n  ensures acc.Some? ==> pesel in accounts && acc.value == accounts[pesel]\n  ensures acc.None? ==> pesel !in accounts\n  {\n    if pesel in accounts {\n      return Some(accounts[pesel]);\n    }\n    return None;\n  }\n  method GetCreditCosts(pesel: string, params: CreditParameters) returns (cost: real)\n  requires IsValidPesel(pesel)\n  requires IsValidCurrency(params.currency)\n  requires params.cost >= 0.0\n  requires IsValidDate(params.startDate)\n  requires IsValidDate(params.endDate)\n  requires params.endDate.year > params.startDate.year || \n          (params.endDate.year == params.startDate.year && \n           params.endDate.month >= params.startDate.month)\n  requires pesel in accounts\n  ensures cost >= params.cost  \n  {\n    \n    var account := accounts[pesel];\n    var monthDiff := (params.endDate.year - params.startDate.year) * 12 +\n                     params.endDate.month - params.startDate.month;\n    \n    \n    var interestRate := if account.income > 5000.0 then 0.05 else 0.08;\n    \n    assert monthDiff >= 0;  \n    assert interestRate > 0.0;  \n    assert (monthDiff as real / 12.0) >= 0.0;  \n    assert interestRate * (monthDiff as real / 12.0) >= 0.0;  \n    assert 1.0 + interestRate * (monthDiff as real / 12.0) >= 1.0;  \n    assert params.cost >= 0.0;  \n    \n    \n    var multiplier := 1.0 + interestRate * (monthDiff as real / 12.0);\n    assert multiplier >= 1.0;\n    \n    \n    cost := params.cost * multiplier;\n  }\n}", "name": "py2dfy_297", "id": 297}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Feedback {\n  var fields: map<string, string>\n  \n  constructor(fields: map<string, string>)\n  {\n    this.fields := fields;\n  }\n}\nclass Database {\n  var feedbacks: seq<Feedback>\n  \n  constructor()\n  {\n    feedbacks := [];\n  }\n  \n  method Save(feedback: Feedback)\n            feedbacks[i] == old(feedbacks[i])\n  {\n    feedbacks := feedbacks + [feedback];\n  }\n}\nmethod HandleFeedbackRequest(requestBody: string, db: Database) returns (statusCode: int)\n{\n  var fields := ParseRequestBody(requestBody);\n  var feedback := new Feedback(fields);\n  db.Save(feedback);\n  return 200;\n}\nmethod ParseRequestBody(body: string) returns (result: map<string, string>)\n{\n  result := map[\"dummy\" := \"value\"];\n}", "output": "class Feedback {\n  var fields: map<string, string>\n  \n  constructor(fields: map<string, string>)\n    ensures this.fields == fields\n  {\n    this.fields := fields;\n  }\n}\nclass Database {\n  var feedbacks: seq<Feedback>\n  \n  constructor()\n    ensures |feedbacks| == 0\n  {\n    feedbacks := [];\n  }\n  \n  method Save(feedback: Feedback)\n    modifies this\n    ensures |feedbacks| == old(|feedbacks|) + 1\n    ensures feedbacks[|feedbacks|-1] == feedback\n    ensures forall i :: 0 <= i < old(|feedbacks|) ==> \n            feedbacks[i] == old(feedbacks[i])\n  {\n    feedbacks := feedbacks + [feedback];\n  }\n}\nmethod HandleFeedbackRequest(requestBody: string, db: Database) returns (statusCode: int)\n  requires requestBody != \"\"\n  modifies db\n  ensures statusCode == 200\n  ensures |db.feedbacks| == old(|db.feedbacks|) + 1\n{\n  var fields := ParseRequestBody(requestBody);\n  var feedback := new Feedback(fields);\n  db.Save(feedback);\n  return 200;\n}\nmethod ParseRequestBody(body: string) returns (result: map<string, string>)\n  requires body != \"\"\n  ensures |result| > 0\n{\n  result := map[\"dummy\" := \"value\"];\n}", "name": "py2dfy_329", "id": 329}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Footer = Footer()\ndatatype Head = Head(title: string, logoShortName: string, motivationalStatement: string)\ndatatype Topbar = Topbar(title: string, statement: string)\nclass AdminRegistry {\n  \n  var registeredModels: map<string, bool>\n  var displayConfigs: map<string, seq<string>>\n  constructor()\n  {\n    registeredModels := map[];\n    displayConfigs := map[];\n  }\n  \n  method RegisterModel(modelName: string)\n  {\n    registeredModels := registeredModels[modelName := true];\n  }\n  \n  method RegisterModelWithConfig(modelName: string, displayFields: seq<string>)\n  {\n    registeredModels := registeredModels[modelName := true];\n    displayConfigs := displayConfigs[modelName := displayFields];\n  }\n  \n  method IsModelRegistered(modelName: string) returns (registered: bool)\n  {\n    registered := modelName in registeredModels;\n  }\n}\nmethod Main()\n{\n  var registry := new AdminRegistry();\n  \n  \n  registry.RegisterModel(\"Footer\");\n  \n  \n  var headDisplayFields := [\"title\", \"logo_short_name\", \"motivational_statement\"];\n  registry.RegisterModelWithConfig(\"Head\", headDisplayFields);\n  \n  \n  var topbarDisplayFields := [\"title\", \"statement\"];\n  registry.RegisterModelWithConfig(\"Topbar\", topbarDisplayFields);\n}", "output": "datatype Footer = Footer()\ndatatype Head = Head(title: string, logoShortName: string, motivationalStatement: string)\ndatatype Topbar = Topbar(title: string, statement: string)\nclass AdminRegistry {\n  \n  var registeredModels: map<string, bool>\n  var displayConfigs: map<string, seq<string>>\n  constructor()\n    ensures fresh(this)\n    ensures registeredModels == map[]\n    ensures displayConfigs == map[]\n  {\n    registeredModels := map[];\n    displayConfigs := map[];\n  }\n  \n  method RegisterModel(modelName: string)\n    modifies this\n    requires modelName != \"\"\n    ensures modelName in registeredModels\n    ensures registeredModels[modelName] == true\n    ensures displayConfigs == old(displayConfigs)\n  {\n    registeredModels := registeredModels[modelName := true];\n  }\n  \n  method RegisterModelWithConfig(modelName: string, displayFields: seq<string>)\n    modifies this\n    requires modelName != \"\"\n    requires |displayFields| > 0\n    ensures modelName in registeredModels\n    ensures modelName in displayConfigs\n    ensures registeredModels[modelName] == true\n    ensures displayConfigs[modelName] == displayFields\n  {\n    registeredModels := registeredModels[modelName := true];\n    displayConfigs := displayConfigs[modelName := displayFields];\n  }\n  \n  method IsModelRegistered(modelName: string) returns (registered: bool)\n    requires modelName != \"\"\n    ensures registered <==> modelName in registeredModels\n  {\n    registered := modelName in registeredModels;\n  }\n}\nmethod Main()\n{\n  var registry := new AdminRegistry();\n  \n  \n  registry.RegisterModel(\"Footer\");\n  \n  \n  var headDisplayFields := [\"title\", \"logo_short_name\", \"motivational_statement\"];\n  registry.RegisterModelWithConfig(\"Head\", headDisplayFields);\n  \n  \n  var topbarDisplayFields := [\"title\", \"statement\"];\n  registry.RegisterModelWithConfig(\"Topbar\", topbarDisplayFields);\n}", "name": "py2dfy_317", "id": 317}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype DivisionResult = Success(value: real) | Error\nmethod divide(n: real, d: real) returns (result: DivisionResult)\n  \n{\n  if d == 0.0 {\n    return Error;\n  }\n  \n  var computation := (n/d) * 100.0;\n  return Success(computation);\n}\nmethod formatResult(dr: DivisionResult) returns (result: string)\n{\n  match dr {\n    case Error => return \"None\";\n    case Success(v) => \n      \n      \n      return \"formatted_number\";  \n  }\n}", "output": "datatype DivisionResult = Success(value: real) | Error\nmethod divide(n: real, d: real) returns (result: DivisionResult)\n  \n  ensures d == 0.0 ==> result.Error?  \n  ensures d != 0.0 ==> result.Success? && result.value == (n/d) * 100.0  \n{\n  if d == 0.0 {\n    return Error;\n  }\n  \n  var computation := (n/d) * 100.0;\n  return Success(computation);\n}\nmethod formatResult(dr: DivisionResult) returns (result: string)\n  ensures dr.Error? ==> result == \"None\"\n  ensures dr.Success? ==> |result| > 0  \n{\n  match dr {\n    case Error => return \"None\";\n    case Success(v) => \n      \n      \n      return \"formatted_number\";  \n  }\n}", "name": "py2dfy_354", "id": 354}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype JsonResponse = \n  | Success(result: seq<char>)\n  | Error(code: int, message: seq<char>)\nclass Response {\n  var ok: bool\n  var body: seq<char>\n  \n  constructor(isOk: bool, responseBody: seq<char>)\n  {\n    ok := isOk;\n    body := responseBody;\n  }\n}\nclass VolttronWebRPC {\n  var url: seq<char>\n  var username: seq<char>\n  var password: seq<char>\n  var authToken: seq<char>\n  constructor(serverUrl: seq<char>, user: seq<char> := \"admin\", pass: seq<char> := \"admin\")\n  {\n    url := serverUrl;\n    username := user;\n    password := pass;\n    authToken := \"\";\n  }\n  \n  method InitAuth()\n  {\n    var token := GetAuthToken();\n    authToken := token;\n  }\n  \n  method DoRPC(rpcMethod: seq<char>, rpcParams: map<seq<char>, seq<char>>) returns (result: JsonResponse)\n  {\n    \n    var response := SimulateHttpRequest(rpcMethod, rpcParams);\n    \n    if !response.ok {\n      return Error(-1, \"Request failed\");\n    }\n    \n    return Success(response.body);\n  }\n  \n  method GetAuthToken() returns (token: seq<char>)\n  {\n    var params := map[\"username\" := username, \"password\" := password];\n    \n    var response := SimulateHttpRequest(\"get_authorization\", params);\n    \n    if response.ok {\n      return response.body;\n    }\n    return \"invalid_token\";\n  }\n  \n  method RegisterInstance(addr: seq<char>, name: seq<char>) returns (result: JsonResponse)\n  {\n    var params := map[\"discovery_address\" := addr, \"display_name\" := name];\n    var rpcResult := DoRPC(\"register_instance\", params);\n    return rpcResult;\n  }\n  \n  method SimulateHttpRequest(rpcMethod: seq<char>, rpcParams: map<seq<char>, seq<char>>) returns (response: Response)\n  {\n    \n    return new Response(true, \"simulated_response\");\n  }\n  \n  method ValidateResponse(response: Response) returns (valid: bool)\n  {\n    if |response.body| == 0 {\n      return false;\n    }\n    \n    return true;\n  }\n}", "output": "datatype JsonResponse = \n  | Success(result: seq<char>)\n  | Error(code: int, message: seq<char>)\nclass Response {\n  var ok: bool\n  var body: seq<char>\n  \n  constructor(isOk: bool, responseBody: seq<char>)\n    ensures ok == isOk && body == responseBody\n  {\n    ok := isOk;\n    body := responseBody;\n  }\n}\nclass VolttronWebRPC {\n  var url: seq<char>\n  var username: seq<char>\n  var password: seq<char>\n  var authToken: seq<char>\n  constructor(serverUrl: seq<char>, user: seq<char> := \"admin\", pass: seq<char> := \"admin\")\n    requires |serverUrl| > 0  \n    ensures url == serverUrl && username == user && password == pass\n  {\n    url := serverUrl;\n    username := user;\n    password := pass;\n    authToken := \"\";\n  }\n  \n  method InitAuth()\n    modifies this\n    requires |url| > 0 && |username| > 0 && |password| > 0\n    ensures |authToken| > 0\n  {\n    var token := GetAuthToken();\n    authToken := token;\n  }\n  \n  method DoRPC(rpcMethod: seq<char>, rpcParams: map<seq<char>, seq<char>>) returns (result: JsonResponse)\n    requires |rpcMethod| > 0  \n    requires |authToken| > 0  \n    ensures result.Success? ==> |result.result| > 0  \n  {\n    \n    var response := SimulateHttpRequest(rpcMethod, rpcParams);\n    \n    if !response.ok {\n      return Error(-1, \"Request failed\");\n    }\n    \n    return Success(response.body);\n  }\n  \n  method GetAuthToken() returns (token: seq<char>)\n    requires |url| > 0 && |username| > 0 && |password| > 0\n    ensures |token| > 0  \n  {\n    var params := map[\"username\" := username, \"password\" := password];\n    \n    var response := SimulateHttpRequest(\"get_authorization\", params);\n    \n    if response.ok {\n      return response.body;\n    }\n    return \"invalid_token\";\n  }\n  \n  method RegisterInstance(addr: seq<char>, name: seq<char>) returns (result: JsonResponse)\n    requires |addr| > 0  \n    requires |authToken| > 0  \n    ensures result.Success? ==> |result.result| > 0\n  {\n    var params := map[\"discovery_address\" := addr, \"display_name\" := name];\n    var rpcResult := DoRPC(\"register_instance\", params);\n    return rpcResult;\n  }\n  \n  method SimulateHttpRequest(rpcMethod: seq<char>, rpcParams: map<seq<char>, seq<char>>) returns (response: Response)\n    requires |rpcMethod| > 0\n    ensures response.ok ==> |response.body| > 0\n  {\n    \n    return new Response(true, \"simulated_response\");\n  }\n  \n  method ValidateResponse(response: Response) returns (valid: bool)\n    requires response.ok  \n    ensures valid ==> |response.body| > 0  \n  {\n    if |response.body| == 0 {\n      return false;\n    }\n    \n    return true;\n  }\n}", "name": "py2dfy_302", "id": 302}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module TimeRecorder {\n    \n    function GetCurrentTime(): string\n    {\n        \n        \"Sun 10:00:00\"\n    }\n    method AppendToFile(filename: string, content: string) returns (success: bool)\n    {\n        \n        success := true;  \n    }\n    method RecordTimeToFile(filename: string) returns (success: bool)\n    {\n        var current_time := GetCurrentTime();\n        success := AppendToFile(filename, current_time + \"\\n\");\n    }\n    method Main()\n    {\n        var filename := \"record_time.txt\";\n        var success := RecordTimeToFile(filename);\n        if success {\n            print \"Time recorded successfully.\\n\";\n        } else {\n            print \"Failed to record time.\\n\";\n        }\n    }\n}", "output": "module TimeRecorder {\n    \n    function GetCurrentTime(): string\n    {\n        \n        \"Sun 10:00:00\"\n    }\n    method AppendToFile(filename: string, content: string) returns (success: bool)\n        requires filename != \"\"\n        ensures success ==> true  \n    {\n        \n        success := true;  \n    }\n    method RecordTimeToFile(filename: string) returns (success: bool)\n        requires filename != \"\"\n        ensures success ==> true  \n    {\n        var current_time := GetCurrentTime();\n        success := AppendToFile(filename, current_time + \"\\n\");\n    }\n    method Main()\n    {\n        var filename := \"record_time.txt\";\n        var success := RecordTimeToFile(filename);\n        if success {\n            print \"Time recorded successfully.\\n\";\n        } else {\n            print \"Failed to record time.\\n\";\n        }\n    }\n}", "name": "py2dfy_330", "id": 330}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Result = Result(result: bool)\nmethod Define() returns (r: Result)\n  \n  \n  \n{\n  \n  return Result(false);\n}", "output": "datatype Result = Result(result: bool)\nmethod Define() returns (r: Result)\n  \n  \n  \n  ensures r == Result(false)\n{\n  \n  return Result(false);\n}", "name": "py2dfy_326", "id": 326}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Image {\n  var path: string\n  var dimensions: Point\n  constructor(filepath: string, width: int, height: int)\n  {\n    path := filepath;\n    dimensions := new Point(width, height);\n  }\n}\nclass Window {\n  var isOpen: bool\n  var components: seq<Component>\n  constructor()\n  {\n    isOpen := true;\n    components := [];\n  }\n  \n  method AddComponent(c: Component?)\n  {\n    components := components + [c];\n  }\n  \n  method MainLoop()\n  {\n    isOpen := false;  \n  }\n}\ntrait Component {\n  var parent: Window?\n  var position: Point?\n}\nclass Label extends Component {\n  var image: Image?\n  \n  constructor(window: Window?, pos: Point?, img: Image?)\n  {\n    parent := window;\n    position := pos;\n    image := img;\n  }\n}\nmethod Main()\n{\n  \n  var root := new Window();\n  \n  \n  var photo := new Image(\"peace.gif\", 300, 180);\n  \n  \n  var position := new Point(0, 0);\n  var peace := new Label(root, position, photo);\n  \n  \n  root.AddComponent(peace);\n  \n  \n  root.MainLoop();\n}", "output": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n    requires x' >= 0 && y' >= 0  \n    ensures x == x' && y == y'   \n  {\n    x := x';\n    y := y';\n  }\n}\nclass Image {\n  var path: string\n  var dimensions: Point\n  constructor(filepath: string, width: int, height: int)\n    requires width >= 0 && height >= 0  \n    requires |filepath| > 0             \n    ensures path == filepath            \n    ensures dimensions.x == width && dimensions.y == height  \n  {\n    path := filepath;\n    dimensions := new Point(width, height);\n  }\n}\nclass Window {\n  var isOpen: bool\n  var components: seq<Component>\n  constructor()\n    ensures isOpen        \n    ensures |components| == 0  \n  {\n    isOpen := true;\n    components := [];\n  }\n  \n  method AddComponent(c: Component?)\n    requires c != null\n    modifies this\n    ensures |components| == old(|components|) + 1  \n    ensures components[|components|-1] == c        \n  {\n    components := components + [c];\n  }\n  \n  method MainLoop()\n    modifies this\n    ensures !isOpen  \n  {\n    isOpen := false;  \n  }\n}\ntrait Component {\n  var parent: Window?\n  var position: Point?\n}\nclass Label extends Component {\n  var image: Image?\n  \n  constructor(window: Window?, pos: Point?, img: Image?)\n    requires pos != null\n    ensures parent == window\n    ensures position == pos\n    ensures image == img\n  {\n    parent := window;\n    position := pos;\n    image := img;\n  }\n}\nmethod Main()\n{\n  \n  var root := new Window();\n  \n  \n  var photo := new Image(\"peace.gif\", 300, 180);\n  \n  \n  var position := new Point(0, 0);\n  var peace := new Label(root, position, photo);\n  \n  \n  root.AddComponent(peace);\n  \n  \n  root.MainLoop();\n}", "name": "py2dfy_358", "id": 358}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function GetInput(): string\nmethod DisplayHelp(topic: string)\nmethod ToUpper(s: string) returns (result: string)\n{\n  var chars := new char[|s|];\n  var i := 0;\n  while i < |s|\n  {\n    chars[i] := if 'a' <= s[i] <= 'z' then \n                  ((s[i] as int - 'a' as int) + 'A' as int) as char\n                else s[i];\n    i := i + 1;\n  }\n  result := chars[..];\n}\nfunction ToUpperF(s: string): string\n{\n  if |s| == 0 then \"\"\n  else\n    var c := if 'a' <= s[0] <= 'z' then \n              ((s[0] as int - 'a' as int) + 'A' as int) as char\n            else s[0];\n    [c] + ToUpperF(s[1..])\n}\nmethod HelpSystem()\n{\n  var response := \"\";\n  var choice := \"\";\n  \n  while response != \"FIM\"\n  {\n    choice := GetInput();\n    response := ToUpperF(choice);\n    \n    if response != \"FIM\" && choice != \"\" {\n      DisplayHelp(choice);\n    }\n  }\n}", "output": "function GetInput(): string\nmethod DisplayHelp(topic: string)\n  requires topic != \"\"\nmethod ToUpper(s: string) returns (result: string)\n{\n  var chars := new char[|s|];\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant chars.Length == |s| \n  {\n    chars[i] := if 'a' <= s[i] <= 'z' then \n                  ((s[i] as int - 'a' as int) + 'A' as int) as char\n                else s[i];\n    i := i + 1;\n  }\n  result := chars[..];\n}\nfunction ToUpperF(s: string): string\n{\n  if |s| == 0 then \"\"\n  else\n    var c := if 'a' <= s[0] <= 'z' then \n              ((s[0] as int - 'a' as int) + 'A' as int) as char\n            else s[0];\n    [c] + ToUpperF(s[1..])\n}\nmethod HelpSystem()\n  decreases *\n{\n  var response := \"\";\n  var choice := \"\";\n  \n  while response != \"FIM\"\n    invariant response == ToUpperF(choice)\n    decreases *\n  {\n    choice := GetInput();\n    response := ToUpperF(choice);\n    \n    if response != \"FIM\" && choice != \"\" {\n      DisplayHelp(choice);\n    }\n  }\n}", "name": "py2dfy_325", "id": 325}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method ChangedBits(s: string) returns (c: nat)\n{\n  var msg := \"SOS\";\n  c := 0;\n  \n  \n  var i := 0;\n  while i < |s|\n  {\n    \n    if msg[0] != s[i] { c := c + 1; }\n    if msg[1] != s[i+1] { c := c + 1; }\n    if msg[2] != s[i+2] { c := c + 1; }\n    \n    i := i + 3;\n  }\n}\nmethod Main() {\n  var input := \"SOSSPSSQSSOR\";\n  var result := ChangedBits(input);\n  print result, \"\\n\";\n}", "output": "method ChangedBits(s: string) returns (c: nat)\n  requires |s| > 0 && |s| % 3 == 0  \n  ensures c <= |s|  \n{\n  var msg := \"SOS\";\n  c := 0;\n  \n  \n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant i % 3 == 0  \n    invariant c <= i  \n  {\n    \n    if msg[0] != s[i] { c := c + 1; }\n    if msg[1] != s[i+1] { c := c + 1; }\n    if msg[2] != s[i+2] { c := c + 1; }\n    \n    i := i + 3;\n  }\n}\nmethod Main() {\n  var input := \"SOSSPSSQSSOR\";\n  var result := ChangedBits(input);\n  print result, \"\\n\";\n}", "name": "py2dfy_333", "id": 333}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DateTime {\n  var year: int\n  var month: int \n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  constructor(y: int, m: int, d: int, h: int, min: int, s: int)\n  {\n    year := y;\n    month := m;\n    day := d;\n    hour := h;\n    minute := min;\n    second := s;\n  }\n  method ToLocalTime() returns (local: DateTime)\n  {\n    local := new DateTime(year, month, day, hour, minute, second);\n  }\n}\nclass Trail {\n  var code: string\n  var name: string\n  var count: int\n  var month: DateTime\n  var graphCount: int\n  var rankingCount: int\n  var progressCount: int\n  var reportCount: int\n  var displayCount: int\n  var alertCount: int\n  var printerCount: int\n  constructor(c: string, n: string, cnt: int, m: DateTime, gc: int, rc: int, pc: int, repc: int, dc: int, ac: int, prc: int)\n             gc >= 0 && rc >= 0 && pc >= 0 && repc >= 0 && dc >= 0 && ac >= 0 && prc >= 0\n            graphCount == gc && rankingCount == rc && progressCount == pc &&\n            reportCount == repc && displayCount == dc && alertCount == ac && printerCount == prc\n  {\n    code := c;\n    name := n;\n    count := cnt;\n    month := m;\n    graphCount := gc;\n    rankingCount := rc;\n    progressCount := pc;\n    reportCount := repc;\n    displayCount := dc;\n    alertCount := ac;\n    printerCount := prc;\n  }\n  method Validate() returns (isValid: bool)\n                         graphCount >= 0 && rankingCount >= 0 && progressCount >= 0 &&\n                         reportCount >= 0 && displayCount >= 0 && alertCount >= 0 && printerCount >= 0)\n  {\n    isValid := |code| <= 100 && |name| <= 200 && count >= 0 &&\n               graphCount >= 0 && rankingCount >= 0 && progressCount >= 0 &&\n               reportCount >= 0 && displayCount >= 0 && alertCount >= 0 && printerCount >= 0;\n  }\n}\nclass Hour {\n  var hour: int\n  var count: int\n  constructor(h: int, c: int)\n  {\n    hour := h;\n    count := c;\n  }\n  method Validate() returns (isValid: bool)\n  {\n    isValid := 0 <= hour < 24 && count >= 0;\n  }\n}\nclass LastAccess {\n  var systemCode: string\n  var systemName: string\n  var createdTime: DateTime\n  constructor(sc: string, sn: string, ct: DateTime)\n  {\n    systemCode := sc;\n    systemName := sn;\n    createdTime := ct;\n  }\n  method Validate() returns (isValid: bool)\n  {\n    isValid := |systemCode| <= 100 && |systemName| <= 200;\n  }\n  method GetLocalCreatedTime() returns (localTime: DateTime)\n             0 <= createdTime.hour < 24 && 0 <= createdTime.minute < 60 && 0 <= createdTime.second < 60\n  {\n    localTime := createdTime.ToLocalTime();\n  }\n}", "output": "class DateTime {\n  var year: int\n  var month: int \n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  constructor(y: int, m: int, d: int, h: int, min: int, s: int)\n    requires 1 <= y && 1 <= m <= 12 && 1 <= d <= 31 && 0 <= h < 24 && 0 <= min < 60 && 0 <= s < 60\n    ensures year == y && month == m && day == d && hour == h && minute == min && second == s\n  {\n    year := y;\n    month := m;\n    day := d;\n    hour := h;\n    minute := min;\n    second := s;\n  }\n  method ToLocalTime() returns (local: DateTime)\n    requires 1 <= year && 1 <= month <= 12 && 1 <= day <= 31 && 0 <= hour < 24 && 0 <= minute < 60 && 0 <= second < 60\n    ensures local.year == year && local.month == month && local.day == day\n  {\n    local := new DateTime(year, month, day, hour, minute, second);\n  }\n}\nclass Trail {\n  var code: string\n  var name: string\n  var count: int\n  var month: DateTime\n  var graphCount: int\n  var rankingCount: int\n  var progressCount: int\n  var reportCount: int\n  var displayCount: int\n  var alertCount: int\n  var printerCount: int\n  constructor(c: string, n: string, cnt: int, m: DateTime, gc: int, rc: int, pc: int, repc: int, dc: int, ac: int, prc: int)\n    requires |c| <= 100 && |n| <= 200 && cnt >= 0 &&\n             gc >= 0 && rc >= 0 && pc >= 0 && repc >= 0 && dc >= 0 && ac >= 0 && prc >= 0\n    ensures code == c && name == n && count == cnt && month == m &&\n            graphCount == gc && rankingCount == rc && progressCount == pc &&\n            reportCount == repc && displayCount == dc && alertCount == ac && printerCount == prc\n  {\n    code := c;\n    name := n;\n    count := cnt;\n    month := m;\n    graphCount := gc;\n    rankingCount := rc;\n    progressCount := pc;\n    reportCount := repc;\n    displayCount := dc;\n    alertCount := ac;\n    printerCount := prc;\n  }\n  method Validate() returns (isValid: bool)\n    ensures isValid ==> (|code| <= 100 && |name| <= 200 && count >= 0 &&\n                         graphCount >= 0 && rankingCount >= 0 && progressCount >= 0 &&\n                         reportCount >= 0 && displayCount >= 0 && alertCount >= 0 && printerCount >= 0)\n  {\n    isValid := |code| <= 100 && |name| <= 200 && count >= 0 &&\n               graphCount >= 0 && rankingCount >= 0 && progressCount >= 0 &&\n               reportCount >= 0 && displayCount >= 0 && alertCount >= 0 && printerCount >= 0;\n  }\n}\nclass Hour {\n  var hour: int\n  var count: int\n  constructor(h: int, c: int)\n    requires 0 <= h < 24 && c >= 0\n    ensures hour == h && count == c\n  {\n    hour := h;\n    count := c;\n  }\n  method Validate() returns (isValid: bool)\n    ensures isValid ==> (0 <= hour < 24 && count >= 0)\n  {\n    isValid := 0 <= hour < 24 && count >= 0;\n  }\n}\nclass LastAccess {\n  var systemCode: string\n  var systemName: string\n  var createdTime: DateTime\n  constructor(sc: string, sn: string, ct: DateTime)\n    requires |sc| <= 100 && |sn| <= 200\n    ensures systemCode == sc && systemName == sn && createdTime == ct\n  {\n    systemCode := sc;\n    systemName := sn;\n    createdTime := ct;\n  }\n  method Validate() returns (isValid: bool)\n    ensures isValid ==> (|systemCode| <= 100 && |systemName| <= 200)\n  {\n    isValid := |systemCode| <= 100 && |systemName| <= 200;\n  }\n  method GetLocalCreatedTime() returns (localTime: DateTime)\n    requires 1 <= createdTime.year && 1 <= createdTime.month <= 12 && 1 <= createdTime.day <= 31 && \n             0 <= createdTime.hour < 24 && 0 <= createdTime.minute < 60 && 0 <= createdTime.second < 60\n    ensures localTime.year == createdTime.year && localTime.month == createdTime.month && localTime.day == createdTime.day\n  {\n    localTime := createdTime.ToLocalTime();\n  }\n}", "name": "py2dfy_350", "id": 350}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Location {\n  var lat: real\n  var lng: real\n  constructor(latitude: real, longitude: real)\n  {\n    lat := latitude;\n    lng := longitude;\n  }\n}\nclass Cluster {\n  var center: Location\n  var points: seq<Location>\n  \n  constructor(centerPoint: Location, clusterPoints: seq<Location>)\n  {\n    center := centerPoint;\n    points := clusterPoints;\n  }\n}\nclass ClusterCreator {\n  var locations: seq<Location>\n  var numClusters: nat\n  \n  constructor(locs: seq<Location>, k: nat)\n  {\n    locations := locs;\n    numClusters := k;\n  }\n  method CalculateDistance(loc1: Location, loc2: Location) returns (distance: real)\n  {\n    var latDiff := loc1.lat - loc2.lat;\n    var lngDiff := loc1.lng - loc2.lng;\n    distance := (latDiff * latDiff + lngDiff * lngDiff);\n  }\n  method CreateClusters() returns (clusters: seq<Cluster>)\n  {\n    clusters := InitializeClusters();\n    \n    var maxIterations := 100;\n    var iteration := 0;\n    \n    while iteration < maxIterations\n    {\n      var changed := AssignPointsToClusters(clusters);\n      if !changed {\n        break;\n      }\n      UpdateClusterCenters(clusters);\n      iteration := iteration + 1;\n    }\n  }\n  method InitializeClusters() returns (clusters: seq<Cluster>)\n  {\n    clusters := [];\n    var i := 0;\n    while i < numClusters\n    {\n      var newCluster := new Cluster(locations[i], []);  \n      clusters := clusters + [newCluster];\n      i := i + 1;\n    }\n  }\n  method AssignPointsToClusters(clusters: seq<Cluster>) returns (changed: bool)\n  {\n    changed := false;\n  }\n  method UpdateClusterCenters(clusters: seq<Cluster>)\n  {\n  }\n}", "output": "class Location {\n  var lat: real\n  var lng: real\n  constructor(latitude: real, longitude: real)\n    requires -90.0 <= latitude <= 90.0  \n    requires -180.0 <= longitude <= 180.0  \n    ensures lat == latitude && lng == longitude\n  {\n    lat := latitude;\n    lng := longitude;\n  }\n}\nclass Cluster {\n  var center: Location\n  var points: seq<Location>\n  \n  constructor(centerPoint: Location, clusterPoints: seq<Location>)\n    ensures center == centerPoint && points == clusterPoints\n  {\n    center := centerPoint;\n    points := clusterPoints;\n  }\n}\nclass ClusterCreator {\n  var locations: seq<Location>\n  var numClusters: nat\n  \n  constructor(locs: seq<Location>, k: nat)\n    requires k > 0\n    requires |locs| > 0\n    requires k <= |locs|  \n    ensures locations == locs\n    ensures numClusters == k\n  {\n    locations := locs;\n    numClusters := k;\n  }\n  method CalculateDistance(loc1: Location, loc2: Location) returns (distance: real)\n    ensures distance >= 0.0\n  {\n    var latDiff := loc1.lat - loc2.lat;\n    var lngDiff := loc1.lng - loc2.lng;\n    distance := (latDiff * latDiff + lngDiff * lngDiff);\n  }\n  method CreateClusters() returns (clusters: seq<Cluster>)\n    requires |locations| >= numClusters\n    ensures |clusters| == numClusters\n  {\n    clusters := InitializeClusters();\n    \n    var maxIterations := 100;\n    var iteration := 0;\n    \n    while iteration < maxIterations\n      invariant 0 <= iteration <= maxIterations\n      invariant |clusters| == numClusters\n    {\n      var changed := AssignPointsToClusters(clusters);\n      if !changed {\n        break;\n      }\n      UpdateClusterCenters(clusters);\n      iteration := iteration + 1;\n    }\n  }\n  method InitializeClusters() returns (clusters: seq<Cluster>)\n    requires numClusters <= |locations|  \n    ensures |clusters| == numClusters\n  {\n    clusters := [];\n    var i := 0;\n    while i < numClusters\n      invariant 0 <= i <= numClusters\n      invariant |clusters| == i\n    {\n      var newCluster := new Cluster(locations[i], []);  \n      clusters := clusters + [newCluster];\n      i := i + 1;\n    }\n  }\n  method AssignPointsToClusters(clusters: seq<Cluster>) returns (changed: bool)\n    requires |clusters| == numClusters\n  {\n    changed := false;\n  }\n  method UpdateClusterCenters(clusters: seq<Cluster>)\n    requires |clusters| == numClusters\n  {\n  }\n}", "name": "py2dfy_343", "id": 343}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main() {\n  var chi2 := ReadData(\"Lam0/buffer/chi2.dat\");\n  var chi4 := ReadData(\"Lam0/buffer/chi4.dat\");\n  \n  \n}\nmethod ReadData(filename: string) returns (data: seq<real>)\n{\n  \n  \n  data := [0.1, 0.2, 0.3, 0.4, 0.5]; \n}\nmethod ProcessData(data: seq<real>) returns (processedData: seq<real>)\n{\n  var result := new real[|data|];\n  var i := 0;\n  while i < |data|\n  {\n    result[i] := data[i] * 2.0;\n    i := i + 1;\n  }\n  processedData := result[..];\n}", "output": "method Main() {\n  var chi2 := ReadData(\"Lam0/buffer/chi2.dat\");\n  var chi4 := ReadData(\"Lam0/buffer/chi4.dat\");\n  \n  \n}\nmethod ReadData(filename: string) returns (data: seq<real>)\n  requires filename != \"\"\n  ensures |data| > 0\n{\n  \n  \n  data := [0.1, 0.2, 0.3, 0.4, 0.5]; \n  assert |data| > 0; \n}\nmethod ProcessData(data: seq<real>) returns (processedData: seq<real>)\n  requires |data| > 0\n  ensures |processedData| == |data|\n  ensures forall i :: 0 <= i < |data| ==> processedData[i] == data[i] * 2.0\n{\n  var result := new real[|data|];\n  var i := 0;\n  while i < |data|\n    invariant 0 <= i <= |data|\n    invariant result.Length == |data|\n    invariant forall j :: 0 <= j < i ==> result[j] == data[j] * 2.0\n  {\n    result[i] := data[i] * 2.0;\n    i := i + 1;\n  }\n  processedData := result[..];\n}", "name": "py2dfy_312", "id": 312}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Feature = \n  | NumericFeature(numValue: real) \n  | CategoricalFeature(catValue: string)\ntype DataSet = seq<seq<Feature>>\ntrait Transformer {\n  \n  method fit(data: DataSet)\n  \n  predicate Valid()\n  \n  method transform(data: DataSet) returns (result: DataSet)\n}\nclass ArithmeticalFeatures extends Transformer {\n  var isFitted: bool\n  constructor()\n  {\n    isFitted := false;\n  }\n  predicate Valid()\n  {\n    isFitted\n  }\n  method fit(data: DataSet)\n  {\n    isFitted := true;\n  }\n  method transform(data: DataSet) returns (result: DataSet)\n  {\n    \n    var transformed: DataSet := [];\n    var i := 0;\n    \n    while i < |data|\n    {\n      var row := data[i];\n      var newRow := ComputeArithmeticFeatures(row);\n      transformed := transformed + [newRow];\n      i := i + 1;\n    }\n    \n    result := transformed;\n  }\n  \n  method ComputeArithmeticFeatures(row: seq<Feature>) returns (result: seq<Feature>)\n  {\n    \n    \n    result := row;\n  }\n}\nmethod CheckEstimator(transformer: Transformer?)\n{\n  \n  var testData: DataSet := [[NumericFeature(1.0), NumericFeature(2.0)]];\n  \n  \n  transformer.fit(testData);\n  var transformed := transformer.transform(testData);\n}", "output": "datatype Feature = \n  | NumericFeature(numValue: real) \n  | CategoricalFeature(catValue: string)\ntype DataSet = seq<seq<Feature>>\ntrait Transformer {\n  \n  method fit(data: DataSet)\n    requires |data| > 0  \n    requires forall row :: row in data ==> |row| > 0  \n    modifies this\n    ensures Valid()  \n  \n  predicate Valid()\n    reads this\n  \n  method transform(data: DataSet) returns (result: DataSet)\n    requires Valid()  \n    requires |data| > 0\n    requires forall row :: row in data ==> |row| > 0\n    ensures |result| == |data|  \n    ensures forall i :: 0 <= i < |result| ==> |result[i]| > 0  \n}\nclass ArithmeticalFeatures extends Transformer {\n  var isFitted: bool\n  constructor()\n    ensures !isFitted\n  {\n    isFitted := false;\n  }\n  predicate Valid()\n    reads this\n  {\n    isFitted\n  }\n  method fit(data: DataSet)\n    requires |data| > 0\n    requires forall row :: row in data ==> |row| > 0\n    modifies this\n    ensures Valid()\n  {\n    isFitted := true;\n  }\n  method transform(data: DataSet) returns (result: DataSet)\n    requires Valid()\n    requires |data| > 0\n    requires forall row :: row in data ==> |row| > 0\n    ensures |result| == |data|\n    ensures forall i :: 0 <= i < |result| ==> |result[i]| > 0\n  {\n    \n    var transformed: DataSet := [];\n    var i := 0;\n    \n    while i < |data|\n      invariant 0 <= i <= |data|\n      invariant |transformed| == i\n      invariant forall j :: 0 <= j < i ==> |transformed[j]| > 0\n    {\n      var row := data[i];\n      var newRow := ComputeArithmeticFeatures(row);\n      transformed := transformed + [newRow];\n      i := i + 1;\n    }\n    \n    result := transformed;\n  }\n  \n  method ComputeArithmeticFeatures(row: seq<Feature>) returns (result: seq<Feature>)\n    requires |row| > 0\n    ensures |result| > 0\n  {\n    \n    \n    result := row;\n  }\n}\nmethod CheckEstimator(transformer: Transformer?)\n  requires transformer != null\n  modifies transformer  \n  ensures transformer.Valid()\n{\n  \n  var testData: DataSet := [[NumericFeature(1.0), NumericFeature(2.0)]];\n  \n  \n  transformer.fit(testData);\n  var transformed := transformer.transform(testData);\n  assert |transformed| == |testData|;\n}", "name": "py2dfy_304", "id": 304}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module AgeValidation {\n    \n    const MIN_AGE: int := 0\n    const MAX_AGE: int := 125\n    \n    predicate IsValidAge(age: int)\n    {\n        MIN_AGE <= age <= MAX_AGE\n    }\n    \n    method ClampAge(age: int) returns (clampedAge: int)\n    {\n        if age < MIN_AGE {\n            return MIN_AGE;\n        } else if age > MAX_AGE {\n            return MAX_AGE;\n        }\n        return age;\n    }\n}", "output": "module AgeValidation {\n    \n    const MIN_AGE: int := 0\n    const MAX_AGE: int := 125\n    \n    predicate IsValidAge(age: int)\n        ensures IsValidAge(age) <==> (MIN_AGE <= age <= MAX_AGE)\n    {\n        MIN_AGE <= age <= MAX_AGE\n    }\n    \n    method ClampAge(age: int) returns (clampedAge: int)\n        ensures MIN_AGE <= clampedAge <= MAX_AGE  \n        ensures age <= MIN_AGE ==> clampedAge == MIN_AGE  \n        ensures age >= MAX_AGE ==> clampedAge == MAX_AGE  \n        ensures MIN_AGE <= age <= MAX_AGE ==> clampedAge == age  \n    {\n        if age < MIN_AGE {\n            return MIN_AGE;\n        } else if age > MAX_AGE {\n            return MAX_AGE;\n        }\n        return age;\n    }\n}", "name": "py2dfy_370", "id": 370}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintStrings()\n  \n  \n  \n{\n  \n  print \"test\\n\";\n  print \"moreing\\n\";\n  print \" a nnnnn\\n\";\n}\nmethod Main() {\n  PrintStrings();\n}", "output": "method PrintStrings()\n  \n  \n  \n  ensures true  \n{\n  \n  print \"test\\n\";\n  print \"moreing\\n\";\n  print \" a nnnnn\\n\";\n}\nmethod Main() {\n  PrintStrings();\n}", "name": "py2dfy_361", "id": 361}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Store {\n    var name: string\n    var realised: int\n    var realisedSumm: int\n    predicate Valid()\n    {\n        realised >= 0 && realisedSumm >= 0\n    }\n    constructor(storeName: string)\n    {\n        name := storeName;\n        realised := 0;\n        realisedSumm := 0;\n    }\n    method GetName() returns (result: string)\n    {\n        return name;\n    }\n    method SetName(newName: string)\n    {\n        name := newName;\n    }\n    method GetRealised() returns (result: int)\n    {\n        return realised;\n    }\n    method SetRealised(value: int)\n    {\n        realised := value;\n    }\n    method Sell()\n    {\n        realised := realised + 1;\n        realisedSumm := realisedSumm + 1;\n    }\n    method SeeSumm()\n    {\n        print \"Store sales: \", realised, \"\\n\";\n        print \"Total sales across all stores: \", realisedSumm, \"\\n\";\n    }\n}\nmethod Main()\n{\n    var metro := new Store(\"METPO\");\n    metro.Sell();\n    metro.SeeSumm();\n    var ashan := new Store(\"ASHAN\");\n    ashan.Sell();\n    ashan.SeeSumm();\n}", "output": "class Store {\n    var name: string\n    var realised: int\n    var realisedSumm: int\n    predicate Valid()\n    reads this\n    {\n        realised >= 0 && realisedSumm >= 0\n    }\n    constructor(storeName: string)\n    ensures Valid()\n    ensures name == storeName\n    ensures realised == 0\n    {\n        name := storeName;\n        realised := 0;\n        realisedSumm := 0;\n    }\n    method GetName() returns (result: string)\n    requires Valid()\n    ensures result == name\n    ensures Valid()\n    {\n        return name;\n    }\n    method SetName(newName: string)\n    requires Valid()\n    ensures name == newName\n    ensures Valid()\n    ensures realised == old(realised)\n    modifies this\n    {\n        name := newName;\n    }\n    method GetRealised() returns (result: int)\n    requires Valid()\n    ensures result == realised\n    ensures Valid()\n    {\n        return realised;\n    }\n    method SetRealised(value: int)\n    requires Valid()\n    requires value >= 0\n    ensures realised == value\n    ensures Valid()\n    modifies this\n    {\n        realised := value;\n    }\n    method Sell()\n    requires Valid()\n    ensures realised == old(realised) + 1\n    ensures realisedSumm == old(realisedSumm) + 1\n    ensures Valid()\n    modifies this\n    {\n        realised := realised + 1;\n        realisedSumm := realisedSumm + 1;\n    }\n    method SeeSumm()\n    requires Valid()\n    ensures Valid()\n    {\n        print \"Store sales: \", realised, \"\\n\";\n        print \"Total sales across all stores: \", realisedSumm, \"\\n\";\n    }\n}\nmethod Main()\n{\n    var metro := new Store(\"METPO\");\n    metro.Sell();\n    metro.SeeSumm();\n    var ashan := new Store(\"ASHAN\");\n    ashan.Sell();\n    ashan.SeeSumm();\n}", "name": "py2dfy_366", "id": 366}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Node {\n    var isShutdown: bool\n    var rate: nat\n    constructor()\n    {\n        isShutdown := false;\n        rate := 2;\n    }\n    method Run()\n    {\n        while !isShutdown\n        {\n            Print();\n            Sleep();\n            if * { isShutdown := true; }\n        }\n    }\n    method Print()\n    {\n        print \"this is my first node\\n\";\n    }\n    method Sleep()\n    {\n        \n    }\n}\nmethod Main()\n{\n    var node := new Node();\n    node.Run();\n}", "output": "class Node {\n    var isShutdown: bool\n    var rate: nat\n    constructor()\n        ensures isShutdown == false \n        ensures rate == 2\n    {\n        isShutdown := false;\n        rate := 2;\n    }\n    method Run()\n        requires isShutdown == false\n        requires rate > 0\n        modifies this\n        ensures isShutdown == true\n        decreases *\n    {\n        while !isShutdown\n            invariant rate > 0\n            decreases *\n        {\n            Print();\n            Sleep();\n            if * { isShutdown := true; }\n        }\n    }\n    method Print()\n    {\n        print \"this is my first node\\n\";\n    }\n    method Sleep()\n        requires rate > 0\n    {\n        \n    }\n}\nmethod Main()\n    decreases *\n{\n    var node := new Node();\n    node.Run();\n}", "name": "py2dfy_367", "id": 367}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module BufferOverflowSimulation {\n    class Process {\n        var buffer: array<char>\n        ghost var valid: bool\n        constructor(size: nat)\n        {\n            buffer := new char[size];\n            valid := true;\n        }\n    }\n    method GenerateExploit(bufferSize: nat, winAddr: nat) returns (payload: array<char>)\n    {\n        \n        payload := new char[bufferSize + 4];\n        \n        \n        var j := 0;\n        while j < payload.Length\n        {\n            payload[j] := 0 as char;\n            j := j + 1;\n        }\n        \n        var i := 0;\n        while i < bufferSize \n        {\n            payload[i] := 'A';\n            i := i + 1;\n        }\n        \n        AddressToBytes(winAddr, payload, bufferSize);\n    }\n    method AddressToBytes(addr: nat, payload: array<char>, offset: nat)\n    {\n        payload[offset] := (addr % 256) as char;\n        payload[offset + 1] := ((addr / 256) % 256) as char;\n        payload[offset + 2] := ((addr / 65536) % 256) as char;\n        payload[offset + 3] := ((addr / 16777216) % 256) as char;\n    }\n    method ExecuteExploit(proc: Process, payload: array<char>) returns (success: bool)\n    {\n        var i := 0;\n        while i < payload.Length\n        {\n            proc.buffer[i] := payload[i];\n            i := i + 1;\n        }\n        success := true;\n    }\n}", "output": "module BufferOverflowSimulation {\n    class Process {\n        var buffer: array<char>\n        ghost var valid: bool\n        constructor(size: nat)\n            ensures fresh(buffer)\n            ensures buffer.Length == size \n            ensures valid\n        {\n            buffer := new char[size];\n            valid := true;\n        }\n    }\n    method GenerateExploit(bufferSize: nat, winAddr: nat) returns (payload: array<char>)\n        requires bufferSize > 0\n        requires winAddr > 0\n        ensures fresh(payload)\n        ensures payload.Length == bufferSize + 4  \n        ensures forall i :: 0 <= i < bufferSize ==> payload[i] == 'A'\n    {\n        \n        payload := new char[bufferSize + 4];\n        \n        \n        var j := 0;\n        while j < payload.Length\n            invariant 0 <= j <= payload.Length\n            invariant forall k :: 0 <= k < j ==> payload[k] == 0 as char\n        {\n            payload[j] := 0 as char;\n            j := j + 1;\n        }\n        \n        var i := 0;\n        while i < bufferSize \n            invariant 0 <= i <= bufferSize\n            invariant forall k :: 0 <= k < i ==> payload[k] == 'A'\n            invariant forall k :: i <= k < payload.Length ==> payload[k] == 0 as char\n        {\n            payload[i] := 'A';\n            i := i + 1;\n        }\n        \n        AddressToBytes(winAddr, payload, bufferSize);\n    }\n    method AddressToBytes(addr: nat, payload: array<char>, offset: nat)\n        requires addr > 0\n        requires offset + 4 <= payload.Length\n        modifies payload\n        ensures forall i :: 0 <= i < offset ==> payload[i] == old(payload[i])\n    {\n        payload[offset] := (addr % 256) as char;\n        payload[offset + 1] := ((addr / 256) % 256) as char;\n        payload[offset + 2] := ((addr / 65536) % 256) as char;\n        payload[offset + 3] := ((addr / 16777216) % 256) as char;\n    }\n    method ExecuteExploit(proc: Process, payload: array<char>) returns (success: bool)\n        requires proc.valid\n        requires payload.Length <= proc.buffer.Length\n        modifies proc.buffer\n        ensures success ==> proc.valid\n    {\n        var i := 0;\n        while i < payload.Length\n            invariant 0 <= i <= payload.Length\n            invariant proc.valid\n        {\n            proc.buffer[i] := payload[i];\n            i := i + 1;\n        }\n        success := true;\n    }\n}", "name": "py2dfy_334", "id": 334}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype QueryResult = QueryResult(\n  data: map<string, bool>,\n  extensions: Option<TracingData>  \n)\ndatatype TracingData = TracingData(\n  startTime: nat,\n  endTime: nat,\n  duration: nat\n)\ndatatype Option<T> = None | Some(value: T)\nclass Schema {\n  \n  var isValid: bool  \n  constructor()\n  {\n    isValid := true;\n  }\n  \n  method ExecuteQuery(query: string, useTracing: bool) returns (result: QueryResult)\n  {\n    var data: map<string, bool> := map[\"status\" := true];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n  \n  method ExecuteIntrospectionQuery(useTracing: bool) returns (result: QueryResult)\n  {\n    var data: map<string, bool> := map[\"__schema\" := true];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n  \n  method ExecuteErrorQuery(useTracing: bool) returns (result: QueryResult)\n  {\n    var data: map<string, bool> := map[\"testError\" := false];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n}\nmethod TestQueries()\n{\n  var schema := new Schema();\n  \n  \n  var result1 := schema.ExecuteQuery(\"{ status }\", true);\n  \n  var result2 := schema.ExecuteErrorQuery(true);\n  \n  var result3 := schema.ExecuteIntrospectionQuery(true);\n}", "output": "datatype QueryResult = QueryResult(\n  data: map<string, bool>,\n  extensions: Option<TracingData>  \n)\ndatatype TracingData = TracingData(\n  startTime: nat,\n  endTime: nat,\n  duration: nat\n)\ndatatype Option<T> = None | Some(value: T)\nclass Schema {\n  \n  var isValid: bool  \n  constructor()\n    ensures isValid\n  {\n    isValid := true;\n  }\n  \n  method ExecuteQuery(query: string, useTracing: bool) returns (result: QueryResult)\n    requires isValid\n    ensures result.data.Keys >= {\"status\"}\n    ensures result.data[\"status\"] == true\n    ensures useTracing ==> result.extensions.Some?\n    ensures !useTracing ==> result.extensions.None?\n  {\n    var data: map<string, bool> := map[\"status\" := true];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n  \n  method ExecuteIntrospectionQuery(useTracing: bool) returns (result: QueryResult)\n    requires isValid\n    ensures result.data.Keys >= {\"__schema\"}\n    ensures result.data[\"__schema\"] == true\n    ensures useTracing ==> result.extensions.Some?\n    ensures !useTracing ==> result.extensions.None?\n  {\n    var data: map<string, bool> := map[\"__schema\" := true];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n  \n  method ExecuteErrorQuery(useTracing: bool) returns (result: QueryResult)\n    requires isValid\n    ensures result.data.Keys >= {\"testError\"}\n    ensures result.data[\"testError\"] == false  \n    ensures useTracing ==> result.extensions.Some?\n    ensures !useTracing ==> result.extensions.None?\n  {\n    var data: map<string, bool> := map[\"testError\" := false];\n    \n    if useTracing {\n      var tracingData := TracingData(0, 100, 100);\n      result := QueryResult(data, Some(tracingData));\n    } else {\n      result := QueryResult(data, None);\n    }\n  }\n}\nmethod TestQueries()\n{\n  var schema := new Schema();\n  \n  \n  var result1 := schema.ExecuteQuery(\"{ status }\", true);\n  assert result1.data[\"status\"] == true;\n  assert result1.extensions.Some?;\n  \n  var result2 := schema.ExecuteErrorQuery(true);\n  assert result2.data[\"testError\"] == false;\n  assert result2.extensions.Some?;\n  \n  var result3 := schema.ExecuteIntrospectionQuery(true);\n  assert result3.data[\"__schema\"] == true;\n  assert result3.extensions.Some?;\n}", "name": "py2dfy_332", "id": 332}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CommandCompleter(n: nat, m: nat, b: bool) {\n    var R1 := 0;\n    var R2 := 0;\n    var i := 0;\n    var k := 0;\n    while i < n\n    {\n        i := i + 1;\n        k := k + 1;\n    }\n    if (b) {\n        R1 := R1 + k;\n    } else {\n        var j := 0;\n        while j < k\n        {\n            if (b) {\n                R2 := R2 + 1;\n            }\n            j := j+1;\n        }\n    }\n}", "output": "method CommandCompleter(n: nat, m: nat, b: bool) {\n    var R1 := 0;\n    var R2 := 0;\n    var i := 0;\n    var k := 0;\n    while i < n\n        invariant i==k\n        invariant i<=n\n    {\n        i := i + 1;\n        k := k + 1;\n    }\n    assert k <= n; \n    if (b) {\n        R1 := R1 + k;\n        assert R1 <= n; \n    } else {\n        var j := 0;\n        while j < k\n            invariant j >= R2\n            invariant j <= k\n        {\n            if (b) {\n                R2 := R2 + 1;\n                assert j >= R2; \n            }\n            j := j+1;\n        }\n        assert j<=n; \n    }\n    assert R1 + R2 <= 2*n; \n}", "name": "py2dfy_378", "id": 378}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Solution {\n  \n  method CountConnections(stones: array<Point>) returns (shareList: array<int>)\n  {\n    shareList := new int[stones.Length];\n    \n    \n    var i := 0;\n    while i < stones.Length\n    {\n      shareList[i] := 0;\n      i := i + 1;\n    }\n    \n    i := 0;\n    while i < stones.Length\n    {\n      var j := 0;\n      while j < stones.Length\n      {\n        if i != j {\n          \n          if stones[i].x == stones[j].x || stones[i].y == stones[j].y {\n            shareList[i] := shareList[i] + 1;\n          }\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method RemoveStones(stones: array<Point>) returns (result: int)\n  {\n    var shareList := CountConnections(stones);\n    \n    \n    var isolatedCount := 0;\n    var i := 0;\n    while i < shareList.Length\n    {\n      if shareList[i] == 0 {\n        isolatedCount := isolatedCount + 1;\n      }\n      i := i + 1;\n    }\n    \n    var connectSum := 0;\n    i := 0;\n    while i < shareList.Length\n    {\n      connectSum := connectSum + shareList[i];\n      i := i + 1;\n    }\n    \n    if connectSum == 0 {\n      result := 0;\n    } else {\n      \n      result := stones.Length - (isolatedCount + 1);\n    }\n    \n    if result < 0 {\n      result := 0;\n    } else if result > stones.Length - 1 {\n      result := stones.Length - 1;\n    }\n  }\n}", "output": "class Point {\n  var x: int\n  var y: int\n  constructor(x': int, y': int)\n  {\n    x := x';\n    y := y';\n  }\n}\nclass Solution {\n  \n  method CountConnections(stones: array<Point>) returns (shareList: array<int>)\n    requires stones.Length > 0\n    ensures shareList.Length == stones.Length\n    ensures forall i :: 0 <= i < shareList.Length ==> shareList[i] >= 0\n  {\n    shareList := new int[stones.Length];\n    \n    \n    var i := 0;\n    while i < stones.Length\n      invariant 0 <= i <= stones.Length\n      invariant shareList.Length == stones.Length\n      invariant forall k :: 0 <= k < i ==> shareList[k] == 0\n    {\n      shareList[i] := 0;\n      i := i + 1;\n    }\n    \n    i := 0;\n    while i < stones.Length\n      invariant 0 <= i <= stones.Length\n      invariant shareList.Length == stones.Length\n      invariant forall k :: 0 <= k < shareList.Length ==> shareList[k] >= 0\n    {\n      var j := 0;\n      while j < stones.Length\n        invariant 0 <= j <= stones.Length\n        invariant shareList.Length == stones.Length\n        invariant forall k :: 0 <= k < shareList.Length ==> shareList[k] >= 0\n      {\n        if i != j {\n          \n          if stones[i].x == stones[j].x || stones[i].y == stones[j].y {\n            shareList[i] := shareList[i] + 1;\n          }\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method RemoveStones(stones: array<Point>) returns (result: int)\n    requires stones.Length > 0\n    ensures 0 <= result <= stones.Length - 1\n  {\n    var shareList := CountConnections(stones);\n    \n    \n    var isolatedCount := 0;\n    var i := 0;\n    while i < shareList.Length\n      invariant 0 <= i <= shareList.Length\n      invariant 0 <= isolatedCount <= i\n    {\n      if shareList[i] == 0 {\n        isolatedCount := isolatedCount + 1;\n      }\n      i := i + 1;\n    }\n    \n    var connectSum := 0;\n    i := 0;\n    while i < shareList.Length\n      invariant 0 <= i <= shareList.Length\n      invariant connectSum >= 0\n      invariant forall k :: 0 <= k < shareList.Length ==> shareList[k] >= 0\n    {\n      connectSum := connectSum + shareList[i];\n      i := i + 1;\n    }\n    \n    if connectSum == 0 {\n      result := 0;\n    } else {\n      \n      result := stones.Length - (isolatedCount + 1);\n    }\n    \n    if result < 0 {\n      result := 0;\n    } else if result > stones.Length - 1 {\n      result := stones.Length - 1;\n    }\n  }\n}", "name": "py2dfy_374", "id": 374}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method {:extern} Print(s: string)\nmethod {:extern} ReadLine() returns (s: string)\nmethod Main()\n{\n    \n    var name := GetValidName();\n    \n    \n    Print(\"How many guests will you have?\");\n    var input := ReadLine();\n    var numGuests := ParseInt(input);\n    \n    \n    if numGuests > 0 {\n        Print(\"Be sure to have enough room for all your guests.\");\n    }\n    Print(\"Done\");\n}\nmethod GetValidName() returns (name: string)\n{\n    name := \"\";\n    \n    while |name| == 0\n    {\n        Print(\"Enter your name:\");\n        name := ReadLine();\n    }\n}\nmethod ParseInt(s: string) returns (n: int)\n{\n    \n    \n    n := 0;  \n}", "output": "method {:extern} Print(s: string)\nmethod {:extern} ReadLine() returns (s: string)\nmethod Main()\n  decreases *\n{\n    \n    var name := GetValidName();\n    \n    \n    Print(\"How many guests will you have?\");\n    var input := ReadLine();\n    var numGuests := ParseInt(input);\n    \n    \n    if numGuests > 0 {\n        Print(\"Be sure to have enough room for all your guests.\");\n    }\n    Print(\"Done\");\n}\nmethod GetValidName() returns (name: string)\n    ensures |name| > 0  \n    decreases *\n{\n    name := \"\";\n    \n    while |name| == 0\n        invariant true  \n        decreases *  \n    {\n        Print(\"Enter your name:\");\n        name := ReadLine();\n    }\n}\nmethod ParseInt(s: string) returns (n: int)\n    ensures n >= 0  \n{\n    \n    \n    n := 0;  \n}", "name": "py2dfy_362", "id": 362}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module NLPConfig {\n  \n  datatype ModelType = Word2Vec | GloVe | BERT\n  \n  class Configuration {\n    \n    const WORD2VEC_MODEL_PATH: string\n    const GLOVE_MODEL_PATH: string \n    const META_PATH: string\n    const PAIRED_PATH: string\n    const TABLE2_PATH: string\n    const TABLE3_PATH: string\n    const PHQ_TERM_PATH: string\n    const VOCAB_PATH: string\n    \n    \n    var modelDimensions: map<ModelType, int>\n    \n    \n    const DIMENSIONS: seq<string>\n    \n    ghost predicate Valid()\n    {\n      && modelDimensions.Keys == {Word2Vec, GloVe, BERT}\n      && (forall m :: m in modelDimensions ==> modelDimensions[m] > 0)\n      && |DIMENSIONS| > 0\n    }\n    constructor()\n    {\n      WORD2VEC_MODEL_PATH := \"models/word2vec/GoogleNews-vectors-negative300.bin\";\n      GLOVE_MODEL_PATH := \"models/glove/glove.840B.300d.txt\";\n      META_PATH := \"results/_phq9_diffs_with_paths.tsv\";\n      PAIRED_PATH := \"results/paired7.json\";\n      TABLE2_PATH := \"results/table2.tsv\";\n      TABLE3_PATH := \"results/table3.tsv\";\n      PHQ_TERM_PATH := \"data/clinical-terms-v3.tsv\";\n      VOCAB_PATH := \"data/english.txt\";\n      \n      \n      modelDimensions := map[\n        Word2Vec := 300,\n        GloVe := 300,\n        BERT := 1024\n      ];\n      \n      \n      DIMENSIONS := [\"gender_imputed\", \"Num_sess\", \"Age_ses1\", \"PHQ9_total_ses\"];\n    }\n    \n    method GetModelDimension(model: ModelType) returns (dimension: int)\n    {\n      dimension := modelDimensions[model];\n      \n      }\n    }\n    \n    method IsValidDimension(dim: string) returns (isValid: bool)\n    {\n      isValid := dim in DIMENSIONS;\n    }\n  }\n}", "output": "module NLPConfig {\n  \n  datatype ModelType = Word2Vec | GloVe | BERT\n  \n  class Configuration {\n    \n    const WORD2VEC_MODEL_PATH: string\n    const GLOVE_MODEL_PATH: string \n    const META_PATH: string\n    const PAIRED_PATH: string\n    const TABLE2_PATH: string\n    const TABLE3_PATH: string\n    const PHQ_TERM_PATH: string\n    const VOCAB_PATH: string\n    \n    \n    var modelDimensions: map<ModelType, int>\n    \n    \n    const DIMENSIONS: seq<string>\n    \n    ghost predicate Valid()\n      reads this\n    {\n      && modelDimensions.Keys == {Word2Vec, GloVe, BERT}\n      && (forall m :: m in modelDimensions ==> modelDimensions[m] > 0)\n      && |DIMENSIONS| > 0\n    }\n    constructor()\n      ensures Valid()\n      ensures fresh(this)\n    {\n      WORD2VEC_MODEL_PATH := \"models/word2vec/GoogleNews-vectors-negative300.bin\";\n      GLOVE_MODEL_PATH := \"models/glove/glove.840B.300d.txt\";\n      META_PATH := \"results/_phq9_diffs_with_paths.tsv\";\n      PAIRED_PATH := \"results/paired7.json\";\n      TABLE2_PATH := \"results/table2.tsv\";\n      TABLE3_PATH := \"results/table3.tsv\";\n      PHQ_TERM_PATH := \"data/clinical-terms-v3.tsv\";\n      VOCAB_PATH := \"data/english.txt\";\n      \n      \n      modelDimensions := map[\n        Word2Vec := 300,\n        GloVe := 300,\n        BERT := 1024\n      ];\n      \n      \n      DIMENSIONS := [\"gender_imputed\", \"Num_sess\", \"Age_ses1\", \"PHQ9_total_ses\"];\n    }\n    \n    method GetModelDimension(model: ModelType) returns (dimension: int)\n      requires Valid()\n      requires model in modelDimensions.Keys\n      ensures dimension == modelDimensions[model]\n      ensures dimension > 0\n    {\n      dimension := modelDimensions[model];\n      \n      assert modelDimensions[model] > 0 by {\n        assert model in modelDimensions;\n      }\n    }\n    \n    method IsValidDimension(dim: string) returns (isValid: bool)\n      requires Valid()\n      ensures isValid <==> dim in DIMENSIONS\n    {\n      isValid := dim in DIMENSIONS;\n    }\n  }\n}", "name": "py2dfy_340", "id": 340}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class PollMessage {\n  var question: string\n  var options: seq<string>\n  var emojis: seq<string>\n  var authorId: string\n  var messageId: string\n  var reactions: seq<int>  \n  constructor(q: string, opts: seq<string>, em: seq<string>, author: string)\n  {\n    question := q;\n    options := opts;\n    emojis := em;\n    authorId := author;\n    messageId := \"\"; \n    reactions := seq(|opts|, _ => 0);  \n  }\n  \n  method AddReaction(optionIndex: int) returns (success: bool)\n            reactions[i] == old(reactions[i])  \n  {\n    reactions := reactions[optionIndex := reactions[optionIndex] + 1];\n    return true;\n  }\n  \n  method RemoveReaction(optionIndex: int) returns (success: bool)\n            reactions[i] == old(reactions[i])  \n  {\n    reactions := reactions[optionIndex := reactions[optionIndex] - 1];\n    return true;\n  }\n  \n  method GetResults() returns (results: seq<(string, string, int)>)\n            results[i] == (options[i], emojis[i], reactions[i])\n  {\n    results := [];\n    var i := 0;\n    while i < |options|\n                results[k] == (options[k], emojis[k], reactions[k])\n    {\n      results := results + [(options[i], emojis[i], reactions[i])];\n      i := i + 1;\n    }\n  }\n}\nmethod CreatePoll(question: string, options: seq<string>, emojis: seq<string>, authorId: string) \n  returns (poll: PollMessage?)\n    poll.question == question && \n    poll.options == options && \n    poll.emojis == emojis &&\n    poll.authorId == authorId\n{\n  poll := new PollMessage(question, options, emojis, authorId);\n  return poll;\n}", "output": "class PollMessage {\n  var question: string\n  var options: seq<string>\n  var emojis: seq<string>\n  var authorId: string\n  var messageId: string\n  var reactions: seq<int>  \n  constructor(q: string, opts: seq<string>, em: seq<string>, author: string)\n    requires |opts| > 1  \n    requires |opts| == |em|  \n    requires forall i :: 0 <= i < |opts| ==> |opts[i]| > 0  \n    requires forall i :: 0 <= i < |em| ==> |em[i]| > 0  \n    ensures question == q\n    ensures options == opts\n    ensures emojis == em\n    ensures authorId == author\n    ensures |reactions| == |options|\n    ensures forall i :: 0 <= i < |reactions| ==> reactions[i] == 0  \n  {\n    question := q;\n    options := opts;\n    emojis := em;\n    authorId := author;\n    messageId := \"\"; \n    reactions := seq(|opts|, _ => 0);  \n  }\n  \n  method AddReaction(optionIndex: int) returns (success: bool)\n    requires 0 <= optionIndex < |options|\n    requires |reactions| == |options|\n    modifies this\n    ensures success\n    ensures |reactions| == old(|reactions|)\n    ensures reactions[optionIndex] == old(reactions[optionIndex]) + 1\n    ensures forall i :: 0 <= i < |reactions| && i != optionIndex ==> \n            reactions[i] == old(reactions[i])  \n  {\n    reactions := reactions[optionIndex := reactions[optionIndex] + 1];\n    return true;\n  }\n  \n  method RemoveReaction(optionIndex: int) returns (success: bool)\n    requires 0 <= optionIndex < |options|\n    requires |reactions| == |options|\n    requires reactions[optionIndex] > 0  \n    modifies this\n    ensures success\n    ensures |reactions| == old(|reactions|)\n    ensures reactions[optionIndex] == old(reactions[optionIndex]) - 1\n    ensures forall i :: 0 <= i < |reactions| && i != optionIndex ==> \n            reactions[i] == old(reactions[i])  \n  {\n    reactions := reactions[optionIndex := reactions[optionIndex] - 1];\n    return true;\n  }\n  \n  method GetResults() returns (results: seq<(string, string, int)>)\n    requires |options| == |emojis| == |reactions|\n    ensures |results| == |options|\n    ensures forall i :: 0 <= i < |results| ==>\n            results[i] == (options[i], emojis[i], reactions[i])\n  {\n    results := [];\n    var i := 0;\n    while i < |options|\n      invariant 0 <= i <= |options|\n      invariant |results| == i\n      invariant |options| == |emojis| == |reactions|\n      invariant forall k :: 0 <= k < i ==>\n                results[k] == (options[k], emojis[k], reactions[k])\n    {\n      results := results + [(options[i], emojis[i], reactions[i])];\n      i := i + 1;\n    }\n  }\n}\nmethod CreatePoll(question: string, options: seq<string>, emojis: seq<string>, authorId: string) \n  returns (poll: PollMessage?)\n  requires |options| > 1  \n  requires |options| == |emojis|  \n  requires forall i :: 0 <= i < |options| ==> |options[i]| > 0\n  requires forall i :: 0 <= i < |emojis| ==> |emojis[i]| > 0\n  ensures poll != null ==> \n    poll.question == question && \n    poll.options == options && \n    poll.emojis == emojis &&\n    poll.authorId == authorId\n{\n  poll := new PollMessage(question, options, emojis, authorId);\n  return poll;\n}", "name": "py2dfy_320", "id": 320}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Color = Red | Pink | Blue | Purple | Black | Green\ndatatype Option<T> = None | Some(value: T)\nclass Racer {\n  var xPos: int\n  var yPos: int  \n  var color: Color\n  constructor(c: Color, x: int, y: int)\n  {\n    color := c;\n    xPos := x;\n    yPos := y;\n  }\n}\nclass RaceSimulation {\n  var racers: array<Racer?>\n  var isRaceOn: bool\n  var userBet: Color\n  \n  constructor()\n  {\n    racers := new Racer?[6];\n    isRaceOn := false;\n  }\n  method InitializeRacers()\n  {\n    var colors := [Color.Red, Color.Pink, Color.Blue, Color.Purple, Color.Black, Color.Green];\n    var yPositions := [100, 60, 20, -20, -60, -100];\n    \n    var i := 0;\n    while i < 6\n    {\n      racers[i] := new Racer(colors[i], -230, yPositions[i]);\n      i := i + 1;\n    }\n  }\n  function GetRandomMove(): int\n  {\n    5 \n  }\n  method RaceStep() returns (winner: Option<Color>)\n  {\n    var i := 0;\n    while i < racers.Length\n    {\n      \n      racers[i].xPos := racers[i].xPos + GetRandomMove();\n      \n      if racers[i].xPos > 230 {\n        isRaceOn := false;\n        return Some(racers[i].color);\n      }\n      i := i + 1;\n    }\n    return None;\n  }\n  method RunRace(bet: Color) returns (winner: Color)\n  {\n    userBet := bet;\n    isRaceOn := true;\n    \n    var currentWinner: Option<Color> := None;\n    while isRaceOn\n    {\n      currentWinner := RaceStep();\n    }\n    \n    match currentWinner {\n      case Some(w) => return w;\n      case None => return Color.Red; \n    }\n  }\n}", "output": "datatype Color = Red | Pink | Blue | Purple | Black | Green\ndatatype Option<T> = None | Some(value: T)\nclass Racer {\n  var xPos: int\n  var yPos: int  \n  var color: Color\n  constructor(c: Color, x: int, y: int)\n    ensures this.xPos == x\n    ensures this.yPos == y \n    ensures this.color == c\n  {\n    color := c;\n    xPos := x;\n    yPos := y;\n  }\n}\nclass RaceSimulation {\n  var racers: array<Racer?>\n  var isRaceOn: bool\n  var userBet: Color\n  \n  constructor()\n    ensures racers.Length == 6\n    ensures fresh(racers)\n  {\n    racers := new Racer?[6];\n    isRaceOn := false;\n  }\n  method InitializeRacers()\n    modifies racers\n    requires racers.Length == 6\n    ensures forall i :: 0 <= i < racers.Length ==> racers[i] != null\n    ensures forall i :: 0 <= i < racers.Length ==> fresh(racers[i])\n  {\n    var colors := [Color.Red, Color.Pink, Color.Blue, Color.Purple, Color.Black, Color.Green];\n    var yPositions := [100, 60, 20, -20, -60, -100];\n    \n    var i := 0;\n    while i < 6\n      invariant 0 <= i <= 6\n      invariant forall k :: 0 <= k < i ==> racers[k] != null\n      invariant forall k :: 0 <= k < i ==> fresh(racers[k])\n    {\n      racers[i] := new Racer(colors[i], -230, yPositions[i]);\n      i := i + 1;\n    }\n  }\n  function GetRandomMove(): int\n  {\n    5 \n  }\n  method RaceStep() returns (winner: Option<Color>)\n    modifies racers[..]\n    requires racers.Length == 6\n    requires forall i :: 0 <= i < racers.Length ==> racers[i] != null\n    requires isRaceOn\n    ensures winner.Some? ==> !isRaceOn  \n    ensures winner.None? ==> isRaceOn   \n    modifies this`isRaceOn\n  {\n    var i := 0;\n    while i < racers.Length\n      invariant 0 <= i <= racers.Length\n      invariant forall k :: 0 <= k < racers.Length ==> racers[k] != null\n      invariant isRaceOn\n    {\n      \n      racers[i].xPos := racers[i].xPos + GetRandomMove();\n      \n      if racers[i].xPos > 230 {\n        isRaceOn := false;\n        return Some(racers[i].color);\n      }\n      i := i + 1;\n    }\n    return None;\n  }\n  method RunRace(bet: Color) returns (winner: Color)\n    modifies this`isRaceOn, this`userBet, racers[..]\n    requires racers.Length == 6\n    requires forall i :: 0 <= i < racers.Length ==> racers[i] != null\n    ensures !isRaceOn  \n    decreases *\n  {\n    userBet := bet;\n    isRaceOn := true;\n    \n    var currentWinner: Option<Color> := None;\n    while isRaceOn\n      invariant forall i :: 0 <= i < racers.Length ==> racers[i] != null\n      decreases *\n    {\n      currentWinner := RaceStep();\n    }\n    \n    match currentWinner {\n      case Some(w) => return w;\n      case None => return Color.Red; \n    }\n  }\n}", "name": "py2dfy_306", "id": 306}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class StockBasicInfo {\n  var id: int\n  var code: string\n  var name: string\n  var industry: string\n  var area: string\n  var pe: real\n  var outstanding: real\n  var totals: real\n  var totalAssets: real\n  var liquidAssets: real\n  var fixedAssets: real\n  var reserved: real\n  var reservedPerShare: real\n  var esp: real\n  var bvps: real\n  var pb: real\n  var timeToMarket: Option<Date>\n  var undp: real\n  var perundp: real\n  var rev: real\n  var profit: real\n  var gpr: real\n  var npr: real\n  var holders: real\n  predicate ValidState()\n  {\n    pe >= 0.0 && outstanding >= 0.0 && totals >= 0.0 &&\n    totalAssets >= 0.0 && liquidAssets >= 0.0 && fixedAssets >= 0.0 &&\n    reserved >= 0.0 && reservedPerShare >= 0.0 && esp >= 0.0 &&\n    bvps >= 0.0 && pb >= 0.0 && undp >= 0.0 && perundp >= 0.0 &&\n    rev >= 0.0 && profit >= 0.0 && gpr >= 0.0 && npr >= 0.0 &&\n    holders >= 0.0 && |code| <= 32 && |name| <= 64 && id > 0\n  }\n  constructor(stockCode: string, stockName: string)\n  {\n    code := stockCode;\n    name := stockName;\n    industry := \"\";\n    area := \"\";\n    pe := 0.0;\n    outstanding := 0.0;\n    totals := 0.0;\n    totalAssets := 0.0;\n    liquidAssets := 0.0;\n    fixedAssets := 0.0;\n    reserved := 0.0;\n    reservedPerShare := 0.0;\n    esp := 0.0;\n    bvps := 0.0;\n    pb := 0.0;\n    timeToMarket := None;\n    undp := 0.0;\n    perundp := 0.0;\n    rev := 0.0;\n    profit := 0.0;\n    gpr := 0.0;\n    npr := 0.0;\n    holders := 0.0;\n    id := 1; \n  }\n}\nclass Date {\n  var year: int\n  var month: int\n  var day: int\n  predicate ValidDate()\n  {\n    1 <= month <= 12 && 1 <= day <= 31 && year >= 1900\n  }\n  constructor(y: int, m: int, d: int)\n  {\n    year := y;\n    month := m;\n    day := d;\n  }\n}\ndatatype Option<T> = Some(value: T) | None\nclass StockTradeMoneyHis {\n  var id: int\n  var code: string\n  var name: Option<string>\n  var trade_date: Option<Date>\n  var open: real\n  var high: real\n  var low: real\n  var close: real\n  var change_rate: real\n  var zhen_rate: real\n  var liangbi: real\n  var pre_close: real\n  var vol: real\n  var amount: real\n  var turnover: real\n  var outstanding: real\n  var mktcap: real\n  var pe: real\n  var pb: real\n  var main_money: real\n  var main_money_rate: real\n  var super_money: real\n  var super_money_rate: real\n  var large_money: real\n  var large_money_rate: real\n  var midden_money: real\n  var midden_money_rate: real\n  var small_money: real\n  var small_money_rate: real\n  predicate ValidState()\n  {\n    |code| <= 32 && \n    (name.Some? ==> |name.value| <= 64) &&\n    id > 0\n  }\n  constructor(stockCode: string)\n  {\n    code := stockCode;\n    name := None;\n    trade_date := None;\n    open := 0.0;\n    high := 0.0;\n    low := 0.0;\n    close := 0.0;\n    change_rate := 0.0;\n    zhen_rate := 0.0;\n    liangbi := 0.0;\n    pre_close := 0.0;\n    vol := 0.0;\n    amount := 0.0;\n    turnover := 0.0;\n    outstanding := 0.0;\n    mktcap := 0.0;\n    pe := 0.0;\n    pb := 0.0;\n    main_money := 0.0;\n    main_money_rate := 0.0;\n    super_money := 0.0;\n    super_money_rate := 0.0;\n    large_money := 0.0;\n    large_money_rate := 0.0;\n    midden_money := 0.0;\n    midden_money_rate := 0.0;\n    small_money := 0.0;\n    small_money_rate := 0.0;\n    id := 1; \n  }\n}\nclass BankBasicInfo {\n  var id: int\n  var name: string\n  var bank_type: string\n  var bank_desc: string\n  var stocks: seq<StockBasicInfo>\n  predicate ValidState()\n  {\n    |name| <= 64 && |bank_type| <= 64 && |bank_desc| <= 1000 && id > 0\n  }\n  constructor(bankName: string, bankType: string)\n  {\n    name := bankName;\n    bank_type := bankType;\n    bank_desc := \"\";\n    stocks := [];\n    id := 1; \n  }\n  method AddStock(stock: StockBasicInfo)\n  {\n    stocks := stocks + [stock];\n  }\n}\nmethod Main()\n{\n  var bank := new BankBasicInfo(\"Example Bank\", \"Commercial\");\n  var stock := new StockBasicInfo(\"600000\", \"Example Stock\");\n  bank.AddStock(stock);\n  \n  var tradeHistory := new StockTradeMoneyHis(\"600000\");\n}", "output": "class StockBasicInfo {\n  var id: int\n  var code: string\n  var name: string\n  var industry: string\n  var area: string\n  var pe: real\n  var outstanding: real\n  var totals: real\n  var totalAssets: real\n  var liquidAssets: real\n  var fixedAssets: real\n  var reserved: real\n  var reservedPerShare: real\n  var esp: real\n  var bvps: real\n  var pb: real\n  var timeToMarket: Option<Date>\n  var undp: real\n  var perundp: real\n  var rev: real\n  var profit: real\n  var gpr: real\n  var npr: real\n  var holders: real\n  predicate ValidState()\n    reads this\n  {\n    pe >= 0.0 && outstanding >= 0.0 && totals >= 0.0 &&\n    totalAssets >= 0.0 && liquidAssets >= 0.0 && fixedAssets >= 0.0 &&\n    reserved >= 0.0 && reservedPerShare >= 0.0 && esp >= 0.0 &&\n    bvps >= 0.0 && pb >= 0.0 && undp >= 0.0 && perundp >= 0.0 &&\n    rev >= 0.0 && profit >= 0.0 && gpr >= 0.0 && npr >= 0.0 &&\n    holders >= 0.0 && |code| <= 32 && |name| <= 64 && id > 0\n  }\n  constructor(stockCode: string, stockName: string)\n    requires |stockCode| <= 32 && |stockName| <= 64\n    ensures code == stockCode && name == stockName\n    ensures pe == 0.0 && outstanding == 0.0 && totals == 0.0\n    ensures totalAssets == 0.0 && liquidAssets == 0.0 && fixedAssets == 0.0\n    ensures reserved == 0.0 && reservedPerShare == 0.0 && esp == 0.0\n    ensures bvps == 0.0 && pb == 0.0 && timeToMarket.None?\n    ensures undp == 0.0 && perundp == 0.0 && rev == 0.0\n    ensures profit == 0.0 && gpr == 0.0 && npr == 0.0 && holders == 0.0\n    ensures ValidState()\n  {\n    code := stockCode;\n    name := stockName;\n    industry := \"\";\n    area := \"\";\n    pe := 0.0;\n    outstanding := 0.0;\n    totals := 0.0;\n    totalAssets := 0.0;\n    liquidAssets := 0.0;\n    fixedAssets := 0.0;\n    reserved := 0.0;\n    reservedPerShare := 0.0;\n    esp := 0.0;\n    bvps := 0.0;\n    pb := 0.0;\n    timeToMarket := None;\n    undp := 0.0;\n    perundp := 0.0;\n    rev := 0.0;\n    profit := 0.0;\n    gpr := 0.0;\n    npr := 0.0;\n    holders := 0.0;\n    id := 1; \n  }\n}\nclass Date {\n  var year: int\n  var month: int\n  var day: int\n  predicate ValidDate()\n    reads this\n  {\n    1 <= month <= 12 && 1 <= day <= 31 && year >= 1900\n  }\n  constructor(y: int, m: int, d: int)\n    requires 1 <= m <= 12 && 1 <= d <= 31 && y >= 1900\n    ensures year == y && month == m && day == d\n    ensures ValidDate()\n  {\n    year := y;\n    month := m;\n    day := d;\n  }\n}\ndatatype Option<T> = Some(value: T) | None\nclass StockTradeMoneyHis {\n  var id: int\n  var code: string\n  var name: Option<string>\n  var trade_date: Option<Date>\n  var open: real\n  var high: real\n  var low: real\n  var close: real\n  var change_rate: real\n  var zhen_rate: real\n  var liangbi: real\n  var pre_close: real\n  var vol: real\n  var amount: real\n  var turnover: real\n  var outstanding: real\n  var mktcap: real\n  var pe: real\n  var pb: real\n  var main_money: real\n  var main_money_rate: real\n  var super_money: real\n  var super_money_rate: real\n  var large_money: real\n  var large_money_rate: real\n  var midden_money: real\n  var midden_money_rate: real\n  var small_money: real\n  var small_money_rate: real\n  predicate ValidState()\n    reads this\n  {\n    |code| <= 32 && \n    (name.Some? ==> |name.value| <= 64) &&\n    id > 0\n  }\n  constructor(stockCode: string)\n    requires |stockCode| <= 32\n    ensures code == stockCode && name == None && trade_date == None\n    ensures open == 0.0 && high == 0.0 && low == 0.0 && close == 0.0\n    ensures change_rate == 0.0 && zhen_rate == 0.0 && liangbi == 0.0\n    ensures pre_close == 0.0 && vol == 0.0 && amount == 0.0\n    ensures turnover == 0.0 && outstanding == 0.0 && mktcap == 0.0\n    ensures pe == 0.0 && pb == 0.0 && main_money == 0.0\n    ensures main_money_rate == 0.0 && super_money == 0.0\n    ensures super_money_rate == 0.0 && large_money == 0.0\n    ensures large_money_rate == 0.0 && midden_money == 0.0\n    ensures midden_money_rate == 0.0 && small_money == 0.0\n    ensures small_money_rate == 0.0\n    ensures ValidState()\n  {\n    code := stockCode;\n    name := None;\n    trade_date := None;\n    open := 0.0;\n    high := 0.0;\n    low := 0.0;\n    close := 0.0;\n    change_rate := 0.0;\n    zhen_rate := 0.0;\n    liangbi := 0.0;\n    pre_close := 0.0;\n    vol := 0.0;\n    amount := 0.0;\n    turnover := 0.0;\n    outstanding := 0.0;\n    mktcap := 0.0;\n    pe := 0.0;\n    pb := 0.0;\n    main_money := 0.0;\n    main_money_rate := 0.0;\n    super_money := 0.0;\n    super_money_rate := 0.0;\n    large_money := 0.0;\n    large_money_rate := 0.0;\n    midden_money := 0.0;\n    midden_money_rate := 0.0;\n    small_money := 0.0;\n    small_money_rate := 0.0;\n    id := 1; \n  }\n}\nclass BankBasicInfo {\n  var id: int\n  var name: string\n  var bank_type: string\n  var bank_desc: string\n  var stocks: seq<StockBasicInfo>\n  predicate ValidState()\n    reads this\n  {\n    |name| <= 64 && |bank_type| <= 64 && |bank_desc| <= 1000 && id > 0\n  }\n  constructor(bankName: string, bankType: string)\n    requires |bankName| <= 64 && |bankType| <= 64\n    ensures name == bankName && bank_type == bankType && bank_desc == \"\"\n    ensures stocks == []\n    ensures ValidState()\n  {\n    name := bankName;\n    bank_type := bankType;\n    bank_desc := \"\";\n    stocks := [];\n    id := 1; \n  }\n  method AddStock(stock: StockBasicInfo)\n    requires stock.ValidState()\n    requires ValidState()\n    modifies this\n    ensures stocks == old(stocks) + [stock]\n    ensures ValidState()\n  {\n    stocks := stocks + [stock];\n  }\n}\nmethod Main()\n{\n  var bank := new BankBasicInfo(\"Example Bank\", \"Commercial\");\n  var stock := new StockBasicInfo(\"600000\", \"Example Stock\");\n  bank.AddStock(stock);\n  \n  var tradeHistory := new StockTradeMoneyHis(\"600000\");\n  assert bank.ValidState() && stock.ValidState() && tradeHistory.ValidState();\n}", "name": "py2dfy_307", "id": 307}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype IpAddress = IpAddress(addr: seq<int>)\ndatatype TracerouteResult = TracerouteResult(hopNum: int, node: IpAddress, rtt: int)\ndatatype UserInfo = UserInfo(userId: string, timestamp: string, ip: IpAddress)\ndatatype NetworkData = NetworkData(userInfo: UserInfo, traceroute: map<int, TracerouteResult>)\ndatatype Option<T> = Some(value: T) | None\nclass NetworkProcessor {\n    \n    const MAX_HOPS: int := 30\n    \n    method TracerouteHop(hopNum: int, targetIp: IpAddress) returns (res: Option<TracerouteResult>)\n    {\n        \n        \n        var dummyNode := IpAddress([0,0,0,0]);\n        res := Some(TracerouteResult(hopNum, dummyNode, 0));\n    }\n    \n    method ProcessTraceroute(userInfo: UserInfo) returns (data: NetworkData)\n    {\n        var tracerouteMap: map<int, TracerouteResult> := map[];\n        var lastAddr := IpAddress([0, 0, 0, 0]);  \n        var hopNum := 1;\n        \n        \n        while hopNum <= MAX_HOPS\n        {\n            var result := TracerouteHop(hopNum, userInfo.ip);\n            \n            if result.None? {\n                break;\n            }\n            \n            if result.value.node == lastAddr {\n                break;\n            }\n            \n            tracerouteMap := tracerouteMap[hopNum := result.value];\n            lastAddr := result.value.node;\n            hopNum := hopNum + 1;\n        }\n        \n        return NetworkData(userInfo, tracerouteMap);\n    }\n    \n    method SaveNetworkData(data: NetworkData) returns (success: bool)\n    {\n        \n        return true;\n    }\n    \n    method ProcessConnection(userInfo: UserInfo) returns (success: bool)\n    {\n        var networkData := ProcessTraceroute(userInfo);\n        success := SaveNetworkData(networkData);\n    }\n}", "output": "datatype IpAddress = IpAddress(addr: seq<int>)\ndatatype TracerouteResult = TracerouteResult(hopNum: int, node: IpAddress, rtt: int)\ndatatype UserInfo = UserInfo(userId: string, timestamp: string, ip: IpAddress)\ndatatype NetworkData = NetworkData(userInfo: UserInfo, traceroute: map<int, TracerouteResult>)\ndatatype Option<T> = Some(value: T) | None\nclass NetworkProcessor {\n    \n    const MAX_HOPS: int := 30\n    \n    method TracerouteHop(hopNum: int, targetIp: IpAddress) returns (res: Option<TracerouteResult>)\n        requires 0 < hopNum <= MAX_HOPS\n        ensures res.Some? ==> res.value.hopNum == hopNum\n    {\n        \n        \n        var dummyNode := IpAddress([0,0,0,0]);\n        res := Some(TracerouteResult(hopNum, dummyNode, 0));\n    }\n    \n    method ProcessTraceroute(userInfo: UserInfo) returns (data: NetworkData)\n        requires |userInfo.ip.addr| == 4  \n        ensures data.userInfo == userInfo\n        ensures forall i :: i in data.traceroute ==> 0 < i <= MAX_HOPS\n    {\n        var tracerouteMap: map<int, TracerouteResult> := map[];\n        var lastAddr := IpAddress([0, 0, 0, 0]);  \n        var hopNum := 1;\n        \n        \n        while hopNum <= MAX_HOPS\n            invariant 0 < hopNum <= MAX_HOPS + 1\n            invariant forall i :: i in tracerouteMap ==> 0 < i < hopNum\n            decreases MAX_HOPS - hopNum + 1\n        {\n            var result := TracerouteHop(hopNum, userInfo.ip);\n            \n            if result.None? {\n                break;\n            }\n            \n            if result.value.node == lastAddr {\n                break;\n            }\n            \n            tracerouteMap := tracerouteMap[hopNum := result.value];\n            lastAddr := result.value.node;\n            hopNum := hopNum + 1;\n        }\n        \n        return NetworkData(userInfo, tracerouteMap);\n    }\n    \n    method SaveNetworkData(data: NetworkData) returns (success: bool)\n        ensures success ==> true  \n    {\n        \n        return true;\n    }\n    \n    method ProcessConnection(userInfo: UserInfo) returns (success: bool)\n        requires |userInfo.ip.addr| == 4\n        ensures success ==> true\n    {\n        var networkData := ProcessTraceroute(userInfo);\n        success := SaveNetworkData(networkData);\n    }\n}", "name": "py2dfy_375", "id": 375}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Configuration {\n  \n  var secretKey: string\n  var debug: bool\n  var templateDebug: bool  \n  var allowedHosts: seq<string>\n  \n  \n  var celeryEagerPropagatesExceptions: bool\n  var celeryAlwaysEager: bool\n  var brokerBackend: string\n  \n  \n  var transferToLogin: string\n  var transferToToken: string\n  var transferToApiKey: string\n  var transferToApiSecret: string\n  \n  \n  var rabbitMqInterface: string\n  \n  constructor()\n  {\n    secretKey := \"TESTSEKRET\";\n    debug := true;\n    templateDebug := true;\n    brokerBackend := \"memory\";\n    allowedHosts := [];\n  }\n  \n  method ParseAllowedHosts(envHosts: string) returns (result: seq<string>)\n  {\n    var hosts: seq<string> := [];\n    \n    \n    var envHostsList := SplitString(envHosts, ',');\n    \n    \n    hosts := envHostsList;\n    \n    \n    hosts := hosts + [\"localhost\", \".localhost\", \"127.0.0.1\", \"0.0.0.0\"];\n    \n    return hosts;\n  }\n  \n  method SplitString(s: string, delimiter: char) returns (result: seq<string>)\n  {\n    \n    result := [];\n  }\n  \n  method ValidateConfiguration() returns (isValid: bool)\n  {\n    isValid := true;\n    \n    \n    if secretKey == \"\" {\n      isValid := false;\n      return;\n    }\n    \n    \n    if |allowedHosts| == 0 {\n      isValid := false;\n      return;\n    }\n    \n    return isValid;\n  }\n}", "output": "class Configuration {\n  \n  var secretKey: string\n  var debug: bool\n  var templateDebug: bool  \n  var allowedHosts: seq<string>\n  \n  \n  var celeryEagerPropagatesExceptions: bool\n  var celeryAlwaysEager: bool\n  var brokerBackend: string\n  \n  \n  var transferToLogin: string\n  var transferToToken: string\n  var transferToApiKey: string\n  var transferToApiSecret: string\n  \n  \n  var rabbitMqInterface: string\n  \n  constructor()\n    ensures secretKey == \"TESTSEKRET\"\n    ensures debug == true\n    ensures templateDebug == true\n    ensures brokerBackend == \"memory\"\n  {\n    secretKey := \"TESTSEKRET\";\n    debug := true;\n    templateDebug := true;\n    brokerBackend := \"memory\";\n    allowedHosts := [];\n  }\n  \n  method ParseAllowedHosts(envHosts: string) returns (result: seq<string>)\n    requires |envHosts| >= 0\n    ensures |result| >= 4  \n    ensures \"localhost\" in result\n    ensures \".localhost\" in result\n    ensures \"127.0.0.1\" in result\n    ensures \"0.0.0.0\" in result\n  {\n    var hosts: seq<string> := [];\n    \n    \n    var envHostsList := SplitString(envHosts, ',');\n    \n    \n    hosts := envHostsList;\n    \n    \n    hosts := hosts + [\"localhost\", \".localhost\", \"127.0.0.1\", \"0.0.0.0\"];\n    \n    return hosts;\n  }\n  \n  method SplitString(s: string, delimiter: char) returns (result: seq<string>)\n    requires |s| >= 0\n    ensures |result| >= 0\n  {\n    \n    result := [];\n  }\n  \n  method ValidateConfiguration() returns (isValid: bool)\n    requires |secretKey| >= 0\n    requires |rabbitMqInterface| >= 0\n    ensures isValid ==> secretKey != \"\"  \n    ensures isValid ==> |allowedHosts| > 0  \n  {\n    isValid := true;\n    \n    \n    if secretKey == \"\" {\n      isValid := false;\n      return;\n    }\n    \n    \n    if |allowedHosts| == 0 {\n      isValid := false;\n      return;\n    }\n    \n    return isValid;\n  }\n}", "name": "py2dfy_377", "id": 377}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}\nmethod print_array(a:array<int>)\n{\n  for i:= 0 to a.Length{\n    print(a[i]);\n  }\n  print(\";\");\n}\nmethod TestMethod(){\n  var a1 := new int[3][1,2,3];\n  var b1 := new int[3][4,5,6];\n  var test1 := concat(a1, b1);\n  \n  print_array(test1);\n  var a2 := new int[3][-1,-2,-3];\n  var b2 := new int[3][-4,-5,-6];\n  var test2 := concat(a2, b2);\n  print_array(test2);\n  \n  var a3 := new int[0][];\n  var b3 := new int[3][7,8,9];\n  var test3 := concat(a3, b3);\n  print_array(test3);\n  \n  var a4 := new int[2][10,11];\n  var b4 := new int[0][];\n  var test4 := concat(a4, b4);\n  print_array(test4);\n  \n  var a5 := new int[0][];\n  var b5 := new int[0][];\n  var test5 := concat(a5, b5);\n  print_array(test5);\n  \n}\nmethod Main(){\n  TestMethod();\n}", "output": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n  ensures a[..]+b[..]==c[..]\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n    invariant 0 <= i <= c.Length\n    invariant if i<a.Length then c[..i]==a[..i] else c[..i]==a[..]+b[..(i-a.Length)]\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}\nmethod print_array(a:array<int>)\n{\n  for i:= 0 to a.Length{\n    print(a[i]);\n  }\n  print(\";\");\n}\nmethod TestMethod(){\n  var a1 := new int[3][1,2,3];\n  var b1 := new int[3][4,5,6];\n  var test1 := concat(a1, b1);\n  \n  print_array(test1);\n  var a2 := new int[3][-1,-2,-3];\n  var b2 := new int[3][-4,-5,-6];\n  var test2 := concat(a2, b2);\n  print_array(test2);\n  \n  var a3 := new int[0][];\n  var b3 := new int[3][7,8,9];\n  var test3 := concat(a3, b3);\n  print_array(test3);\n  \n  var a4 := new int[2][10,11];\n  var b4 := new int[0][];\n  var test4 := concat(a4, b4);\n  print_array(test4);\n  \n  var a5 := new int[0][];\n  var b5 := new int[0][];\n  var test5 := concat(a5, b5);\n  print_array(test5);\n  \n}\nmethod Main(){\n  TestMethod();\n}", "name": "py2dfy_365", "id": 365}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Somar(a: int, b: int, c: int := 0)\n  \n{\n  var res := a + b + c;\n  print res, \"\\n\";\n}\nmethod Main() {\n  Somar(6, 9);  \n}", "output": "method Somar(a: int, b: int, c: int := 0)\n  \n  ensures true  \n{\n  var res := a + b + c;\n  print res, \"\\n\";\n}\nmethod Main() {\n  Somar(6, 9);  \n}", "name": "py2dfy_382", "id": 382}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype PathComponent = \n  | Static(value: string)\n  | Parameter(name: string, typ: string)\nclass UrlPattern {\n  var components: seq<PathComponent>\n  var viewName: string\n  \n  constructor(comps: seq<PathComponent>, view: string)\n  {\n    components := comps;\n    viewName := view;\n  }\n}\nclass UrlRouter {\n  var patterns: seq<UrlPattern>\n  \n  constructor()\n  {\n    patterns := [];\n  }\n  \n  method AddPattern(pattern: UrlPattern)\n  {\n    patterns := patterns + [pattern];\n  }\n  \n  method MatchPath(path: seq<string>) returns (matchFound: bool, viewName: string)\n  {\n    var i := 0;\n    matchFound := false;\n    viewName := \"\";\n    \n    while i < |patterns|\n    {\n      var matches := PathMatchesPattern(patterns[i], path);\n      if matches {\n        matchFound := true;\n        viewName := patterns[i].viewName;\n        return;\n      }\n      i := i + 1;\n    }\n  }\n  \n  predicate PathMatches(pattern: UrlPattern, path: seq<string>)\n  {\n    |pattern.components| == |path| &&\n    forall i :: 0 <= i < |path| ==>\n      match pattern.components[i]\n      case Static(v) => path[i] == v\n      case Parameter(_, _) => true\n  }\n  \n  method PathMatchesPattern(pattern: UrlPattern, path: seq<string>) returns (matches: bool)\n  {\n    if |pattern.components| != |path| {\n      matches := false;\n      return;\n    }\n    \n    var i := 0;\n    matches := true;\n    \n    while i < |path| && matches\n        match pattern.components[j]\n        case Static(v) => path[j] == v\n        case Parameter(_, _) => true\n    {\n      match pattern.components[i] {\n        case Static(v) => matches := path[i] == v;\n        case Parameter(_, _) => \n      }\n      i := i + 1;\n    }\n  }\n}", "output": "datatype PathComponent = \n  | Static(value: string)\n  | Parameter(name: string, typ: string)\nclass UrlPattern {\n  var components: seq<PathComponent>\n  var viewName: string\n  \n  constructor(comps: seq<PathComponent>, view: string)\n    ensures components == comps\n    ensures viewName == view\n  {\n    components := comps;\n    viewName := view;\n  }\n}\nclass UrlRouter {\n  var patterns: seq<UrlPattern>\n  \n  constructor()\n    ensures patterns == []\n  {\n    patterns := [];\n  }\n  \n  method AddPattern(pattern: UrlPattern)\n    modifies this\n    ensures patterns == old(patterns) + [pattern]\n    ensures |patterns| == |old(patterns)| + 1\n  {\n    patterns := patterns + [pattern];\n  }\n  \n  method MatchPath(path: seq<string>) returns (matchFound: bool, viewName: string)\n    ensures matchFound ==> exists p :: p in patterns && PathMatches(p, path)\n    ensures !matchFound ==> forall p :: p in patterns ==> !PathMatches(p, path)\n  {\n    var i := 0;\n    matchFound := false;\n    viewName := \"\";\n    \n    while i < |patterns|\n      invariant 0 <= i <= |patterns|\n      invariant forall j :: 0 <= j < i ==> !PathMatches(patterns[j], path)\n    {\n      var matches := PathMatchesPattern(patterns[i], path);\n      if matches {\n        matchFound := true;\n        viewName := patterns[i].viewName;\n        return;\n      }\n      i := i + 1;\n    }\n  }\n  \n  predicate PathMatches(pattern: UrlPattern, path: seq<string>)\n    reads pattern\n  {\n    |pattern.components| == |path| &&\n    forall i :: 0 <= i < |path| ==>\n      match pattern.components[i]\n      case Static(v) => path[i] == v\n      case Parameter(_, _) => true\n  }\n  \n  method PathMatchesPattern(pattern: UrlPattern, path: seq<string>) returns (matches: bool)\n    ensures matches <==> PathMatches(pattern, path)\n  {\n    if |pattern.components| != |path| {\n      matches := false;\n      return;\n    }\n    \n    var i := 0;\n    matches := true;\n    \n    while i < |path| && matches\n      invariant 0 <= i <= |path|\n      invariant matches <==> forall j :: 0 <= j < i ==>\n        match pattern.components[j]\n        case Static(v) => path[j] == v\n        case Parameter(_, _) => true\n    {\n      match pattern.components[i] {\n        case Static(v) => matches := path[i] == v;\n        case Parameter(_, _) => \n      }\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_352", "id": 352}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Document = Document(movingAverage: real)\ndatatype Query = Query(upperBound: real, lowerBound: real)\nclass Collection {\n  var documents: seq<Document>\n  constructor()\n  {\n    documents := [];\n  }\n  method CountDocuments(query: Query) returns (count: nat)\n  {\n    count := 0;\n    var i := 0;\n    \n    while i < |documents|\n    {\n      var oldCount := count;\n      var oldPrefix := documents[..i];\n      \n      if IsMatch(documents[i], query) {\n        count := count + 1;\n      }\n      i := i + 1;\n      \n      \n      \n      lemma_CountMatchingDistributes(oldPrefix, documents[i-1], query);\n             \n      \n             CountMatching(oldPrefix, query) + (if IsMatch(documents[i-1], query) then 1 else 0);\n             \n      \n      if IsMatch(documents[i-1], query) {\n      } else {\n      }\n    }\n  }\n  lemma lemma_CountMatchingDistributes(prefix: seq<Document>, doc: Document, query: Query)\n            CountMatching(prefix, query) + (if IsMatch(doc, query) then 1 else 0)\n  {\n    if |prefix| == 0 {\n    } else {\n      var first := prefix[0];\n      var rest := prefix[1..];\n      \n      lemma_CountMatchingDistributes(rest, doc, query);\n    }\n  }\n  function CountMatching(docs: seq<Document>, query: Query): nat\n  {\n    if |docs| == 0 then 0\n    else (if IsMatch(docs[0], query) then 1 else 0) + \n         CountMatching(docs[1..], query)\n  }\n  predicate IsMatch(doc: Document, query: Query)\n  {\n    doc.movingAverage > query.lowerBound && \n    doc.movingAverage < query.upperBound\n  }\n}\nmethod Main() \n{\n  var collection := new Collection();\n  \n  print \"Enter Highest Value: \";\n  var high: real :| true;\n  \n  print \"Enter Lowest Value: \";\n  var low: real :| true;\n  \n  if low < high {\n    var query := Query(high, low);\n    var count := collection.CountDocuments(query);\n    print \"Value of Documents: \", count, \" Documents\\n\";\n  } else {\n    print \"Invalid input: lowest value must be less than highest value\\n\";\n  }\n}", "output": "datatype Document = Document(movingAverage: real)\ndatatype Query = Query(upperBound: real, lowerBound: real)\nclass Collection {\n  var documents: seq<Document>\n  constructor()\n    ensures documents == []\n  {\n    documents := [];\n  }\n  method CountDocuments(query: Query) returns (count: nat)\n    ensures count <= |documents|\n    ensures count == CountMatching(documents, query)\n  {\n    count := 0;\n    var i := 0;\n    \n    while i < |documents|\n      invariant 0 <= i <= |documents|\n      invariant count == CountMatching(documents[..i], query)\n      invariant count <= i\n      decreases |documents| - i\n    {\n      var oldCount := count;\n      var oldPrefix := documents[..i];\n      \n      if IsMatch(documents[i], query) {\n        count := count + 1;\n      }\n      i := i + 1;\n      \n      assert documents[..i] == oldPrefix + [documents[i-1]];\n      \n      \n      lemma_CountMatchingDistributes(oldPrefix, documents[i-1], query);\n             \n      \n      assert CountMatching(documents[..i], query) == \n             CountMatching(oldPrefix, query) + (if IsMatch(documents[i-1], query) then 1 else 0);\n             \n      \n      if IsMatch(documents[i-1], query) {\n        assert count == oldCount + 1;\n        assert oldCount == CountMatching(oldPrefix, query);\n      } else {\n        assert count == oldCount;\n        assert oldCount == CountMatching(oldPrefix, query);\n      }\n    }\n    assert documents[..|documents|] == documents;\n  }\n  lemma lemma_CountMatchingDistributes(prefix: seq<Document>, doc: Document, query: Query)\n    ensures CountMatching(prefix + [doc], query) == \n            CountMatching(prefix, query) + (if IsMatch(doc, query) then 1 else 0)\n    decreases |prefix|\n  {\n    if |prefix| == 0 {\n      assert prefix + [doc] == [doc];\n    } else {\n      var first := prefix[0];\n      var rest := prefix[1..];\n      assert prefix == [first] + rest;\n      assert prefix + [doc] == [first] + (rest + [doc]);\n      \n      lemma_CountMatchingDistributes(rest, doc, query);\n    }\n  }\n  function CountMatching(docs: seq<Document>, query: Query): nat\n    decreases |docs|\n  {\n    if |docs| == 0 then 0\n    else (if IsMatch(docs[0], query) then 1 else 0) + \n         CountMatching(docs[1..], query)\n  }\n  predicate IsMatch(doc: Document, query: Query)\n  {\n    doc.movingAverage > query.lowerBound && \n    doc.movingAverage < query.upperBound\n  }\n}\nmethod Main() \n{\n  var collection := new Collection();\n  \n  print \"Enter Highest Value: \";\n  var high: real :| true;\n  \n  print \"Enter Lowest Value: \";\n  var low: real :| true;\n  \n  if low < high {\n    var query := Query(high, low);\n    var count := collection.CountDocuments(query);\n    print \"Value of Documents: \", count, \" Documents\\n\";\n  } else {\n    print \"Invalid input: lowest value must be less than highest value\\n\";\n  }\n}", "name": "py2dfy_373", "id": 373}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Card {\n  var name: string\n  var phone: string  \n  var email: string\n  constructor(n: string, p: string, e: string)\n  {\n    name := n;\n    phone := p;\n    email := e;\n  }\n}\nclass CardSystem {\n  var cards: seq<Card>\n  constructor()\n  {\n    cards := [];\n  }\n  \n  method PrintTitle()\n  {\n    print \"1. Add new card\\n\";\n    print \"2. Show all cards\\n\";\n    print \"3. Search cards\\n\";\n    print \"0. Exit\\n\";\n  }\n  \n  method AddCard(name: string, phone: string, email: string)\n  {\n    var newCard := new Card(name, phone, email);\n    cards := cards + [newCard];\n  }\n  \n  method ShowAll()\n  {\n    var i := 0;\n    while i < |cards|\n    {\n      print \"Name: \", cards[i].name, \"\\n\";\n      print \"Phone: \", cards[i].phone, \"\\n\";\n      print \"Email: \", cards[i].email, \"\\n\";\n      print \"---------------\\n\";\n      i := i + 1;\n    }\n  }\n  \n  method SearchCard(searchName: string) returns (found: bool)\n  {\n    var i := 0;\n    while i < |cards|\n    {\n      if cards[i].name == searchName {\n        print \"Found card:\\n\";\n        print \"Name: \", cards[i].name, \"\\n\";\n        print \"Phone: \", cards[i].phone, \"\\n\";\n        print \"Email: \", cards[i].email, \"\\n\";\n        return true;\n      }\n      i := i + 1;\n    }\n    return false;\n  }\n  \n  method RunSystem()\n  {\n    var running := true;\n    var fuel := 1000; \n    \n    while running && fuel > 0  \n    {\n      PrintTitle();\n      print \"Please enter your choice: \";\n      var choice := ReadInput();\n      \n      fuel := fuel - 1;  \n      match choice {\n        case \"1\" =>\n          print \"Enter name: \";\n          var name := ReadInput();\n          print \"Enter phone: \";\n          var phone := ReadInput();\n          print \"Enter email: \";\n          var email := ReadInput();\n          AddCard(name, phone, email);\n        case \"2\" =>\n          ShowAll();\n        case \"3\" =>\n          print \"Enter name to search: \";\n          var searchName := ReadInput();\n          var _ := SearchCard(searchName);\n        case \"0\" =>\n          running := false;\n        case _ =>\n          print \"Invalid choice, please try again\\n\";\n      }\n    }\n  }\n  \n  method ReadInput() returns (input: string)\n}", "output": "class Card {\n  var name: string\n  var phone: string  \n  var email: string\n  constructor(n: string, p: string, e: string)\n    ensures name == n && phone == p && email == e\n  {\n    name := n;\n    phone := p;\n    email := e;\n  }\n}\nclass CardSystem {\n  var cards: seq<Card>\n  constructor()\n    ensures cards == []\n  {\n    cards := [];\n  }\n  \n  method PrintTitle()\n  {\n    print \"1. Add new card\\n\";\n    print \"2. Show all cards\\n\";\n    print \"3. Search cards\\n\";\n    print \"0. Exit\\n\";\n  }\n  \n  method AddCard(name: string, phone: string, email: string)\n    modifies this\n    ensures |cards| == old(|cards|) + 1\n    ensures cards[|cards|-1].name == name\n    ensures cards[|cards|-1].phone == phone \n    ensures cards[|cards|-1].email == email\n    ensures forall i :: 0 <= i < old(|cards|) ==> cards[i] == old(cards[i])\n  {\n    var newCard := new Card(name, phone, email);\n    cards := cards + [newCard];\n  }\n  \n  method ShowAll()\n  {\n    var i := 0;\n    while i < |cards|\n      invariant 0 <= i <= |cards|\n    {\n      print \"Name: \", cards[i].name, \"\\n\";\n      print \"Phone: \", cards[i].phone, \"\\n\";\n      print \"Email: \", cards[i].email, \"\\n\";\n      print \"---------------\\n\";\n      i := i + 1;\n    }\n  }\n  \n  method SearchCard(searchName: string) returns (found: bool)\n    ensures found ==> exists i :: 0 <= i < |cards| && cards[i].name == searchName\n    ensures !found ==> forall i :: 0 <= i < |cards| ==> cards[i].name != searchName\n  {\n    var i := 0;\n    while i < |cards|\n      invariant 0 <= i <= |cards|\n      invariant forall k :: 0 <= k < i ==> cards[k].name != searchName\n    {\n      if cards[i].name == searchName {\n        print \"Found card:\\n\";\n        print \"Name: \", cards[i].name, \"\\n\";\n        print \"Phone: \", cards[i].phone, \"\\n\";\n        print \"Email: \", cards[i].email, \"\\n\";\n        return true;\n      }\n      i := i + 1;\n    }\n    return false;\n  }\n  \n  method RunSystem()\n    modifies this\n  {\n    var running := true;\n    var fuel := 1000; \n    \n    while running && fuel > 0  \n      decreases fuel  \n      invariant fuel >= 0\n    {\n      PrintTitle();\n      print \"Please enter your choice: \";\n      var choice := ReadInput();\n      \n      fuel := fuel - 1;  \n      match choice {\n        case \"1\" =>\n          print \"Enter name: \";\n          var name := ReadInput();\n          print \"Enter phone: \";\n          var phone := ReadInput();\n          print \"Enter email: \";\n          var email := ReadInput();\n          AddCard(name, phone, email);\n        case \"2\" =>\n          ShowAll();\n        case \"3\" =>\n          print \"Enter name to search: \";\n          var searchName := ReadInput();\n          var _ := SearchCard(searchName);\n        case \"0\" =>\n          running := false;\n        case _ =>\n          print \"Invalid choice, please try again\\n\";\n      }\n    }\n  }\n  \n  method ReadInput() returns (input: string)\n}", "name": "py2dfy_351", "id": 351}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module SparkifyDB {\n  \n  datatype Schema = Schema(name: string)\n  datatype Table = Table(name: string, columns: seq<Column>)\n  datatype Column = Column(name: string, dataType: DataType, constraints: seq<Constraint>)\n  datatype DataType = Int | Text | Timestamp | Double\n  datatype Constraint = PrimaryKey | NotNull | Unique\n  \n  class DatabaseConnection {\n    var isConnected: bool\n    var currentSchema: Schema\n    var tables: map<string, Table>\n    constructor()\n    {\n      isConnected := false;\n      tables := map[];\n    }\n    \n    method CreateSchema(schemaName: string) returns (success: bool)\n    {\n      currentSchema := Schema(schemaName);\n      success := true;\n    }\n    \n    method DropTable(tableName: string) returns (success: bool)\n    {\n      if tableName in tables {\n        tables := map k | k in tables && k != tableName :: tables[k];\n        success := true;\n      } else {\n        success := false;\n      }\n    }\n    \n    method CreateTable(tableName: string, columns: seq<Column>) returns (success: bool)\n    {\n      if tableName !in tables {\n        tables := tables[tableName := Table(tableName, columns)];\n        success := true;\n      } else {\n        success := false;\n      }\n    }\n    \n    predicate ValidTable(table: Table)\n    {\n      && table.name != \"\"\n      && |table.columns| > 0\n      && forall c :: c in table.columns ==> c.name != \"\"\n    }\n    \n    predicate ValidDatabase()\n    {\n      forall tableName :: tableName in tables ==> ValidTable(tables[tableName])\n    }\n  }\n  \n  method InitializeDatabase() returns (db: DatabaseConnection)\n  {\n    db := new DatabaseConnection();\n    return db;\n  }\n}", "output": "module SparkifyDB {\n  \n  datatype Schema = Schema(name: string)\n  datatype Table = Table(name: string, columns: seq<Column>)\n  datatype Column = Column(name: string, dataType: DataType, constraints: seq<Constraint>)\n  datatype DataType = Int | Text | Timestamp | Double\n  datatype Constraint = PrimaryKey | NotNull | Unique\n  \n  class DatabaseConnection {\n    var isConnected: bool\n    var currentSchema: Schema\n    var tables: map<string, Table>\n    constructor()\n      ensures isConnected == false\n      ensures tables == map[]\n    {\n      isConnected := false;\n      tables := map[];\n    }\n    \n    method CreateSchema(schemaName: string) returns (success: bool)\n      modifies this\n      requires schemaName != \"\"\n      ensures success ==> currentSchema.name == schemaName\n      ensures !success ==> old(currentSchema) == currentSchema\n    {\n      currentSchema := Schema(schemaName);\n      success := true;\n    }\n    \n    method DropTable(tableName: string) returns (success: bool)\n      modifies this\n      requires tableName != \"\"\n      ensures success ==> tableName !in tables\n      ensures !success ==> tables == old(tables)\n    {\n      if tableName in tables {\n        tables := map k | k in tables && k != tableName :: tables[k];\n        success := true;\n      } else {\n        success := false;\n      }\n    }\n    \n    method CreateTable(tableName: string, columns: seq<Column>) returns (success: bool)\n      modifies this\n      requires tableName != \"\"\n      requires |columns| > 0\n      ensures success ==> tableName in tables\n      ensures success ==> tables[tableName].columns == columns\n    {\n      if tableName !in tables {\n        tables := tables[tableName := Table(tableName, columns)];\n        success := true;\n      } else {\n        success := false;\n      }\n    }\n    \n    predicate ValidTable(table: Table)\n    {\n      && table.name != \"\"\n      && |table.columns| > 0\n      && forall c :: c in table.columns ==> c.name != \"\"\n    }\n    \n    predicate ValidDatabase()\n      reads this\n    {\n      forall tableName :: tableName in tables ==> ValidTable(tables[tableName])\n    }\n  }\n  \n  method InitializeDatabase() returns (db: DatabaseConnection)\n    ensures fresh(db)\n    ensures db.isConnected == false\n    ensures db.tables == map[]\n  {\n    db := new DatabaseConnection();\n    return db;\n  }\n}", "name": "py2dfy_363", "id": 363}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Command = ON | OFF | LEVEL(value: int)\ntrait InsteonMessage {\n    var data: seq<int>\n    var length: int\n    \n    ghost var Valid: bool\n    \n    method Init(code: int, len: int)\n    {\n        data := [];\n        length := len;\n        Valid := true;\n    }\n    \n    method AppendData(value: int)\n    {\n        data := data + [value];\n    }\n    \n    method GetData() returns (result: seq<int>)\n    {\n        return data;\n    }\n    \n    method GetLength() returns (result: int)\n    {\n        return length;\n    }\n    \n    method IsComplete() returns (result: bool)\n    {\n        return |data| == length;\n    }\n}\nfunction ByteIdToStringId(idHigh: int, idMid: int, idLow: int): string\n{\n    Format2Digits(idHigh) + \".\" + Format2Digits(idMid) + \".\" + Format2Digits(idLow)\n}\nfunction Format2Digits(n: int): string\n{\n    if n < 16 then\n        \"0\" + IntToString(n)\n    else\n        IntToString(n)\n}\nfunction IntToString(n: int): string\nclass InsteonExtendedMessage extends InsteonMessage {\n    constructor()\n    {\n        data := [];\n        length := 25;\n        Valid := true;\n    }\n    \n    method GetCommands() returns (commands: seq<(Command, string)>)\n    {\n        var ledState := data[21];\n        commands := [];\n        var address := ByteIdToStringId(data[2], data[3], data[4]);\n        \n        var i := 0;\n        while i < 8\n                commands[j].0 in {Command.ON, Command.OFF}\n        {\n            var cmd := if ((ledState as bv8 & (1 as bv8 << (i as bv8))) != 0 as bv8) then Command.ON else Command.OFF;\n            var addr := address + \":\" + Format2Digits(i + 1);\n            commands := commands + [(cmd, addr)];\n            i := i + 1;\n        }\n    }\n}", "output": "datatype Command = ON | OFF | LEVEL(value: int)\ntrait InsteonMessage {\n    var data: seq<int>\n    var length: int\n    \n    ghost var Valid: bool\n    \n    method Init(code: int, len: int)\n        requires len > 0\n        modifies this\n        ensures data == []\n        ensures length == len\n        ensures Valid\n    {\n        data := [];\n        length := len;\n        Valid := true;\n    }\n    \n    method AppendData(value: int)\n        requires Valid\n        requires 0 <= value < 256  \n        modifies this\n        ensures data == old(data) + [value]\n        ensures length == old(length)\n        ensures Valid\n    {\n        data := data + [value];\n    }\n    \n    method GetData() returns (result: seq<int>)\n        requires Valid\n        ensures result == data\n    {\n        return data;\n    }\n    \n    method GetLength() returns (result: int)\n        requires Valid\n        ensures result == length\n    {\n        return length;\n    }\n    \n    method IsComplete() returns (result: bool)\n        requires Valid\n        ensures result == (|data| == length)\n    {\n        return |data| == length;\n    }\n}\nfunction ByteIdToStringId(idHigh: int, idMid: int, idLow: int): string\n    requires 0 <= idHigh < 256\n    requires 0 <= idMid < 256\n    requires 0 <= idLow < 256\n{\n    Format2Digits(idHigh) + \".\" + Format2Digits(idMid) + \".\" + Format2Digits(idLow)\n}\nfunction Format2Digits(n: int): string\n    requires 0 <= n < 256\n{\n    if n < 16 then\n        \"0\" + IntToString(n)\n    else\n        IntToString(n)\n}\nfunction IntToString(n: int): string\n    requires 0 <= n < 256\nclass InsteonExtendedMessage extends InsteonMessage {\n    constructor()\n        ensures Valid\n        ensures length == 25\n        ensures data == []\n    {\n        data := [];\n        length := 25;\n        Valid := true;\n    }\n    \n    method GetCommands() returns (commands: seq<(Command, string)>)\n        requires Valid\n        requires |data| >= 22  \n        requires forall i :: 0 <= i < |data| ==> 0 <= data[i] < 256  \n        ensures |commands| <= 8  \n    {\n        var ledState := data[21];\n        commands := [];\n        var address := ByteIdToStringId(data[2], data[3], data[4]);\n        \n        var i := 0;\n        while i < 8\n            invariant 0 <= i <= 8\n            invariant |commands| == i\n            invariant forall j :: 0 <= j < i ==>\n                commands[j].0 in {Command.ON, Command.OFF}\n        {\n            var cmd := if ((ledState as bv8 & (1 as bv8 << (i as bv8))) != 0 as bv8) then Command.ON else Command.OFF;\n            var addr := address + \":\" + Format2Digits(i + 1);\n            commands := commands + [(cmd, addr)];\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_353", "id": 353}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Dependency = Dependency(name: string, version: string)\nclass PackageConfig {\n    \n    var name: string\n    var version: string\n    var description: string\n    var author: string\n    var dependencies: seq<Dependency>\n    \n    \n    predicate ValidState()\n    {\n        \n        |name| > 0 && \n        |version| > 0 &&\n        |author| > 0\n    }\n    \n    constructor Init(\n        pkgName: string, \n        pkgVersion: string, \n        pkgDesc: string, \n        pkgAuthor: string\n    )\n    {\n        name := pkgName;\n        version := pkgVersion;\n        description := pkgDesc;\n        author := pkgAuthor;\n        dependencies := [];\n    }\n    \n    method AddDependency(depName: string, depVersion: string)\n            dependencies[i] == old(dependencies[i])\n    {\n        dependencies := dependencies + [Dependency(depName, depVersion)];\n    }\n    \n    method GetDependencies() returns (deps: seq<Dependency>)\n    {\n        deps := dependencies;\n    }\n}\nmethod CreatePackageSetup() returns (config: PackageConfig)\n{\n    var pkgName := \"app\";\n    var pkgVersion := \"1.0.0\";\n    var pkgDesc := \"a simple speech to text converter\";\n    var pkgAuthor := \"Tim Gaspard\";\n    config := new PackageConfig.Init(pkgName, pkgVersion, pkgDesc, pkgAuthor);\n}", "output": "datatype Dependency = Dependency(name: string, version: string)\nclass PackageConfig {\n    \n    var name: string\n    var version: string\n    var description: string\n    var author: string\n    var dependencies: seq<Dependency>\n    \n    \n    predicate ValidState()\n    reads this\n    {\n        \n        |name| > 0 && \n        |version| > 0 &&\n        |author| > 0\n    }\n    \n    constructor Init(\n        pkgName: string, \n        pkgVersion: string, \n        pkgDesc: string, \n        pkgAuthor: string\n    )\n    requires |pkgName| > 0 && |pkgVersion| > 0 && |pkgAuthor| > 0\n    ensures ValidState()\n    ensures name == pkgName\n    ensures version == pkgVersion \n    ensures description == pkgDesc\n    ensures author == pkgAuthor\n    ensures dependencies == []\n    {\n        name := pkgName;\n        version := pkgVersion;\n        description := pkgDesc;\n        author := pkgAuthor;\n        dependencies := [];\n    }\n    \n    method AddDependency(depName: string, depVersion: string)\n    requires ValidState()\n    requires |depName| > 0 && |depVersion| > 0\n    modifies this\n    ensures ValidState()\n    ensures |dependencies| == old(|dependencies|) + 1\n    ensures dependencies[|dependencies|-1] == Dependency(depName, depVersion)\n    ensures forall i :: 0 <= i < old(|dependencies|) ==> \n            dependencies[i] == old(dependencies[i])\n    {\n        dependencies := dependencies + [Dependency(depName, depVersion)];\n    }\n    \n    method GetDependencies() returns (deps: seq<Dependency>)\n    requires ValidState()\n    ensures deps == dependencies\n    {\n        deps := dependencies;\n    }\n}\nmethod CreatePackageSetup() returns (config: PackageConfig)\nensures config.ValidState() \nensures config.name == \"app\"\nensures config.version == \"1.0.0\"\n{\n    var pkgName := \"app\";\n    var pkgVersion := \"1.0.0\";\n    var pkgDesc := \"a simple speech to text converter\";\n    var pkgAuthor := \"Tim Gaspard\";\n    config := new PackageConfig.Init(pkgName, pkgVersion, pkgDesc, pkgAuthor);\n    assert config.name == \"app\";  \n    assert config.version == \"1.0.0\"; \n}", "name": "py2dfy_368", "id": 368}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Image = Image(\n    width: nat,\n    height: nat,\n    channels: nat,\n    pixels: array3<real>\n)\ndatatype NetworkParameters = NetworkParams(\n    numBlocks: nat,\n    alpha: nat,\n    firstChannels: nat,\n    scale: nat\n)\nnewtype uint8 = x | 0 <= x <= 255\nclass ImageProcessor {\n    \n    method LoadParameters(configPath: string) returns (params: NetworkParameters)\n    {\n        \n        params := NetworkParams(1, 1, 64, 2);\n    }\n    \n    method LoadImage(path: string) returns (img: Image)\n    {\n        \n        var pixels := new real[1, 1, 3];\n        return Image(1, 1, 3, pixels);\n    }\n    \n    method ProcessImage(img: Image, params: NetworkParameters) returns (output: Image)\n    {\n        var outputPixels := new real[img.height, img.width, 3];\n        \n        \n        output := Image(img.width, img.height, 3, outputPixels);\n    }\n    \n    method ClipToPixelRange(img: Image) returns (clipped: array3<uint8>)\n            (0 <= i < img.height && \n            0 <= j < img.width && \n            0 <= k < 3) ==> \n            0 <= clipped[i,j,k] <= 255\n    {\n        clipped := new uint8[img.height, img.width, 3];\n        \n        var i := 0;\n        while i < img.height\n                (0 <= x < i && \n                0 <= y < img.width && \n                0 <= z < 3) ==> \n                0 <= clipped[x,y,z] <= 255\n        {\n            var j := 0;\n            while j < img.width\n                    (0 <= x < i && \n                    0 <= y < img.width && \n                    0 <= z < 3) ==> \n                    0 <= clipped[x,y,z] <= 255\n                    (0 <= y < j && \n                    0 <= z < 3) ==> \n                    0 <= clipped[i,y,z] <= 255\n            {\n                var k := 0;\n                while k < 3\n                        (0 <= z < k) ==> \n                        0 <= clipped[i,j,z] <= 255\n                {\n                    var value := img.pixels[i,j,k];\n                    if value < 0.0 {\n                        clipped[i,j,k] := 0;\n                    } else if value > 255.0 {\n                        clipped[i,j,k] := 255;\n                    } else {\n                        clipped[i,j,k] := value.Floor as uint8;\n                    }\n                    k := k + 1;\n                }\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method ProcessImageFile(inputPath: string, configPath: string) returns (success: bool)\n    {\n        var params := LoadParameters(configPath);\n        var inputImage := LoadImage(inputPath);\n        var processedImage := ProcessImage(inputImage, params);\n        var clippedPixels := ClipToPixelRange(processedImage);\n        \n        \n        success := true;\n    }\n}", "output": "datatype Image = Image(\n    width: nat,\n    height: nat,\n    channels: nat,\n    pixels: array3<real>\n)\ndatatype NetworkParameters = NetworkParams(\n    numBlocks: nat,\n    alpha: nat,\n    firstChannels: nat,\n    scale: nat\n)\nnewtype uint8 = x | 0 <= x <= 255\nclass ImageProcessor {\n    \n    method LoadParameters(configPath: string) returns (params: NetworkParameters)\n        requires configPath != \"\"\n        ensures params.numBlocks > 0\n        ensures params.alpha > 0\n        ensures params.firstChannels > 0\n        ensures params.scale > 0\n    {\n        \n        params := NetworkParams(1, 1, 64, 2);\n    }\n    \n    method LoadImage(path: string) returns (img: Image)\n        requires path != \"\"\n        ensures img.width > 0 && img.height > 0 && img.channels == 3\n        ensures img.pixels.Length0 == img.height\n        ensures img.pixels.Length1 == img.width\n        ensures img.pixels.Length2 == img.channels\n    {\n        \n        var pixels := new real[1, 1, 3];\n        return Image(1, 1, 3, pixels);\n    }\n    \n    method ProcessImage(img: Image, params: NetworkParameters) returns (output: Image)\n        requires img.channels == 3\n        requires img.width > 0 && img.height > 0\n        requires params.numBlocks > 0\n        ensures output.width == img.width\n        ensures output.height == img.height\n        ensures output.channels == 3\n        ensures output.pixels.Length0 == img.height\n        ensures output.pixels.Length1 == img.width\n        ensures output.pixels.Length2 == 3\n    {\n        var outputPixels := new real[img.height, img.width, 3];\n        \n        \n        output := Image(img.width, img.height, 3, outputPixels);\n    }\n    \n    method ClipToPixelRange(img: Image) returns (clipped: array3<uint8>)\n        requires img.width > 0 && img.height > 0\n        requires img.channels == 3\n        requires img.pixels.Length0 == img.height\n        requires img.pixels.Length1 == img.width\n        requires img.pixels.Length2 == 3\n        ensures fresh(clipped)\n        ensures clipped.Length0 == img.height\n        ensures clipped.Length1 == img.width\n        ensures clipped.Length2 == 3\n        ensures forall i, j, k :: \n            (0 <= i < img.height && \n            0 <= j < img.width && \n            0 <= k < 3) ==> \n            0 <= clipped[i,j,k] <= 255\n    {\n        clipped := new uint8[img.height, img.width, 3];\n        \n        var i := 0;\n        while i < img.height\n            invariant 0 <= i <= img.height\n            invariant clipped.Length0 == img.height\n            invariant clipped.Length1 == img.width\n            invariant clipped.Length2 == 3\n            invariant forall x, y, z :: \n                (0 <= x < i && \n                0 <= y < img.width && \n                0 <= z < 3) ==> \n                0 <= clipped[x,y,z] <= 255\n        {\n            var j := 0;\n            while j < img.width\n                invariant 0 <= j <= img.width\n                invariant 0 <= i < img.height\n                invariant forall x, y, z :: \n                    (0 <= x < i && \n                    0 <= y < img.width && \n                    0 <= z < 3) ==> \n                    0 <= clipped[x,y,z] <= 255\n                invariant forall y, z :: \n                    (0 <= y < j && \n                    0 <= z < 3) ==> \n                    0 <= clipped[i,y,z] <= 255\n            {\n                var k := 0;\n                while k < 3\n                    invariant 0 <= k <= 3\n                    invariant 0 <= i < img.height\n                    invariant 0 <= j < img.width\n                    invariant forall z :: \n                        (0 <= z < k) ==> \n                        0 <= clipped[i,j,z] <= 255\n                {\n                    var value := img.pixels[i,j,k];\n                    if value < 0.0 {\n                        clipped[i,j,k] := 0;\n                    } else if value > 255.0 {\n                        clipped[i,j,k] := 255;\n                    } else {\n                        clipped[i,j,k] := value.Floor as uint8;\n                    }\n                    k := k + 1;\n                }\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n    }\n    \n    method ProcessImageFile(inputPath: string, configPath: string) returns (success: bool)\n        requires inputPath != \"\"\n        requires configPath != \"\"\n        ensures success ==> true  \n    {\n        var params := LoadParameters(configPath);\n        var inputImage := LoadImage(inputPath);\n        var processedImage := ProcessImage(inputImage, params);\n        var clippedPixels := ClipToPixelRange(processedImage);\n        \n        \n        success := true;\n    }\n}", "name": "py2dfy_344", "id": 344}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = Some(value: T) | None\nclass MockRedis {\n  \n  var redis: map<seq<int>, seq<int>>\n  \n  var hashMaps: map<seq<int>, map<seq<int>, seq<int>>>\n  constructor()\n  {\n    redis := map[];\n    hashMaps := map[];\n  }\n  \n  method Get(key: seq<int>) returns (value: Option<seq<int>>)\n  {\n    if key in redis {\n      return Some(redis[key]);\n    }\n    return None;\n  }\n  method Set(key: seq<int>, value: seq<int>) returns (success: bool)\n  {\n    redis := redis[key := value];\n    return true;\n  }\n  method Delete(key: seq<int>) returns (count: nat)\n  {\n    if key in redis {\n      redis := map k | k in redis && k != key :: redis[k];\n      return 1;\n    }\n    return 0;\n  }\n  \n  method HGet(key: seq<int>, field: seq<int>) returns (value: Option<seq<int>>)\n    value == Some(hashMaps[key][field])\n    value == None\n  {\n    if key in hashMaps && field in hashMaps[key] {\n      return Some(hashMaps[key][field]);\n    }\n    return None;\n  }\n  method HSet(key: seq<int>, field: seq<int>, value: seq<int>) returns (created: bool)\n  {\n    var fieldExists := key in hashMaps && field in hashMaps[key];\n    \n    if key !in hashMaps {\n      hashMaps := hashMaps[key := map[]];\n    }\n    \n    var hashMap := hashMaps[key];\n    hashMap := hashMap[field := value];\n    hashMaps := hashMaps[key := hashMap];\n    \n    return !fieldExists;\n  }\n  predicate Valid()\n  {\n    true  \n  }\n}", "output": "datatype Option<T> = Some(value: T) | None\nclass MockRedis {\n  \n  var redis: map<seq<int>, seq<int>>\n  \n  var hashMaps: map<seq<int>, map<seq<int>, seq<int>>>\n  constructor()\n  ensures fresh(this)\n  ensures redis == map[]\n  ensures hashMaps == map[]\n  {\n    redis := map[];\n    hashMaps := map[];\n  }\n  \n  method Get(key: seq<int>) returns (value: Option<seq<int>>)\n  requires Valid()\n  ensures Valid()\n  ensures key in redis ==> value == Some(redis[key])\n  ensures key !in redis ==> value == None\n  {\n    if key in redis {\n      return Some(redis[key]);\n    }\n    return None;\n  }\n  method Set(key: seq<int>, value: seq<int>) returns (success: bool)\n  requires Valid()\n  modifies this\n  ensures Valid()\n  ensures success\n  ensures redis == old(redis)[key := value]\n  ensures hashMaps == old(hashMaps)\n  {\n    redis := redis[key := value];\n    return true;\n  }\n  method Delete(key: seq<int>) returns (count: nat)\n  requires Valid()\n  modifies this\n  ensures Valid()\n  ensures count == (if key in old(redis) then 1 else 0)\n  ensures key in old(redis) ==> redis == map k | k in old(redis) && k != key :: old(redis)[k]\n  ensures key !in old(redis) ==> redis == old(redis)\n  ensures hashMaps == old(hashMaps)\n  {\n    if key in redis {\n      redis := map k | k in redis && k != key :: redis[k];\n      return 1;\n    }\n    return 0;\n  }\n  \n  method HGet(key: seq<int>, field: seq<int>) returns (value: Option<seq<int>>)\n  requires Valid()\n  ensures Valid()\n  ensures key in hashMaps && field in hashMaps[key] ==> \n    value == Some(hashMaps[key][field])\n  ensures (key !in hashMaps || field !in hashMaps[key]) ==>\n    value == None\n  {\n    if key in hashMaps && field in hashMaps[key] {\n      return Some(hashMaps[key][field]);\n    }\n    return None;\n  }\n  method HSet(key: seq<int>, field: seq<int>, value: seq<int>) returns (created: bool)\n  requires Valid()\n  modifies this\n  ensures Valid()\n  ensures key in hashMaps\n  ensures field in hashMaps[key]\n  ensures hashMaps[key][field] == value\n  ensures created == (old(key !in hashMaps || field !in hashMaps[key]))\n  ensures redis == old(redis)\n  {\n    var fieldExists := key in hashMaps && field in hashMaps[key];\n    \n    if key !in hashMaps {\n      hashMaps := hashMaps[key := map[]];\n    }\n    \n    var hashMap := hashMaps[key];\n    hashMap := hashMap[field := value];\n    hashMaps := hashMaps[key := hashMap];\n    \n    return !fieldExists;\n  }\n  predicate Valid()\n  reads this\n  {\n    true  \n  }\n}", "name": "py2dfy_355", "id": 355}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DataFrame {\n  var columns: array<string>  \n  var numColumns: nat         \n  \n  predicate Valid()\n  {\n    0 <= numColumns <= columns.Length\n  }\n  constructor(size: nat)\n  {\n    columns := new string[size];\n    numColumns := size;\n  }\n  \n  method RenameOlympicsColumns() returns (success: bool)\n  {\n    if numColumns < 15 { \n      return false;\n    }\n    \n    columns[0] := \"Country\";\n    \n    var newNames := [\"Gold_Summer\", \"Silver_Summer\", \"Bronze_Summer\", \n                     \"Total_Summer\", \"# Winter\", \"Gold_Winter\", \n                     \"Silver_Winter\", \"Bronze_Winter\", \"Total_Winter\",\n                     \"# Games\", \"Gold_Total\", \"Silver_Total\", \n                     \"Bronze_Total\", \"Total\"];\n    \n    var i := 0;\n    while i < |newNames| && i + 2 < numColumns\n                2 + k < numColumns ==> \n                columns[2 + k] == newNames[k]\n    {\n      columns[i + 2] := newNames[i];\n      i := i + 1;\n    }\n    return true;\n  }\n}", "output": "class DataFrame {\n  var columns: array<string>  \n  var numColumns: nat         \n  \n  predicate Valid()\n    reads this\n  {\n    0 <= numColumns <= columns.Length\n  }\n  constructor(size: nat)\n    ensures Valid()\n    ensures fresh(columns)\n    ensures columns.Length == size\n    ensures numColumns == size\n  {\n    columns := new string[size];\n    numColumns := size;\n  }\n  \n  method RenameOlympicsColumns() returns (success: bool)\n    requires Valid()\n    requires numColumns > 0  \n    modifies columns\n    ensures Valid()\n    ensures success ==> columns[0] == \"Country\"  \n    ensures old(columns.Length) == columns.Length \n  {\n    if numColumns < 15 { \n      return false;\n    }\n    \n    columns[0] := \"Country\";\n    \n    var newNames := [\"Gold_Summer\", \"Silver_Summer\", \"Bronze_Summer\", \n                     \"Total_Summer\", \"# Winter\", \"Gold_Winter\", \n                     \"Silver_Winter\", \"Bronze_Winter\", \"Total_Winter\",\n                     \"# Games\", \"Gold_Total\", \"Silver_Total\", \n                     \"Bronze_Total\", \"Total\"];\n    \n    var i := 0;\n    while i < |newNames| && i + 2 < numColumns\n      invariant 0 <= i <= |newNames|\n      invariant Valid()\n      invariant columns[0] == \"Country\"  \n      invariant forall k :: 0 <= k < i ==> \n                2 + k < numColumns ==> \n                columns[2 + k] == newNames[k]\n    {\n      columns[i + 2] := newNames[i];\n      i := i + 1;\n    }\n    return true;\n  }\n}", "name": "py2dfy_379", "id": 379}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Coord = Coord(x: int, y: int)\ndatatype Direction = Up | Down | Left | Right\ndatatype Option<T> = None | Some(value: T)\nclass Snake {\n  \n  var segments: seq<Coord>\n  \n  var direction: Direction\n  \n  var lastDirection: Direction\n  \n  var newSegment: Option<Coord>\n  \n  ghost predicate Valid()\n  {\n    \n    |segments| > 0 &&\n    \n    (newSegment.Some? ==> newSegment.value in segments)\n  }\n  constructor(startPos: Coord)\n  {\n    segments := [\n      startPos,\n      Coord(4, 5),\n      Coord(3, 5), \n      Coord(3, 4)\n    ];\n    direction := Direction.Right;\n    lastDirection := Direction.Right;\n    newSegment := None;\n  }\n  \n  function DirectionToCoord(d: Direction): Coord\n  {\n    match d\n    case Up => Coord(0, -1)\n    case Down => Coord(0, 1)\n    case Left => Coord(-1, 0)\n    case Right => Coord(1, 0)\n  }\n  \n  function AddCoord(a: Coord, b: Coord): Coord\n  {\n    Coord(a.x + b.x, a.y + b.y)\n  }\n  method Move()\n  {\n    var oldHead := segments[0];\n    var newHead := AddCoord(oldHead, DirectionToCoord(direction));\n    \n    \n    var newSegments := [newHead];\n    var i := 0;\n    while i < |segments| - 1\n    {\n      newSegments := newSegments + [segments[i]];\n      i := i + 1;\n    }\n    \n    segments := newSegments;\n    \n    if newSegment.Some? {\n      segments := segments + [newSegment.value];\n      newSegment := None;\n    }\n    \n    lastDirection := direction;\n  }\n  method ChangeDirection(newDir: Direction)\n  {\n    \n    match (lastDirection, newDir)\n    case (Up, Down) => return;\n    case (Down, Up) => return;\n    case (Left, Right) => return;\n    case (Right, Left) => return;\n    case _ => \n      direction := newDir;\n  }\n  \n  method Up()\n  {\n    ChangeDirection(Direction.Up);\n  }\n  method Down()\n  {\n    ChangeDirection(Direction.Down);\n  }\n  method Left()\n  {\n    ChangeDirection(Direction.Left);\n  }\n  method Right()\n  {\n    ChangeDirection(Direction.Right);\n  }\n}", "output": "datatype Coord = Coord(x: int, y: int)\ndatatype Direction = Up | Down | Left | Right\ndatatype Option<T> = None | Some(value: T)\nclass Snake {\n  \n  var segments: seq<Coord>\n  \n  var direction: Direction\n  \n  var lastDirection: Direction\n  \n  var newSegment: Option<Coord>\n  \n  ghost predicate Valid()\n    reads this\n  {\n    \n    |segments| > 0 &&\n    \n    (newSegment.Some? ==> newSegment.value in segments)\n  }\n  constructor(startPos: Coord)\n    ensures Valid()\n    ensures segments[0] == startPos\n    ensures |segments| == 4  \n    ensures direction == Direction.Right\n    ensures lastDirection == Direction.Right\n    ensures newSegment.None?\n  {\n    segments := [\n      startPos,\n      Coord(4, 5),\n      Coord(3, 5), \n      Coord(3, 4)\n    ];\n    direction := Direction.Right;\n    lastDirection := Direction.Right;\n    newSegment := None;\n  }\n  \n  function DirectionToCoord(d: Direction): Coord\n  {\n    match d\n    case Up => Coord(0, -1)\n    case Down => Coord(0, 1)\n    case Left => Coord(-1, 0)\n    case Right => Coord(1, 0)\n  }\n  \n  function AddCoord(a: Coord, b: Coord): Coord\n  {\n    Coord(a.x + b.x, a.y + b.y)\n  }\n  method Move()\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures |segments| >= old(|segments|)\n    ensures segments[0] == AddCoord(old(segments[0]), DirectionToCoord(old(direction)))\n  {\n    var oldHead := segments[0];\n    var newHead := AddCoord(oldHead, DirectionToCoord(direction));\n    \n    \n    var newSegments := [newHead];\n    var i := 0;\n    while i < |segments| - 1\n      invariant 0 <= i < |segments|\n      invariant |newSegments| == i + 1\n      invariant newSegments[0] == newHead\n    {\n      newSegments := newSegments + [segments[i]];\n      i := i + 1;\n    }\n    \n    segments := newSegments;\n    \n    if newSegment.Some? {\n      segments := segments + [newSegment.value];\n      newSegment := None;\n    }\n    \n    lastDirection := direction;\n  }\n  method ChangeDirection(newDir: Direction)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures segments == old(segments)\n    ensures newSegment == old(newSegment)\n  {\n    \n    match (lastDirection, newDir)\n    case (Up, Down) => return;\n    case (Down, Up) => return;\n    case (Left, Right) => return;\n    case (Right, Left) => return;\n    case _ => \n      direction := newDir;\n  }\n  \n  method Up()\n    requires Valid()\n    modifies this\n    ensures Valid()\n  {\n    ChangeDirection(Direction.Up);\n  }\n  method Down()\n    requires Valid()\n    modifies this\n    ensures Valid()\n  {\n    ChangeDirection(Direction.Down);\n  }\n  method Left()\n    requires Valid()\n    modifies this\n    ensures Valid()\n  {\n    ChangeDirection(Direction.Left);\n  }\n  method Right()\n    requires Valid()\n    modifies this\n    ensures Valid()\n  {\n    ChangeDirection(Direction.Right);\n  }\n}", "name": "py2dfy_369", "id": 369}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Option<T> = Some(value: T) | None\nmethod Main()\n{\n    var alp := \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    var idx := GetUserInput();\n    ProcessInput(alp, idx);\n    print \"程序执行完毕，不知道是否发生了异常\\n\";\n}\nmethod GetUserInput() returns (idx: int)\n{\n    print \"请输入一个整数: \";\n    var input := ReadInt();\n    if input.Some? {\n        idx := input.value;\n        if 0 <= idx < 26 {\n            return idx;\n        }\n    }\n    return -1; \n}\nmethod ProcessInput(alp: string, idx: int)\n{\n    if idx == -1 {\n        print \"输入错误，请输入一个整数\\n\";\n    } else if 0 <= idx < 26 {\n        print alp[idx], \"\\n\";\n        print \"没有发生错误\\n\";\n    } else {\n        print \"其他错误\\n\";\n    }\n}\nmethod ReadInt() returns (result: Option<int>)\n{\n    \n    \n    \n    \n    result := None; \n}", "output": "datatype Option<T> = Some(value: T) | None\nmethod Main()\n{\n    var alp := \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    var idx := GetUserInput();\n    ProcessInput(alp, idx);\n    print \"程序执行完毕，不知道是否发生了异常\\n\";\n}\nmethod GetUserInput() returns (idx: int)\n    ensures -1 <= idx <= 26\n{\n    print \"请输入一个整数: \";\n    var input := ReadInt();\n    if input.Some? {\n        idx := input.value;\n        if 0 <= idx < 26 {\n            return idx;\n        }\n    }\n    return -1; \n}\nmethod ProcessInput(alp: string, idx: int)\n    requires |alp| == 26\n    requires -1 <= idx <= 26\n{\n    if idx == -1 {\n        print \"输入错误，请输入一个整数\\n\";\n    } else if 0 <= idx < 26 {\n        print alp[idx], \"\\n\";\n        print \"没有发生错误\\n\";\n    } else {\n        print \"其他错误\\n\";\n    }\n}\nmethod ReadInt() returns (result: Option<int>)\n{\n    \n    \n    \n    \n    result := None; \n}", "name": "py2dfy_388", "id": 388}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module CDB {\n  datatype Result<T> = Some(value: T) | None\n  class KeyValuePair {\n    var key: seq<int>\n    var value: seq<int>\n    \n    constructor(k: seq<int>, v: seq<int>)\n    {\n      key := k;\n      value := v;\n    }\n  }\n  method CalcHash(input: seq<int>) returns (hash: int)\n  {\n    var h: bv32 := 5381;\n    var i := 0;\n    \n    while i < |input|\n    {\n      h := ((h * 32) + h) ^ (input[i] as bv32);\n      i := i + 1;\n    }\n    \n    return h as int;\n  }\n  method StringToBytes(s: string) returns (bytes: seq<int>)\n  {\n    bytes := [];\n    var i := 0;\n    while i < |s|\n    {\n      var charCode := (s[i] as bv32 & 0xFF) as int;  \n      bytes := bytes + [charCode];\n      i := i + 1;\n    }\n  }\n}", "output": "module CDB {\n  datatype Result<T> = Some(value: T) | None\n  class KeyValuePair {\n    var key: seq<int>\n    var value: seq<int>\n    \n    constructor(k: seq<int>, v: seq<int>)\n      ensures key == k && value == v\n    {\n      key := k;\n      value := v;\n    }\n  }\n  method CalcHash(input: seq<int>) returns (hash: int)\n    requires forall i :: 0 <= i < |input| ==> 0 <= input[i] < 256\n    ensures 0 <= hash < 0x1_0000_0000\n  {\n    var h: bv32 := 5381;\n    var i := 0;\n    \n    while i < |input|\n      invariant 0 <= i <= |input|\n      invariant 0 <= h as int < 0x1_0000_0000\n    {\n      h := ((h * 32) + h) ^ (input[i] as bv32);\n      i := i + 1;\n    }\n    \n    return h as int;\n  }\n  method StringToBytes(s: string) returns (bytes: seq<int>)\n    ensures |bytes| == |s|\n    ensures forall i :: 0 <= i < |bytes| ==> 0 <= bytes[i] < 256\n  {\n    bytes := [];\n    var i := 0;\n    while i < |s|\n      invariant 0 <= i <= |s|\n      invariant |bytes| == i\n      invariant forall j :: 0 <= j < i ==> 0 <= bytes[j] < 256\n    {\n      var charCode := (s[i] as bv32 & 0xFF) as int;  \n      bytes := bytes + [charCode];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_360", "id": 360}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class InventorySystem {\n  var users: map<string, string>  \n  var items: map<string, int>     \n  \n  constructor()\n  {\n    users := map[];\n    items := map[];\n  }\n  method Login(username: string, password: string) returns (success: bool)\n  {\n    if username in users && users[username] == password {\n      success := true;\n      return;\n    }\n    \n    success := false;\n    var attempts := 1;\n    \n    while attempts < 3\n    {\n      attempts := attempts + 1;\n      if username in users && users[username] == password {\n        success := true;\n        return;\n      }\n    }\n  }\n  method AddItem(name: string, quantity: int) returns (success: bool)\n  {\n    items := items[name := quantity];\n    success := true;\n  }\n  method RemoveItem(name: string) returns (success: bool)\n  {\n    if name in items {\n      var newItems := map k | k in items && k != name :: items[k];\n      items := newItems;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method UpdateItem(name: string, newQuantity: int) returns (success: bool)\n  {\n    if name in items {\n      items := items[name := newQuantity];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method GetAllItems() returns (result: map<string, int>)\n  {\n    result := items;\n  }\n}", "output": "class InventorySystem {\n  var users: map<string, string>  \n  var items: map<string, int>     \n  \n  constructor()\n    ensures fresh(this)\n    ensures users == map[]\n    ensures items == map[]\n  {\n    users := map[];\n    items := map[];\n  }\n  method Login(username: string, password: string) returns (success: bool)\n    modifies this\n    ensures success <==> (username in users && users[username] == password)\n  {\n    if username in users && users[username] == password {\n      success := true;\n      return;\n    }\n    \n    success := false;\n    var attempts := 1;\n    \n    while attempts < 3\n      invariant 1 <= attempts <= 3\n      invariant !success\n      decreases 3 - attempts\n    {\n      attempts := attempts + 1;\n      if username in users && users[username] == password {\n        success := true;\n        return;\n      }\n    }\n  }\n  method AddItem(name: string, quantity: int) returns (success: bool)\n    modifies this\n    requires quantity >= 0\n    ensures success\n    ensures items == old(items)[name := quantity]\n  {\n    items := items[name := quantity];\n    success := true;\n  }\n  method RemoveItem(name: string) returns (success: bool)\n    modifies this\n    ensures success <==> (name in old(items))\n    ensures success ==> items == map k | k in old(items) && k != name :: old(items)[k]\n    ensures !success ==> items == old(items)\n  {\n    if name in items {\n      var newItems := map k | k in items && k != name :: items[k];\n      items := newItems;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method UpdateItem(name: string, newQuantity: int) returns (success: bool)\n    modifies this\n    requires newQuantity >= 0\n    ensures success ==> items == old(items)[name := newQuantity]\n    ensures !success ==> items == old(items)\n    ensures success <==> name in old(items)\n  {\n    if name in items {\n      items := items[name := newQuantity];\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  method GetAllItems() returns (result: map<string, int>)\n    ensures result == items\n  {\n    result := items;\n  }\n}", "name": "py2dfy_384", "id": 384}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type Graph = map<int, seq<int>>\ntype Path = seq<int>\nmethod FindAllPaths(g: Graph, start: int, end: int) returns (paths: seq<Path>)\n    \n    |p| > 0 && p[0] == start && p[|p|-1] == end &&\n    \n    (forall i :: 0 <= i < |p| ==> p[i] in g.Keys) &&\n    (forall i,j :: 0 <= i < j < |p| ==> p[i] != p[j])\n{\n  \n  var currentPath := [start];\n  paths := [];\n  \n  \n  paths := FindAllPathsHelper(g, start, end, currentPath);\n}\nmethod FindAllPathsHelper(g: Graph, start: int, end: int, currentPath: Path) returns (paths: seq<Path>)\n    |p| > 0 && p[0] == start && p[|p|-1] == end &&\n    (forall i :: 0 <= i < |p| ==> p[i] in g.Keys) &&\n    (forall i,j :: 0 <= i < j < |p| ==> p[i] != p[j])\n{\n  var current := currentPath[|currentPath|-1];\n  \n  \n  if current == end {\n    if |currentPath| == |g.Keys| {\n      \n      return [currentPath];\n    }\n    return [];\n  }\n  \n  paths := [];\n  \n  if current in g {\n    var neighbors := g[current];\n    var i := 0;\n    while i < |neighbors|\n        |p| > 0 && p[0] == start && p[|p|-1] == end &&\n        (forall j :: 0 <= j < |p| ==> p[j] in g.Keys) &&\n        (forall j,k :: 0 <= j < k < |p| ==> p[j] != p[k])\n    {\n      var next := neighbors[i];\n      \n      if !Contains(currentPath, next) {\n        \n        var newPath := currentPath + [next];\n        \n        if |newPath| <= |g.Keys| { \n          var newPaths := FindAllPathsHelper(g, start, end, newPath);\n          \n          paths := paths + newPaths;\n        }\n      }\n      i := i + 1;\n    }\n  }\n}\npredicate Contains(s: seq<int>, x: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == x\n}", "output": "type Graph = map<int, seq<int>>\ntype Path = seq<int>\nmethod FindAllPaths(g: Graph, start: int, end: int) returns (paths: seq<Path>)\n  requires g != map[] \n  requires start in g.Keys && end in g.Keys \n  requires forall k :: k in g.Keys ==> forall i :: 0 <= i < |g[k]| ==> g[k][i] in g.Keys \n  ensures forall p :: p in paths ==> \n    \n    |p| > 0 && p[0] == start && p[|p|-1] == end &&\n    \n    (forall i :: 0 <= i < |p| ==> p[i] in g.Keys) &&\n    (forall i,j :: 0 <= i < j < |p| ==> p[i] != p[j])\n{\n  \n  var currentPath := [start];\n  paths := [];\n  \n  \n  paths := FindAllPathsHelper(g, start, end, currentPath);\n}\nmethod FindAllPathsHelper(g: Graph, start: int, end: int, currentPath: Path) returns (paths: seq<Path>)\n  requires g != map[]\n  requires start in g.Keys && end in g.Keys\n  requires |currentPath| > 0 && currentPath[0] == start\n  requires forall i :: 0 <= i < |currentPath| ==> currentPath[i] in g.Keys\n  requires forall i,j :: 0 <= i < j < |currentPath| ==> currentPath[i] != currentPath[j]\n  requires forall k :: k in g.Keys ==> forall i :: 0 <= i < |g[k]| ==> g[k][i] in g.Keys\n  requires |currentPath| <= |g.Keys|  \n  decreases |g.Keys| - |currentPath|  \n  ensures forall p :: p in paths ==>\n    |p| > 0 && p[0] == start && p[|p|-1] == end &&\n    (forall i :: 0 <= i < |p| ==> p[i] in g.Keys) &&\n    (forall i,j :: 0 <= i < j < |p| ==> p[i] != p[j])\n{\n  var current := currentPath[|currentPath|-1];\n  \n  \n  if current == end {\n    if |currentPath| == |g.Keys| {\n      \n      return [currentPath];\n    }\n    return [];\n  }\n  \n  paths := [];\n  \n  if current in g {\n    var neighbors := g[current];\n    var i := 0;\n    while i < |neighbors|\n      invariant 0 <= i <= |neighbors|\n      invariant forall p :: p in paths ==>\n        |p| > 0 && p[0] == start && p[|p|-1] == end &&\n        (forall j :: 0 <= j < |p| ==> p[j] in g.Keys) &&\n        (forall j,k :: 0 <= j < k < |p| ==> p[j] != p[k])\n    {\n      var next := neighbors[i];\n      \n      if !Contains(currentPath, next) {\n        \n        var newPath := currentPath + [next];\n        \n        if |newPath| <= |g.Keys| { \n          var newPaths := FindAllPathsHelper(g, start, end, newPath);\n          \n          paths := paths + newPaths;\n        }\n      }\n      i := i + 1;\n    }\n  }\n}\npredicate Contains(s: seq<int>, x: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == x\n}", "name": "py2dfy_387", "id": 387}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class ProductInfo {\n  var url: string\n  var desiredPrice: real\n  var email: string\n  \n  constructor(u: string, dp: real, e: string)\n  {\n    url := u;\n    desiredPrice := dp; \n    email := e;\n  }\n}\ndatatype ScrapedProduct = ScrapedProduct(\n  name: string,\n  currentPrice: real,\n  available: bool\n)\nclass PriceMonitor {\n  \n  var products: seq<ProductInfo>\n  \n  constructor()\n  {\n    products := [];\n  }\n  \n  method ScrapeProductInfo(url: string) returns (result: ScrapedProduct)\n  {\n    \n    \n    var name := \"Example Product\";\n    var price := 99.99;\n    var available := true;\n    return ScrapedProduct(name, price, available);\n  }\n  \n  predicate IsPriceMet(current: real, desired: real)\n  {\n    current <= desired\n  }\n  \n  method SendEmailNotification(product: ScrapedProduct, userEmail: string) returns (success: bool)\n  {\n    var msg := \"Product: \" + product.name + \n               \"\\nPrice: \" + RealToString(product.currentPrice) +\n               \"\\nAvailable: \" + BoolToString(product.available);\n    \n    success := true;\n  }\n  \n  function RealToString(r: real): string {\n    \n    \"0.00\" \n  }\n  \n  function BoolToString(b: bool): string {\n    if b then \"Yes\" else \"No\"\n  }\n  \n  method CheckPrices() returns (notificationsSent: nat)\n  {\n    var i := 0;\n    notificationsSent := 0;\n    var oldProducts := products;\n    \n    \n    while i < |products|\n    {\n      var product := products[i];\n      var scrapedInfo := ScrapeProductInfo(product.url);\n      \n      if IsPriceMet(scrapedInfo.currentPrice, product.desiredPrice) {\n        var emailSent := SendEmailNotification(scrapedInfo, product.email);\n        if emailSent {\n          notificationsSent := notificationsSent + 1;\n          \n          products := products[..i] + products[i+1..];\n          \n        } else {\n          i := i + 1;\n        }\n      } else {\n        i := i + 1;\n      }\n    }\n  }\n}", "output": "class ProductInfo {\n  var url: string\n  var desiredPrice: real\n  var email: string\n  \n  constructor(u: string, dp: real, e: string)\n    requires dp >= 0.0  \n    requires u != \"\"    \n    requires e != \"\"    \n    ensures url == u && desiredPrice == dp && email == e\n  {\n    url := u;\n    desiredPrice := dp; \n    email := e;\n  }\n}\ndatatype ScrapedProduct = ScrapedProduct(\n  name: string,\n  currentPrice: real,\n  available: bool\n)\nclass PriceMonitor {\n  \n  var products: seq<ProductInfo>\n  \n  constructor()\n    ensures products == []\n  {\n    products := [];\n  }\n  \n  method ScrapeProductInfo(url: string) returns (result: ScrapedProduct)\n    requires url != \"\"\n    ensures result.currentPrice >= 0.0\n  {\n    \n    \n    var name := \"Example Product\";\n    var price := 99.99;\n    var available := true;\n    return ScrapedProduct(name, price, available);\n  }\n  \n  predicate IsPriceMet(current: real, desired: real)\n    requires current >= 0.0\n    requires desired >= 0.0\n  {\n    current <= desired\n  }\n  \n  method SendEmailNotification(product: ScrapedProduct, userEmail: string) returns (success: bool)\n    requires userEmail != \"\"\n  {\n    var msg := \"Product: \" + product.name + \n               \"\\nPrice: \" + RealToString(product.currentPrice) +\n               \"\\nAvailable: \" + BoolToString(product.available);\n    \n    success := true;\n  }\n  \n  function RealToString(r: real): string {\n    \n    \"0.00\" \n  }\n  \n  function BoolToString(b: bool): string {\n    if b then \"Yes\" else \"No\"\n  }\n  \n  method CheckPrices() returns (notificationsSent: nat)\n    requires forall p :: p in products ==> p.desiredPrice >= 0.0 && p.url != \"\" && p.email != \"\"\n    ensures notificationsSent <= |old(products)|\n    modifies this`products\n  {\n    var i := 0;\n    notificationsSent := 0;\n    var oldProducts := products;\n    \n    \n    while i < |products|\n      invariant 0 <= i <= |products|\n      invariant notificationsSent <= |oldProducts|\n      invariant |products| == |oldProducts| - notificationsSent\n      invariant forall p :: p in products ==> p.desiredPrice >= 0.0 && p.url != \"\" && p.email != \"\"\n      invariant forall j :: 0 <= j < |products| ==> products[j].url != \"\"\n      invariant forall j :: 0 <= j < |products| ==> products[j].email != \"\"\n      decreases |products| - i\n    {\n      var product := products[i];\n      assert product.url != \"\";  \n      var scrapedInfo := ScrapeProductInfo(product.url);\n      \n      if IsPriceMet(scrapedInfo.currentPrice, product.desiredPrice) {\n        assert product.email != \"\";  \n        var emailSent := SendEmailNotification(scrapedInfo, product.email);\n        if emailSent {\n          notificationsSent := notificationsSent + 1;\n          \n          products := products[..i] + products[i+1..];\n          \n        } else {\n          i := i + 1;\n        }\n      } else {\n        i := i + 1;\n      }\n    }\n  }\n}", "name": "py2dfy_385", "id": 385}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Label = Label(start: int, end: int, tag: string)\ntype TagCount = map<string, int>\nmethod CountTags(labels: seq<Label>) returns (counts: TagCount)\n    counts[tag] == CountOccurrences(labels, tag)\n{\n  counts := map[];\n  \n  var i := 0;\n  while i < |labels|\n      counts[tag] == CountOccurrencesUpto(labels, tag, i)\n      CountOccurrencesUpto(labels, tag, i) == 0\n  {\n    var currentTag := labels[i].tag;\n    if currentTag in counts {\n      counts := counts[currentTag := counts[currentTag] + 1];\n    } else {\n      counts := counts[currentTag := 1];\n    }\n    i := i + 1;\n  }\n}\nfunction CountOccurrences(labels: seq<Label>, tag: string): int\n{\n  CountOccurrencesUpto(labels, tag, |labels|)\n}\nfunction CountOccurrencesUpto(labels: seq<Label>, tag: string, upTo: int): int\n{\n  if upTo == 0 then\n    0\n  else\n    CountOccurrencesUpto(labels, tag, upTo-1) + \n    (if labels[upTo-1].tag == tag then 1 else 0)\n}", "output": "datatype Label = Label(start: int, end: int, tag: string)\ntype TagCount = map<string, int>\nmethod CountTags(labels: seq<Label>) returns (counts: TagCount)\n  ensures forall tag :: tag in counts ==> counts[tag] >= 0\n  ensures forall l :: l in labels ==> l.tag in counts\n  ensures forall tag :: tag in counts ==> \n    counts[tag] == CountOccurrences(labels, tag)\n{\n  counts := map[];\n  \n  var i := 0;\n  while i < |labels|\n    invariant 0 <= i <= |labels|\n    invariant forall tag :: tag in counts ==> counts[tag] >= 0\n    invariant forall j :: 0 <= j < i ==> labels[j].tag in counts\n    invariant forall tag :: tag in counts ==>\n      counts[tag] == CountOccurrencesUpto(labels, tag, i)\n    invariant forall tag :: tag !in counts ==>\n      CountOccurrencesUpto(labels, tag, i) == 0\n  {\n    var currentTag := labels[i].tag;\n    if currentTag in counts {\n      counts := counts[currentTag := counts[currentTag] + 1];\n    } else {\n      counts := counts[currentTag := 1];\n    }\n    i := i + 1;\n  }\n}\nfunction CountOccurrences(labels: seq<Label>, tag: string): int\n{\n  CountOccurrencesUpto(labels, tag, |labels|)\n}\nfunction CountOccurrencesUpto(labels: seq<Label>, tag: string, upTo: int): int\n  requires 0 <= upTo <= |labels|\n{\n  if upTo == 0 then\n    0\n  else\n    CountOccurrencesUpto(labels, tag, upTo-1) + \n    (if labels[upTo-1].tag == tag then 1 else 0)\n}", "name": "py2dfy_383", "id": 383}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Point = Point(x: real, y: real)\ndatatype FitParameters = FitParams(a0: real, a1: real, a2: real)\nfunction CubicFunction(p: FitParameters, x: real): real\n{\n    p.a0 * (x-1.0) - p.a1 * ((x-1.0) * (x-1.0)) + p.a2 * ((x-1.0) * (x-1.0) * (x-1.0)) + 1.0\n}\nfunction ComputeResidual(param: FitParameters, point: Point): real\n{\n    point.y - CubicFunction(param, point.x)\n}\nfunction SumSquaredResiduals(param: FitParameters, points: seq<Point>): real\n{\n    if |points| == 1 \n    then var r := ComputeResidual(param, points[0]); r * r\n    else \n        var r := ComputeResidual(param, points[0]);\n        r * r + SumSquaredResiduals(param, points[1..])\n}\nmethod NormalizePoints(points: seq<Point>) returns (normalized: seq<Point>)\n{\n    var minX := points[0].x;\n    var maxX := points[0].x;\n    \n    \n    var i := 0;\n    while i < |points|\n    {\n        if points[i].x < minX { minX := points[i].x; }\n        if points[i].x > maxX { maxX := points[i].x; }\n        i := i + 1;\n    }\n    \n    normalized := [];\n    i := 0;\n    var range := maxX - minX;\n    while i < |points|\n            0.0 <= normalized[k].x <= 1.0\n    {\n        var normalizedX := if range == 0.0 then 0.0 \n                          else (points[i].x - minX) / range;\n        normalized := normalized + [Point(normalizedX, points[i].y)];\n        i := i + 1;\n    }\n}\nmethod EvaluateCubicFunction(params: FitParameters, xValues: seq<real>) returns (yValues: seq<real>)\n{\n    yValues := [];\n    var i := 0;\n    while i < |xValues|\n    {\n        var y := CubicFunction(params, xValues[i]);\n        yValues := yValues + [y];\n        i := i + 1;\n    }\n}", "output": "datatype Point = Point(x: real, y: real)\ndatatype FitParameters = FitParams(a0: real, a1: real, a2: real)\nfunction CubicFunction(p: FitParameters, x: real): real\n{\n    p.a0 * (x-1.0) - p.a1 * ((x-1.0) * (x-1.0)) + p.a2 * ((x-1.0) * (x-1.0) * (x-1.0)) + 1.0\n}\nfunction ComputeResidual(param: FitParameters, point: Point): real\n{\n    point.y - CubicFunction(param, point.x)\n}\nfunction SumSquaredResiduals(param: FitParameters, points: seq<Point>): real\n    requires |points| > 0\n{\n    if |points| == 1 \n    then var r := ComputeResidual(param, points[0]); r * r\n    else \n        var r := ComputeResidual(param, points[0]);\n        r * r + SumSquaredResiduals(param, points[1..])\n}\nmethod NormalizePoints(points: seq<Point>) returns (normalized: seq<Point>)\n    requires |points| > 0\n    ensures |normalized| == |points|\n    ensures forall i :: 0 <= i < |normalized| ==> 0.0 <= normalized[i].x <= 1.0\n{\n    var minX := points[0].x;\n    var maxX := points[0].x;\n    \n    \n    var i := 0;\n    while i < |points|\n        invariant 0 <= i <= |points|\n        invariant forall k :: 0 <= k < i ==> points[k].x >= minX\n        invariant forall k :: 0 <= k < i ==> points[k].x <= maxX\n    {\n        if points[i].x < minX { minX := points[i].x; }\n        if points[i].x > maxX { maxX := points[i].x; }\n        i := i + 1;\n    }\n    \n    normalized := [];\n    i := 0;\n    var range := maxX - minX;\n    while i < |points|\n        invariant 0 <= i <= |points|\n        invariant |normalized| == i\n        invariant forall k :: 0 <= k < i ==> \n            0.0 <= normalized[k].x <= 1.0\n    {\n        var normalizedX := if range == 0.0 then 0.0 \n                          else (points[i].x - minX) / range;\n        normalized := normalized + [Point(normalizedX, points[i].y)];\n        i := i + 1;\n    }\n}\nmethod EvaluateCubicFunction(params: FitParameters, xValues: seq<real>) returns (yValues: seq<real>)\n    requires |xValues| > 0\n    ensures |yValues| == |xValues|\n{\n    yValues := [];\n    var i := 0;\n    while i < |xValues|\n        invariant 0 <= i <= |xValues|\n        invariant |yValues| == i\n    {\n        var y := CubicFunction(params, xValues[i]);\n        yValues := yValues + [y];\n        i := i + 1;\n    }\n}", "name": "py2dfy_389", "id": 389}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class A {\n  \n  var a: string\n  \n  constructor() \n  {\n    a := \"d\";\n  }\n  \n  method func_1()\n  {\n    a := \"b\";\n    print a, \"\\n\";\n  }\n  \n  method func_3()\n  {\n    print a, \"\\n\";\n  }\n  \n  method func_2()\n  {\n    print a, \"\\n\";\n  }\n}\nmethod Main()\n{\n  var a := new A();\n  print a.a, \"\\n\";\n  a.func_1();\n  a.func_1();\n  var instance := new A();\n  instance.func_3();\n  print a.a, \"\\n\";\n}", "output": "class A {\n  \n  var a: string\n  \n  constructor() \n    ensures a == \"d\"\n  {\n    a := \"d\";\n  }\n  \n  method func_1()\n    modifies this\n    ensures a == \"b\"\n  {\n    a := \"b\";\n    print a, \"\\n\";\n  }\n  \n  method func_3()\n    requires a != \"\"\n    ensures a == old(a)  \n  {\n    print a, \"\\n\";\n  }\n  \n  method func_2()\n    requires a != \"\"\n    ensures a == old(a)\n  {\n    print a, \"\\n\";\n  }\n}\nmethod Main()\n{\n  var a := new A();\n  print a.a, \"\\n\";\n  a.func_1();\n  a.func_1();\n  var instance := new A();\n  instance.func_3();\n  print a.a, \"\\n\";\n}", "name": "py2dfy_390", "id": 390}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype VoiceParams = VoiceParams(\n  languageCode: string,\n  name: string,\n  gender: string,\n  sampleRate: int\n)\ndatatype AudioConfig = AudioConfig(\n  encoding: string\n)\nclass TextToSpeech {\n  \n  var isConnected: bool\n  \n  constructor()\n  {\n    isConnected := true;\n  }\n  \n  method GetLanguageCode(voiceName: string) returns (languageCode: string)\n  {\n    \n    languageCode := voiceName[..5]; \n  }\n  \n  method SynthesizeSpeech(text: string, voiceName: string) returns (audioContent: array<int>)\n  {\n    \n    audioContent := new int[1]; \n  }\n  \n  method ProcessTextBatch(texts: array<string>, voiceName: string) returns (success: bool)\n  {\n    var i := 0;\n    \n    \n    while i < texts.Length \n    {\n      var audioContent := SynthesizeSpeech(texts[i], voiceName);\n      \n      i := i + 1;\n    }\n    \n    success := true;\n  }\n  \n  method ListVoices(languageCode: string) returns (voices: seq<VoiceParams>)\n  {\n    \n    var voice := VoiceParams(languageCode, languageCode + \"-Wavenet-A\", \"FEMALE\", 24000);\n    voices := [voice];\n  }\n}", "output": "datatype VoiceParams = VoiceParams(\n  languageCode: string,\n  name: string,\n  gender: string,\n  sampleRate: int\n)\ndatatype AudioConfig = AudioConfig(\n  encoding: string\n)\nclass TextToSpeech {\n  \n  var isConnected: bool\n  \n  constructor()\n    ensures isConnected\n  {\n    isConnected := true;\n  }\n  \n  method GetLanguageCode(voiceName: string) returns (languageCode: string)\n    requires voiceName != \"\"\n    requires |voiceName| >= 5  \n    ensures languageCode != \"\"\n  {\n    \n    languageCode := voiceName[..5]; \n  }\n  \n  method SynthesizeSpeech(text: string, voiceName: string) returns (audioContent: array<int>)\n    requires isConnected\n    requires text != \"\"\n    requires voiceName != \"\"\n    ensures audioContent.Length > 0\n  {\n    \n    audioContent := new int[1]; \n  }\n  \n  method ProcessTextBatch(texts: array<string>, voiceName: string) returns (success: bool)\n    requires isConnected\n    requires voiceName != \"\"\n    requires forall i :: 0 <= i < texts.Length ==> texts[i] != \"\"\n    ensures success\n  {\n    var i := 0;\n    \n    \n    while i < texts.Length \n      invariant 0 <= i <= texts.Length\n      invariant forall k :: 0 <= k < i ==> texts[k] != \"\"\n      decreases texts.Length - i\n    {\n      var audioContent := SynthesizeSpeech(texts[i], voiceName);\n      \n      i := i + 1;\n    }\n    \n    success := true;\n  }\n  \n  method ListVoices(languageCode: string) returns (voices: seq<VoiceParams>)\n    requires isConnected\n    requires languageCode != \"\"\n    ensures |voices| > 0\n    ensures forall v :: v in voices ==> v.languageCode == languageCode\n  {\n    \n    var voice := VoiceParams(languageCode, languageCode + \"-Wavenet-A\", \"FEMALE\", 24000);\n    voices := [voice];\n  }\n}", "name": "py2dfy_395", "id": 395}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Roll(upperBound: int) returns (result: string)\n{\n  \n  var roll := upperBound;  \n  var rollStr := IntToString(roll); \n  \n  if roll == upperBound {\n    result := \"Critical Hit! \" + rollStr;\n  } else if roll == 1 {\n    result := \"Critical Fail! \" + rollStr; \n  } else {\n    result := rollStr;\n  }\n}\nmethod {:axiom} IntToString(n: int) returns (s: string)", "output": "method Roll(upperBound: int) returns (result: string)\n  requires upperBound > 0  \n  ensures |result| > 0     \n{\n  \n  var roll := upperBound;  \n  var rollStr := IntToString(roll); \n  \n  if roll == upperBound {\n    result := \"Critical Hit! \" + rollStr;\n  } else if roll == 1 {\n    result := \"Critical Fail! \" + rollStr; \n  } else {\n    result := rollStr;\n  }\n}\nmethod {:axiom} IntToString(n: int) returns (s: string)\n  ensures |s| > 0", "name": "py2dfy_408", "id": 408}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ApiKeys = ApiKeys(api_key: string, api_secret_key: string, bearer_token: string)\ndatatype Response = Response(status_code: int, data: map<string, seq<string>>)\nclass Collector {\n  \n  var number_apps: int\n  var keys: seq<ApiKeys>\n  var db_path: string\n  \n  \n  predicate Valid()\n  {\n    number_apps >= 0 && \n    |keys| == number_apps &&\n    forall i :: 0 <= i < |keys| ==> |keys[i].bearer_token| >= 1\n  }\n  constructor()\n  {\n    number_apps := 0;\n    keys := [];\n    db_path := \"\";\n  }\n  \n  method ProcessTokens(apps: seq<ApiKeys>) \n  {\n    keys := apps;\n    number_apps := |apps|;\n  }\n  \n  method GetBearerHeader(app_index: int) returns (header: map<string, string>)\n  {\n    header := map[\"Authorization\" := \"Bearer \" + keys[app_index].bearer_token];\n  }\n  \n  method RequestData(search_query: string, app_index: int) returns (response: Response)\n  {\n    \n    var status := 200;  \n    var result := map[\"data\" := [\"tweet1\", \"tweet2\"]];  \n    response := Response(status, result);\n  }\n  \n  method Collect(query_list: seq<string>) returns (success: bool)\n  {\n    var query_index := 0;\n    var app_index := 0;\n    \n    while query_index < |query_list| && app_index < number_apps\n    {\n      var current_query := if query_index < |query_list| then query_list[query_index] else \"\";\n      if current_query != \"\" {\n        var response := RequestData(current_query, app_index);\n        \n        if response.status_code < 200 || response.status_code >= 300 {\n          return false;  \n        }\n      }\n      \n      query_index := query_index + 1;\n      if query_index >= |query_list| {\n        query_index := 0;\n        app_index := app_index + 1;\n      }\n    }\n    return true;\n  }\n}", "output": "datatype ApiKeys = ApiKeys(api_key: string, api_secret_key: string, bearer_token: string)\ndatatype Response = Response(status_code: int, data: map<string, seq<string>>)\nclass Collector {\n  \n  var number_apps: int\n  var keys: seq<ApiKeys>\n  var db_path: string\n  \n  \n  predicate Valid()\n    reads this\n  {\n    number_apps >= 0 && \n    |keys| == number_apps &&\n    forall i :: 0 <= i < |keys| ==> |keys[i].bearer_token| >= 1\n  }\n  constructor()\n    ensures Valid()\n    ensures number_apps == 0\n    ensures |keys| == 0\n  {\n    number_apps := 0;\n    keys := [];\n    db_path := \"\";\n  }\n  \n  method ProcessTokens(apps: seq<ApiKeys>) \n    requires |apps| > 0\n    requires forall i :: 0 <= i < |apps| ==> |apps[i].bearer_token| >= 1\n    modifies this\n    ensures Valid()\n    ensures number_apps == |apps|\n    ensures keys == apps\n  {\n    keys := apps;\n    number_apps := |apps|;\n  }\n  \n  method GetBearerHeader(app_index: int) returns (header: map<string, string>)\n    requires Valid()\n    requires 0 <= app_index < number_apps\n    ensures header.Keys == {(\"Authorization\")}\n    ensures |header[\"Authorization\"]| > 7\n    ensures header[\"Authorization\"][..7] == \"Bearer \"\n  {\n    header := map[\"Authorization\" := \"Bearer \" + keys[app_index].bearer_token];\n    assert |\"Bearer \"| == 7;\n  }\n  \n  method RequestData(search_query: string, app_index: int) returns (response: Response)\n    requires Valid()\n    requires search_query != \"\"\n    requires 0 <= app_index < number_apps\n    ensures response.status_code >= 200 ==> response.status_code < 300  \n  {\n    \n    var status := 200;  \n    var result := map[\"data\" := [\"tweet1\", \"tweet2\"]];  \n    response := Response(status, result);\n  }\n  \n  method Collect(query_list: seq<string>) returns (success: bool)\n    requires Valid()\n    requires |query_list| > 0\n    modifies this\n    ensures Valid()\n  {\n    var query_index := 0;\n    var app_index := 0;\n    \n    while query_index < |query_list| && app_index < number_apps\n      invariant Valid()\n      invariant 0 <= query_index <= |query_list|\n      invariant 0 <= app_index <= number_apps\n      decreases |query_list| - query_index + (number_apps - app_index) * |query_list|\n    {\n      var current_query := if query_index < |query_list| then query_list[query_index] else \"\";\n      if current_query != \"\" {\n        var response := RequestData(current_query, app_index);\n        \n        if response.status_code < 200 || response.status_code >= 300 {\n          return false;  \n        }\n      }\n      \n      query_index := query_index + 1;\n      if query_index >= |query_list| {\n        query_index := 0;\n        app_index := app_index + 1;\n      }\n    }\n    return true;\n  }\n}", "name": "py2dfy_391", "id": 391}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Node<T> {\n  var next: Node?<T>\n}\nclass List<T> {\n    ghost var spine: seq<Node<T>>\n    ghost var repr: set<object>\n    ghost predicate Valid()\n    {\n        && forall i | 0 <= i < |spine| ::\n            && spine[i] in repr\n            && (spine[i].next == (if i < |spine| - 1 then spine[i+1] else null))\n    }\n}", "output": "class Node<T> {\n  var next: Node?<T>\n}\nclass List<T> {\n    ghost var spine: seq<Node<T>>\n    ghost var repr: set<object>\n    ghost predicate Valid()\n        reads this, repr\n    {\n        && forall i | 0 <= i < |spine| ::\n            && spine[i] in repr\n            && (spine[i].next == (if i < |spine| - 1 then spine[i+1] else null))\n    }\n}", "name": "py2dfy_419", "id": 419}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait Person {\n    var name: string\n    predicate Valid()\n    {\n        name != \"\"\n    }\n    method eat()\n    {\n        print name, \" is eating\\n\";\n    }\n}\nclass Student extends Person {\n    var university: string\n    constructor(n: string, uni: string)\n    {\n        name := n;\n        university := uni;\n    }\n    method sleep()\n    {\n        print name, \" from \", university, \" is sleeping\\n\";\n    }\n}\nclass PersonImpl extends Person {\n    constructor(n: string)\n    {\n        name := n;\n    }\n}\nmethod Main()\n{\n    var bob := new PersonImpl(\"bob\");\n    bob.eat();\n    var dob := new Student(\"dob\", \"ubb\");\n    dob.eat();\n    dob.sleep();\n}", "output": "trait Person {\n    var name: string\n    predicate Valid()\n        reads this\n    {\n        name != \"\"\n    }\n    method eat()\n        requires Valid()\n        ensures Valid() \n        modifies this\n    {\n        print name, \" is eating\\n\";\n    }\n}\nclass Student extends Person {\n    var university: string\n    constructor(n: string, uni: string)\n        requires n != \"\"\n        requires uni != \"\"\n        ensures name == n\n        ensures university == uni\n        ensures Valid()\n    {\n        name := n;\n        university := uni;\n    }\n    method sleep()\n        requires Valid()\n        ensures Valid()\n        modifies this\n    {\n        print name, \" from \", university, \" is sleeping\\n\";\n    }\n}\nclass PersonImpl extends Person {\n    constructor(n: string)\n        requires n != \"\"\n        ensures name == n\n        ensures Valid()\n    {\n        name := n;\n    }\n}\nmethod Main()\n{\n    var bob := new PersonImpl(\"bob\");\n    bob.eat();\n    var dob := new Student(\"dob\", \"ubb\");\n    dob.eat();\n    dob.sleep();\n}", "name": "py2dfy_418", "id": 418}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class GPSData {\n  var longitude: real\n  var latitude: real\n  var altitude: real\n  var speed: real\n  var heading: real\n  \n  constructor()\n  {\n    longitude := 0.0;\n    latitude := 0.0;\n    altitude := 0.0;\n    speed := 0.0;\n    heading := 0.0;\n  }\n}\nclass SensorData {\n  var externalTemp: real\n  var internalTemp: real\n  var coLevel: real\n  var ch4Level: real\n  \n  constructor()\n  {\n    externalTemp := 70.0;\n    internalTemp := 0.0;\n    coLevel := 0.0;\n    ch4Level := 0.0;\n  }\n}\nmethod UTCtoPSTDST(hours: int) returns (result: int)\n{\n  var adjusted := hours + 17;\n  if adjusted > 24 {\n    adjusted := adjusted - 24;\n  }\n  return adjusted;\n}\nmethod StringToFloat(input: string, previousValue: real) returns (result: real)\n{\n  if |input| < 4 || input == \"-\" {\n    return previousValue;\n  }\n  \n  if IsValidFloat(input) {\n    return ParseFloat(input);\n  }\n  return previousValue;\n}\npredicate IsValidFloat(s: string)\n{\n  \n  \n  |s| >= 4 && s != \"-\"\n}\nfunction ParseFloat(s: string): real\n{\n  \n  0.0\n}\nmethod ProcessGPSData(nmeaString: string, gps: GPSData?)\n{\n  \n  \n  \n}", "output": "class GPSData {\n  var longitude: real\n  var latitude: real\n  var altitude: real\n  var speed: real\n  var heading: real\n  \n  constructor()\n    ensures longitude == 0.0 && latitude == 0.0 && altitude == 0.0\n    ensures speed == 0.0 && heading == 0.0\n  {\n    longitude := 0.0;\n    latitude := 0.0;\n    altitude := 0.0;\n    speed := 0.0;\n    heading := 0.0;\n  }\n}\nclass SensorData {\n  var externalTemp: real\n  var internalTemp: real\n  var coLevel: real\n  var ch4Level: real\n  \n  constructor()\n    ensures externalTemp == 70.0 \n    ensures internalTemp == 0.0\n    ensures coLevel == 0.0 && ch4Level == 0.0\n  {\n    externalTemp := 70.0;\n    internalTemp := 0.0;\n    coLevel := 0.0;\n    ch4Level := 0.0;\n  }\n}\nmethod UTCtoPSTDST(hours: int) returns (result: int)\n  requires 0 <= hours <= 24\n  ensures 0 <= result <= 24\n  ensures result == if hours + 17 > 24 then hours + 17 - 24 else hours + 17\n{\n  var adjusted := hours + 17;\n  if adjusted > 24 {\n    adjusted := adjusted - 24;\n  }\n  return adjusted;\n}\nmethod StringToFloat(input: string, previousValue: real) returns (result: real)\n  requires |input| >= 0\n  ensures result == if IsValidFloat(input) then ParseFloat(input) else previousValue\n{\n  if |input| < 4 || input == \"-\" {\n    assert !IsValidFloat(input); \n    return previousValue;\n  }\n  \n  if IsValidFloat(input) {\n    return ParseFloat(input);\n  }\n  return previousValue;\n}\npredicate IsValidFloat(s: string)\n{\n  \n  \n  |s| >= 4 && s != \"-\"\n}\nfunction ParseFloat(s: string): real\n  requires IsValidFloat(s)\n{\n  \n  0.0\n}\nmethod ProcessGPSData(nmeaString: string, gps: GPSData?)\n  modifies gps\n  requires gps != null\n  ensures gps.longitude == old(gps.longitude) || gps.longitude != old(gps.longitude)\n  ensures gps.latitude == old(gps.latitude) || gps.latitude != old(gps.latitude)\n{\n  \n  \n  \n}", "name": "py2dfy_407", "id": 407}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module KeyRules {\n  \n  type KeyRuleMap = map<string, seq<string>>\n  \n  method ReadLines(filePath: string) returns (lines: seq<string>)\n  {\n    \n    \n    lines := [\"file1:0,1,2\", \"file2:3,4,5\"];\n  }\n  \n  function Split(s: string, delimiter: char): seq<string>\n  {\n    if s == \"\" then []\n    else if s[0] == delimiter then Split(s[1..], delimiter)\n    else \n      var restSplit := Split(s[1..], delimiter);\n      if |restSplit| > 0 then\n        [s[0..1] + restSplit[0]] + restSplit[1..]\n      else\n        [s[0..1]] + restSplit\n  }\n  \n  method ReadKeyRules(keysPath: string) returns (keyRules: KeyRuleMap)\n  {\n    var lines := ReadLines(keysPath);\n    keyRules := map[];\n    for i := 0 to |lines|\n    {\n      var parts := Split(lines[i], ':');\n      if |parts| == 2 {\n        var key := parts[0];\n        var values := Split(parts[1], ',');\n        if |values| > 0 {\n          keyRules := keyRules[key := values];\n        }\n      }\n    }\n  }\n}", "output": "module KeyRules {\n  \n  type KeyRuleMap = map<string, seq<string>>\n  \n  method ReadLines(filePath: string) returns (lines: seq<string>)\n  {\n    \n    \n    lines := [\"file1:0,1,2\", \"file2:3,4,5\"];\n  }\n  \n  function Split(s: string, delimiter: char): seq<string>\n  {\n    if s == \"\" then []\n    else if s[0] == delimiter then Split(s[1..], delimiter)\n    else \n      var restSplit := Split(s[1..], delimiter);\n      if |restSplit| > 0 then\n        [s[0..1] + restSplit[0]] + restSplit[1..]\n      else\n        [s[0..1]] + restSplit\n  }\n  \n  method ReadKeyRules(keysPath: string) returns (keyRules: KeyRuleMap)\n    ensures forall k :: k in keyRules ==> |keyRules[k]| > 0\n  {\n    var lines := ReadLines(keysPath);\n    keyRules := map[];\n    for i := 0 to |lines|\n      invariant forall k :: k in keyRules ==> |keyRules[k]| > 0\n    {\n      var parts := Split(lines[i], ':');\n      if |parts| == 2 {\n        var key := parts[0];\n        var values := Split(parts[1], ',');\n        if |values| > 0 {\n          keyRules := keyRules[key := values];\n        }\n      }\n    }\n  }\n}", "name": "py2dfy_398", "id": 398}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class MiClase {\n    var name: string\n    constructor(initialName: string)\n    {\n        name := initialName;\n    }\n    predicate Valid()\n    {\n        |name| > 0  \n    }\n    method GetName() returns (result: string)\n    {\n        result := name;\n    }\n    method SetName(newName: string) returns (result: string)\n    {\n        name := newName;\n        result := name;\n    }\n}\nmethod Main()\n{\n    var objeto := new MiClase(\"John Wick\");\n    \n    var name1 := objeto.GetName();\n    print name1, \"\\n\";\n    \n    var name2 := objeto.SetName(\"Neo\");\n    print name2, \"\\n\";\n}", "output": "class MiClase {\n    var name: string\n    constructor(initialName: string)\n        requires |initialName| > 0\n        ensures name == initialName\n        ensures Valid()\n    {\n        name := initialName;\n    }\n    predicate Valid()\n        reads this\n    {\n        |name| > 0  \n    }\n    method GetName() returns (result: string)\n        requires Valid()\n        ensures Valid()\n        ensures result == name\n    {\n        result := name;\n    }\n    method SetName(newName: string) returns (result: string)\n        requires Valid()\n        requires |newName| > 0  \n        ensures Valid()\n        ensures name == newName\n        ensures result == name\n        modifies this\n    {\n        name := newName;\n        result := name;\n    }\n}\nmethod Main()\n{\n    var objeto := new MiClase(\"John Wick\");\n    \n    var name1 := objeto.GetName();\n    print name1, \"\\n\";\n    \n    var name2 := objeto.SetName(\"Neo\");\n    print name2, \"\\n\";\n}", "name": "py2dfy_423", "id": 423}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintHelloWorld()\n{\n  print \"Hello World!\\n\";\n}\nmethod Main()\n{\n  PrintHelloWorld();\n}", "output": "method PrintHelloWorld()\n  ensures true  \n{\n  print \"Hello World!\\n\";\n}\nmethod Main()\n{\n  PrintHelloWorld();\n}", "name": "py2dfy_441", "id": 441}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module Database {\n  datatype DateTime = DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int)\n  \n  class Schedule {\n    var text: string\n    var date: DateTime\n    var ip: string\n    \n    constructor(text: string, ip: string)\n    {\n      this.text := text;\n      this.ip := ip;\n      var currentDateTime := GetCurrentDateTime();\n      this.date := currentDateTime;\n    }\n    \n    static method GetCurrentDateTime() returns (dt: DateTime)\n    {\n      dt := DateTime(2023, 12, 25, 12, 0, 0);\n    }\n  }\n  \n  class ScheduleDatabase {\n    var schedules: seq<Schedule>\n    \n    constructor()\n    {\n      schedules := [];\n    }\n    \n    method AddSchedule(text: string, ip: string) returns (schedule: Schedule)\n    {\n      schedule := new Schedule(text, ip);\n      schedules := schedules + [schedule];\n    }\n    \n    method QueryByIP(ip: string) returns (results: seq<Schedule>)\n    {\n      var matchingSchedules: seq<Schedule> := [];\n      var i := 0;\n      \n      while i < |schedules|\n      {\n        if schedules[i].ip == ip {\n          matchingSchedules := matchingSchedules + [schedules[i]];\n        }\n        i := i + 1;\n      }\n      \n      results := matchingSchedules;\n    }\n  }\n}", "output": "module Database {\n  datatype DateTime = DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int)\n  \n  class Schedule {\n    var text: string\n    var date: DateTime\n    var ip: string\n    \n    constructor(text: string, ip: string)\n      requires text != \"\"\n      requires ip != \"\"\n      ensures this.text == text\n      ensures this.ip == ip\n      ensures this.date.year > 0 && this.date.month > 0 && this.date.day > 0\n    {\n      this.text := text;\n      this.ip := ip;\n      var currentDateTime := GetCurrentDateTime();\n      this.date := currentDateTime;\n    }\n    \n    static method GetCurrentDateTime() returns (dt: DateTime)\n      ensures dt.year > 0 && dt.month > 0 && dt.day > 0\n    {\n      dt := DateTime(2023, 12, 25, 12, 0, 0);\n    }\n  }\n  \n  class ScheduleDatabase {\n    var schedules: seq<Schedule>\n    \n    constructor()\n      ensures schedules == []\n    {\n      schedules := [];\n    }\n    \n    method AddSchedule(text: string, ip: string) returns (schedule: Schedule)\n      requires text != \"\"\n      requires ip != \"\"\n      modifies this\n      ensures fresh(schedule)\n      ensures schedule.text == text\n      ensures schedule.ip == ip\n      ensures schedule in schedules\n      ensures |schedules| == old(|schedules|) + 1\n      ensures schedules == old(schedules) + [schedule]\n    {\n      schedule := new Schedule(text, ip);\n      schedules := schedules + [schedule];\n    }\n    \n    method QueryByIP(ip: string) returns (results: seq<Schedule>)\n      requires ip != \"\"\n      ensures forall s :: s in results ==> s in schedules\n      ensures forall s :: s in results ==> s.ip == ip\n      ensures forall s :: s in schedules && s.ip == ip ==> s in results\n    {\n      var matchingSchedules: seq<Schedule> := [];\n      var i := 0;\n      \n      while i < |schedules|\n        invariant 0 <= i <= |schedules|\n        invariant forall s :: s in matchingSchedules ==> s in schedules\n        invariant forall s :: s in matchingSchedules ==> s.ip == ip\n        invariant forall j :: 0 <= j < i && schedules[j].ip == ip ==> schedules[j] in matchingSchedules\n      {\n        if schedules[i].ip == ip {\n          matchingSchedules := matchingSchedules + [schedules[i]];\n        }\n        i := i + 1;\n      }\n      \n      results := matchingSchedules;\n    }\n  }\n}", "name": "py2dfy_409", "id": 409}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class FirmwarePack {\n  var name: string\n  var orgName: string\n  var rackBundleVersion: string\n  var bladeBundleVersion: string\n  var description: string\n  var mode: string\n  \n  constructor(n: string, org: string, rack: string, blade: string, desc: string, m: string)\n  {\n    name := n;\n    orgName := org;\n    rackBundleVersion := rack;\n    bladeBundleVersion := blade;\n    description := desc;\n    mode := m;\n  }\n}\nclass FirmwareManager {\n  var packs: map<string, FirmwarePack>\n  \n  constructor()\n  {\n    packs := map[];\n  }\n  \n  method CreateFirmwarePack(\n    orgName: string, \n    name: string, \n    rackVersion: string, \n    bladeVersion: string, \n    desc: string := \"\", \n    mode: string := \"staged\"\n  ) returns (success: bool)\n  {\n    if name in packs {\n      success := false;\n      return;\n    }\n    \n    var pack := new FirmwarePack(name, orgName, rackVersion, bladeVersion, desc, mode);\n    packs := packs[name := pack];\n    success := true;\n  }\n  \n  method ModifyFirmwarePack(\n    orgName: string,\n    name: string,\n    rackVersion: string,\n    bladeVersion: string,\n    desc: string,\n    mode: string\n  ) returns (success: bool)\n  {\n    if name !in packs {\n      success := false;\n      return;\n    }\n    \n    var pack := packs[name];\n    pack.rackBundleVersion := rackVersion;\n    pack.bladeBundleVersion := bladeVersion;\n    pack.description := desc;\n    pack.mode := mode;\n    success := true;\n  }\n  \n  method RemoveFirmwarePack(orgName: string, name: string) returns (success: bool)\n  {\n    if name !in packs {\n      success := false;\n      return;\n    }\n    \n    packs := map k | k in packs && k != name :: packs[k];\n    success := true;\n  }\n}", "output": "class FirmwarePack {\n  var name: string\n  var orgName: string\n  var rackBundleVersion: string\n  var bladeBundleVersion: string\n  var description: string\n  var mode: string\n  \n  constructor(n: string, org: string, rack: string, blade: string, desc: string, m: string)\n    requires n != \"\"  \n    requires org != \"\" \n    ensures name == n\n    ensures orgName == org\n    ensures rackBundleVersion == rack\n    ensures bladeBundleVersion == blade\n    ensures description == desc\n    ensures mode == m\n  {\n    name := n;\n    orgName := org;\n    rackBundleVersion := rack;\n    bladeBundleVersion := blade;\n    description := desc;\n    mode := m;\n  }\n}\nclass FirmwareManager {\n  var packs: map<string, FirmwarePack>\n  \n  constructor()\n    ensures packs == map[]\n  {\n    packs := map[];\n  }\n  \n  method CreateFirmwarePack(\n    orgName: string, \n    name: string, \n    rackVersion: string, \n    bladeVersion: string, \n    desc: string := \"\", \n    mode: string := \"staged\"\n  ) returns (success: bool)\n    requires orgName != \"\"\n    requires name != \"\"\n    modifies this\n    ensures success ==> name in packs\n    ensures !success ==> packs == old(packs)\n  {\n    if name in packs {\n      success := false;\n      return;\n    }\n    \n    var pack := new FirmwarePack(name, orgName, rackVersion, bladeVersion, desc, mode);\n    packs := packs[name := pack];\n    success := true;\n  }\n  \n  method ModifyFirmwarePack(\n    orgName: string,\n    name: string,\n    rackVersion: string,\n    bladeVersion: string,\n    desc: string,\n    mode: string\n  ) returns (success: bool)\n    requires orgName != \"\"\n    requires name != \"\"\n    modifies this, if name in packs then {packs[name]} else {}\n    ensures success ==> name in packs\n    ensures !success ==> packs == old(packs)\n    ensures success ==> packs[name].rackBundleVersion == rackVersion\n    ensures success ==> packs[name].bladeBundleVersion == bladeVersion\n  {\n    if name !in packs {\n      success := false;\n      return;\n    }\n    \n    var pack := packs[name];\n    pack.rackBundleVersion := rackVersion;\n    pack.bladeBundleVersion := bladeVersion;\n    pack.description := desc;\n    pack.mode := mode;\n    success := true;\n  }\n  \n  method RemoveFirmwarePack(orgName: string, name: string) returns (success: bool)\n    requires orgName != \"\"\n    requires name != \"\"\n    modifies this\n    ensures success ==> name !in packs\n    ensures !success ==> packs == old(packs)\n    ensures forall k :: k in old(packs) && k != name ==> k in packs && packs[k] == old(packs)[k]\n  {\n    if name !in packs {\n      success := false;\n      return;\n    }\n    \n    packs := map k | k in packs && k != name :: packs[k];\n    success := true;\n  }\n}", "name": "py2dfy_399", "id": 399}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype LogEntry = LogEntry(phase1Finished: bool, phase4Finished: bool)\ndatatype PlotterState = PlotterState(logs: seq<LogEntry>, totalCores: nat, usedCores: nat)\nclass Plotter {\n  const CORES_PER_NEW_PLOT := 4\n  const TOTAL_LOGICAL_CORES: nat\n  var state: PlotterState\n  constructor(cores: nat)\n  {\n    TOTAL_LOGICAL_CORES := cores;\n    state := PlotterState([], cores, 0);\n  }\n  method CountUsedCores(logs: seq<LogEntry>) returns (usedCores: nat)\n  {\n    usedCores := 0;\n    var i := 0;\n    \n    while i < |logs|\n    {\n      var plotCores := CORES_PER_NEW_PLOT;\n      \n      if logs[i].phase1Finished {\n        plotCores := plotCores - 2;\n      }\n      if logs[i].phase4Finished {\n        plotCores := plotCores - 2;\n      }\n      \n      usedCores := usedCores + plotCores;\n      i := i + 1;\n    }\n    usedCores := if usedCores <= TOTAL_LOGICAL_CORES then usedCores else TOTAL_LOGICAL_CORES;\n  }\n  method TryAddPlot() returns (success: bool)\n            !success && state == old(state)\n  {\n    if state.usedCores + CORES_PER_NEW_PLOT <= TOTAL_LOGICAL_CORES {\n      var newLog := LogEntry(false, false);\n      state := PlotterState(state.logs + [newLog], \n                           state.totalCores, \n                           state.usedCores + CORES_PER_NEW_PLOT);\n      return true;\n    }\n    return false;\n  }\n  method RunPlotterLoop() returns (finalState: PlotterState) \n  {\n    while true\n    {\n      var usedCores := CountUsedCores(state.logs);\n      state := PlotterState(state.logs, state.totalCores, usedCores);\n      \n      var added := TryAddPlot();\n      if !added {\n        break;\n      }\n    }\n    return state;\n  }\n}", "output": "datatype LogEntry = LogEntry(phase1Finished: bool, phase4Finished: bool)\ndatatype PlotterState = PlotterState(logs: seq<LogEntry>, totalCores: nat, usedCores: nat)\nclass Plotter {\n  const CORES_PER_NEW_PLOT := 4\n  const TOTAL_LOGICAL_CORES: nat\n  var state: PlotterState\n  constructor(cores: nat)\n    requires cores > 0 \n    ensures TOTAL_LOGICAL_CORES == cores\n    ensures fresh(this)\n    ensures state.totalCores == cores\n    ensures state.logs == []\n    ensures state.usedCores == 0\n  {\n    TOTAL_LOGICAL_CORES := cores;\n    state := PlotterState([], cores, 0);\n  }\n  method CountUsedCores(logs: seq<LogEntry>) returns (usedCores: nat)\n    ensures usedCores <= TOTAL_LOGICAL_CORES\n  {\n    usedCores := 0;\n    var i := 0;\n    \n    while i < |logs|\n      invariant 0 <= i <= |logs|\n      invariant usedCores <= i * CORES_PER_NEW_PLOT\n    {\n      var plotCores := CORES_PER_NEW_PLOT;\n      \n      if logs[i].phase1Finished {\n        plotCores := plotCores - 2;\n      }\n      if logs[i].phase4Finished {\n        plotCores := plotCores - 2;\n      }\n      \n      usedCores := usedCores + plotCores;\n      i := i + 1;\n    }\n    usedCores := if usedCores <= TOTAL_LOGICAL_CORES then usedCores else TOTAL_LOGICAL_CORES;\n  }\n  method TryAddPlot() returns (success: bool)\n    modifies this\n    ensures old(state.usedCores) + CORES_PER_NEW_PLOT > TOTAL_LOGICAL_CORES ==> \n            !success && state == old(state)\n    ensures success ==> state.usedCores == old(state.usedCores) + CORES_PER_NEW_PLOT\n    ensures state.totalCores == old(state.totalCores)\n  {\n    if state.usedCores + CORES_PER_NEW_PLOT <= TOTAL_LOGICAL_CORES {\n      var newLog := LogEntry(false, false);\n      state := PlotterState(state.logs + [newLog], \n                           state.totalCores, \n                           state.usedCores + CORES_PER_NEW_PLOT);\n      return true;\n    }\n    return false;\n  }\n  method RunPlotterLoop() returns (finalState: PlotterState) \n    modifies this\n    ensures finalState.totalCores == old(state.totalCores)\n    decreases *\n  {\n    while true\n      invariant state.totalCores == old(state.totalCores)\n      decreases *\n    {\n      var usedCores := CountUsedCores(state.logs);\n      state := PlotterState(state.logs, state.totalCores, usedCores);\n      \n      var added := TryAddPlot();\n      if !added {\n        break;\n      }\n    }\n    return state;\n  }\n}", "name": "py2dfy_414", "id": 414}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Configuration {\n  var sqlUrl: string\n  var trackModifications: bool\n  constructor()\n  {\n    sqlUrl := \"default_url\";  \n    trackModifications := false;\n  }\n  method GetSqlUrl() returns (url: string)\n  {\n    url := sqlUrl;\n    return url;\n  }\n}\nclass Database {\n  var isInitialized: bool\n  var config: Configuration?\n  constructor()\n  {\n    isInitialized := false;\n    config := null;\n  }\n  method Initialize(conf: Configuration?) returns (success: bool)\n  {\n    if conf != null {\n      config := conf;\n      isInitialized := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass MigrationManager {\n  var db: Database?\n  var commands: seq<string>  \n  constructor()\n  {\n    db := null;\n    commands := [];\n  }\n  method AddCommand(cmd: string) returns (success: bool)\n  {\n    commands := commands + [cmd];\n    return true;\n  }\n  method RunMigrations() returns (success: bool)\n  {\n    if |commands| > 0 {\n      \n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}", "output": "class Configuration {\n  var sqlUrl: string\n  var trackModifications: bool\n  constructor()\n    ensures sqlUrl != \"\"  \n    ensures !trackModifications  \n  {\n    sqlUrl := \"default_url\";  \n    trackModifications := false;\n  }\n  method GetSqlUrl() returns (url: string)\n    ensures url == sqlUrl  \n    ensures url != \"\"  \n    requires sqlUrl != \"\" \n  {\n    url := sqlUrl;\n    return url;\n  }\n}\nclass Database {\n  var isInitialized: bool\n  var config: Configuration?\n  constructor()\n    ensures !isInitialized  \n    ensures config == null  \n  {\n    isInitialized := false;\n    config := null;\n  }\n  method Initialize(conf: Configuration?) returns (success: bool)\n    requires conf != null  \n    modifies this\n    ensures success ==> isInitialized  \n    ensures success ==> config == conf  \n    ensures !success ==> old(isInitialized) == isInitialized  \n  {\n    if conf != null {\n      config := conf;\n      isInitialized := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}\nclass MigrationManager {\n  var db: Database?\n  var commands: seq<string>  \n  constructor()\n    ensures db == null\n    ensures |commands| == 0  \n  {\n    db := null;\n    commands := [];\n  }\n  method AddCommand(cmd: string) returns (success: bool)\n    requires cmd != \"\"  \n    modifies this`commands\n    ensures success\n    ensures |commands| == |old(commands)| + 1  \n    ensures commands[|commands|-1] == cmd  \n    ensures forall i :: 0 <= i < |old(commands)| ==> commands[i] == old(commands)[i]  \n  {\n    commands := commands + [cmd];\n    return true;\n  }\n  method RunMigrations() returns (success: bool)\n    requires db != null\n    requires db.isInitialized\n    ensures success ==> |commands| > 0  \n  {\n    if |commands| > 0 {\n      \n      success := true;\n    } else {\n      success := false;\n    }\n  }\n}", "name": "py2dfy_403", "id": 403}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method add_numbers(a: int, b: int) returns (result: int)\n{\n  result := a + b;\n}\nmethod subtract_numbers(a: int, b: int) returns (result: int)\n{\n  result := a - b;\n}\nmethod multiply_numbers(a: int, b: int) returns (result: int)\n{\n  result := a * b;\n}\nmethod divide_numbers(a: int, b: int) returns (result: int)\n{\n  result := a / b;\n}\nmethod test_add_numbers()\n{\n  var result := add_numbers(10, 5);\n}\nmethod test_subtract_numbers()\n{\n  var result := subtract_numbers(10, 5);\n}\nmethod test_multiply_numbers()\n{\n  var result := multiply_numbers(10, 5);\n}\nmethod test_divide_numbers()\n{\n  var result := divide_numbers(10, 5);\n}\nmethod Main()\n{\n  test_add_numbers();\n  test_subtract_numbers();\n  test_multiply_numbers();\n  test_divide_numbers();\n  print \"All tests passed!\\n\";\n}", "output": "method add_numbers(a: int, b: int) returns (result: int)\n  ensures result == a + b  \n{\n  result := a + b;\n}\nmethod subtract_numbers(a: int, b: int) returns (result: int)\n  ensures result == a - b  \n{\n  result := a - b;\n}\nmethod multiply_numbers(a: int, b: int) returns (result: int)\n  ensures result == a * b  \n{\n  result := a * b;\n}\nmethod divide_numbers(a: int, b: int) returns (result: int)\n  requires b != 0  \n  ensures result == a / b  \n{\n  result := a / b;\n}\nmethod test_add_numbers()\n{\n  var result := add_numbers(10, 5);\n  assert result == 15;  \n}\nmethod test_subtract_numbers()\n{\n  var result := subtract_numbers(10, 5);\n  assert result == 5;  \n}\nmethod test_multiply_numbers()\n{\n  var result := multiply_numbers(10, 5);\n  assert result == 50;  \n}\nmethod test_divide_numbers()\n{\n  var result := divide_numbers(10, 5);\n  assert result == 2;  \n}\nmethod Main()\n{\n  test_add_numbers();\n  test_subtract_numbers();\n  test_multiply_numbers();\n  test_divide_numbers();\n  print \"All tests passed!\\n\";\n}", "name": "py2dfy_416", "id": 416}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CompareNumbers(a: int, b: int) returns (result: string)\n          result == \"First number is larger\" || \n          result == \"Numbers are equal\"\n{\n  if a < b {\n    result := \"First number is smaller\";\n  } else if a > b {\n    result := \"First number is larger\";\n  } else {\n    result := \"Numbers are equal\";\n  }\n}\nmethod Main()\n{\n  \n  \n  var result := CompareNumbers(5, 10);\n  print result, \"\\n\";\n  \n  \n  \n}", "output": "method CompareNumbers(a: int, b: int) returns (result: string)\n  ensures result == \"First number is smaller\" || \n          result == \"First number is larger\" || \n          result == \"Numbers are equal\"\n  ensures result == \"First number is smaller\" ==> a < b\n  ensures result == \"First number is larger\" ==> a > b\n  ensures result == \"Numbers are equal\" ==> a == b\n{\n  if a < b {\n    result := \"First number is smaller\";\n  } else if a > b {\n    result := \"First number is larger\";\n  } else {\n    result := \"Numbers are equal\";\n  }\n}\nmethod Main()\n{\n  \n  \n  var result := CompareNumbers(5, 10);\n  print result, \"\\n\";\n  \n  \n  \n}", "name": "py2dfy_461", "id": 461}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ItemType = Weapon | Armor | Potion | Accessory | Misc  \ndatatype Item = Item(name: string, value: int, rarity: int, itemType: ItemType)\nclass Player {\n  var gold: int\n  var inventory: map<string, (Item, int)>  \n  var charisma: int\n  constructor()\n  {\n    gold := 0;\n    charisma := 0;\n    inventory := map[];\n  }\n}\nmethod BuyItem(player: Player, item: Item, quantity: int) returns (success: bool)\n  \n  \n{\n  var adjustedPrice := CalculateAdjustedPrice(item.value, player.charisma, quantity);\n  \n  if player.gold >= adjustedPrice {\n    \n    player.gold := player.gold - adjustedPrice;\n    \n    \n    var currentQuantity := 0;\n    if item.name in player.inventory {\n      currentQuantity := player.inventory[item.name].1;\n    }\n    player.inventory := player.inventory[item.name := (item, currentQuantity + quantity)];\n    \n    return true;\n  }\n  \n  return false;\n}\nfunction CalculateAdjustedPrice(baseValue: int, charisma: int, quantity: int): int\n{\n  var discountedValue := if baseValue - (charisma * 2) > 1 then \n                           baseValue - (charisma * 2)\n                         else \n                           1;\n  discountedValue * quantity\n}\nmethod SellItem(player: Player, itemName: string, quantity: int) returns (success: bool)\n{\n  var item := player.inventory[itemName].0;\n  var currentQuantity := player.inventory[itemName].1;\n  \n  \n  var salePrice := (item.value * quantity) / 2 + (player.charisma * 2);\n  \n  \n  player.gold := player.gold + salePrice;\n  \n  \n  var newQuantity := currentQuantity - quantity;\n  if newQuantity == 0 {\n    player.inventory := map k | k in player.inventory && k != itemName :: player.inventory[k];\n  } else {\n    player.inventory := player.inventory[itemName := (item, newQuantity)];\n  }\n  \n  return true;\n}", "output": "datatype ItemType = Weapon | Armor | Potion | Accessory | Misc  \ndatatype Item = Item(name: string, value: int, rarity: int, itemType: ItemType)\nclass Player {\n  var gold: int\n  var inventory: map<string, (Item, int)>  \n  var charisma: int\n  constructor()\n    ensures gold == 0 && charisma == 0\n    ensures inventory == map[]\n  {\n    gold := 0;\n    charisma := 0;\n    inventory := map[];\n  }\n}\nmethod BuyItem(player: Player, item: Item, quantity: int) returns (success: bool)\n  requires quantity >= 0\n  \n  requires item.value > 0  \n  \n  requires player.gold >= CalculateAdjustedPrice(item.value, player.charisma, quantity)\n  modifies player`gold, player`inventory\n  ensures success ==> player.gold == old(player.gold) - CalculateAdjustedPrice(item.value, player.charisma, quantity)\n  ensures !success ==> player.gold == old(player.gold)\n  ensures success ==> player.inventory.Keys >= old(player.inventory.Keys)\n{\n  var adjustedPrice := CalculateAdjustedPrice(item.value, player.charisma, quantity);\n  \n  if player.gold >= adjustedPrice {\n    \n    player.gold := player.gold - adjustedPrice;\n    \n    \n    var currentQuantity := 0;\n    if item.name in player.inventory {\n      currentQuantity := player.inventory[item.name].1;\n    }\n    player.inventory := player.inventory[item.name := (item, currentQuantity + quantity)];\n    \n    return true;\n  }\n  \n  return false;\n}\nfunction CalculateAdjustedPrice(baseValue: int, charisma: int, quantity: int): int\n  requires baseValue > 0\n  requires quantity >= 0  \n  ensures CalculateAdjustedPrice(baseValue, charisma, quantity) >= 0\n{\n  var discountedValue := if baseValue - (charisma * 2) > 1 then \n                           baseValue - (charisma * 2)\n                         else \n                           1;\n  discountedValue * quantity\n}\nmethod SellItem(player: Player, itemName: string, quantity: int) returns (success: bool)\n  requires quantity > 0\n  requires itemName in player.inventory\n  requires player.inventory[itemName].1 >= quantity\n  modifies player`gold, player`inventory\n  ensures success\n  ensures itemName in old(player.inventory) ==> player.gold == old(player.gold) + ((old(player.inventory[itemName]).0.value * quantity) / 2 + (player.charisma * 2))\n  ensures (old(player.inventory[itemName]).1 > quantity) ==> (itemName in player.inventory && player.inventory[itemName].1 == old(player.inventory[itemName]).1 - quantity)\n  ensures (old(player.inventory[itemName]).1 == quantity) ==> (itemName !in player.inventory)\n{\n  var item := player.inventory[itemName].0;\n  var currentQuantity := player.inventory[itemName].1;\n  \n  \n  var salePrice := (item.value * quantity) / 2 + (player.charisma * 2);\n  \n  \n  player.gold := player.gold + salePrice;\n  \n  \n  var newQuantity := currentQuantity - quantity;\n  if newQuantity == 0 {\n    player.inventory := map k | k in player.inventory && k != itemName :: player.inventory[k];\n  } else {\n    player.inventory := player.inventory[itemName := (item, newQuantity)];\n  }\n  \n  return true;\n}", "name": "py2dfy_396", "id": 396}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype DIXMAANParams = DIXMAANParams(\n  alpha: real, \n  beta: real, \n  gamma: real, \n  sigma: real, \n  k1: int, \n  k2: int, \n  k3: int, \n  k4: int\n)\nclass DIXMAANTable {\n  var table: map<char, DIXMAANParams>\n  constructor()\n  {\n    table := map[\n      'A' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 0, 0, 0, 0),\n      'B' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 0, 0, 0, 1),\n      'C' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 0, 0, 0, 0),\n      'D' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 0, 0, 0, 0),\n      'E' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 1, 0, 0, 1),\n      'F' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 1, 0, 0, 1),\n      'G' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 1, 0, 0, 1),\n      'H' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 1, 0, 0, 1),\n      'I' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 2, 0, 0, 2),\n      'J' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 2, 0, 0, 2),\n      'K' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 2, 0, 0, 2),\n      'L' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 2, 0, 0, 2)\n    ];\n  }\n  method GetParams(paramType: char) returns (params: DIXMAANParams)\n  {\n    params := table[paramType];\n  }\n}\nmethod CalculateDIXMAAN(n: int, paramType: char, table: DIXMAANTable) returns (result: real)\n{\n  var params := table.GetParams(paramType);\n  var m := n / 3;\n  \n  var x := new real[n];\n  \n  var i := 0;\n  while i < n\n  {\n    x[i] := 2.0;\n    i := i + 1;\n  }\n  result := 1.0;\n}", "output": "datatype DIXMAANParams = DIXMAANParams(\n  alpha: real, \n  beta: real, \n  gamma: real, \n  sigma: real, \n  k1: int, \n  k2: int, \n  k3: int, \n  k4: int\n)\nclass DIXMAANTable {\n  var table: map<char, DIXMAANParams>\n  constructor()\n    ensures fresh(this)\n    ensures table.Keys == {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'}\n  {\n    table := map[\n      'A' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 0, 0, 0, 0),\n      'B' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 0, 0, 0, 1),\n      'C' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 0, 0, 0, 0),\n      'D' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 0, 0, 0, 0),\n      'E' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 1, 0, 0, 1),\n      'F' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 1, 0, 0, 1),\n      'G' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 1, 0, 0, 1),\n      'H' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 1, 0, 0, 1),\n      'I' := DIXMAANParams(1.0, 0.0, 0.125, 0.125, 2, 0, 0, 2),\n      'J' := DIXMAANParams(1.0, 0.0625, 0.0625, 0.0625, 2, 0, 0, 2),\n      'K' := DIXMAANParams(1.0, 0.125, 0.125, 0.125, 2, 0, 0, 2),\n      'L' := DIXMAANParams(1.0, 0.26, 0.26, 0.26, 2, 0, 0, 2)\n    ];\n  }\n  method GetParams(paramType: char) returns (params: DIXMAANParams)\n    requires paramType in table.Keys\n    ensures params == table[paramType]\n  {\n    params := table[paramType];\n  }\n}\nmethod CalculateDIXMAAN(n: int, paramType: char, table: DIXMAANTable) returns (result: real)\n  requires n > 0 && n % 3 == 0  \n  requires paramType in table.table.Keys\n  ensures result > 0.0  \n{\n  var params := table.GetParams(paramType);\n  var m := n / 3;\n  \n  var x := new real[n];\n  \n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall j :: 0 <= j < i ==> x[j] == 2.0\n  {\n    x[i] := 2.0;\n    i := i + 1;\n  }\n  result := 1.0;\n}", "name": "py2dfy_442", "id": 442}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Abc = End | Wrapper(seq<Abc>)\nlemma SeqRank0(a: Abc)\n{\n                       \n                       \n                       \n}\nlemma SeqRank1(s: seq<Abc>)\n{\n}\ndatatype Def = End | MultiWrapper(multiset<Def>)\nlemma MultisetRank(a: Def)\n{\n}\ndatatype Ghi = End | SetWrapper(set<Ghi>)\nlemma SetRank(a: Ghi)\n{\n}", "output": "datatype Abc = End | Wrapper(seq<Abc>)\nlemma SeqRank0(a: Abc)\n  ensures a != Wrapper([a])\n{\n  assert [a][0] == a;  \n                       \n                       \n                       \n}\nlemma SeqRank1(s: seq<Abc>)\n  requires s != []\n  ensures s[0] != Wrapper(s)\n{\n}\ndatatype Def = End | MultiWrapper(multiset<Def>)\nlemma MultisetRank(a: Def)\n  ensures a != MultiWrapper(multiset{a})\n{\n}\ndatatype Ghi = End | SetWrapper(set<Ghi>)\nlemma SetRank(a: Ghi)\n  ensures a != SetWrapper({a})\n{\n}", "name": "py2dfy_440", "id": 440}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class SellerInfo {\n  var aadharNo: string\n  var panNo: string\n  var gmailId: string\n  var password: string\n  constructor()\n  {\n    aadharNo := \"\";\n    panNo := \"\";\n    gmailId := \"\";\n    password := \"\";\n  }\n  predicate Valid()\n  {\n    |aadharNo| <= 50 &&\n    |panNo| <= 50 &&\n    |gmailId| <= 100 &&\n    |password| <= 50 &&\n    IsValidEmail(gmailId)\n  }\n  method UpdateAadharNo(newAadharNo: string)\n  {\n    aadharNo := newAadharNo;\n  }\n  method UpdatePanNo(newPanNo: string)\n  {\n    panNo := newPanNo;\n  }\n  method UpdateGmailId(newGmailId: string)\n  {\n    gmailId := newGmailId;\n  }\n  method UpdatePassword(newPassword: string)\n  {\n    password := newPassword;\n  }\n}\nfunction IsValidEmail(email: string): bool\n{\n  true \n}\nclass BungalowInfo {\n  var bedHK: string\n  var carpetArea: string\n  var groundArea: string\n  var latitude: string\n  var longitude: string\n  var location: string\n  var name: string\n  var price: string\n  constructor()\n  {\n    bedHK := \"\";\n    carpetArea := \"\";\n    groundArea := \"\";\n    latitude := \"\";\n    longitude := \"\";\n    location := \"\";\n    name := \"\";\n    price := \"\";\n  }\n  predicate Valid()\n  {\n    |bedHK| <= 50 &&\n    |carpetArea| <= 50 &&\n    |groundArea| <= 50 &&\n    |latitude| <= 100 &&\n    |longitude| <= 100 &&\n    |location| <= 50 &&\n    |name| <= 50 &&\n    |price| <= 100\n  }\n}", "output": "class SellerInfo {\n  var aadharNo: string\n  var panNo: string\n  var gmailId: string\n  var password: string\n  constructor()\n    ensures Valid()\n  {\n    aadharNo := \"\";\n    panNo := \"\";\n    gmailId := \"\";\n    password := \"\";\n  }\n  predicate Valid()\n    reads this\n  {\n    |aadharNo| <= 50 &&\n    |panNo| <= 50 &&\n    |gmailId| <= 100 &&\n    |password| <= 50 &&\n    IsValidEmail(gmailId)\n  }\n  method UpdateAadharNo(newAadharNo: string)\n    requires |newAadharNo| <= 50\n    requires Valid()\n    modifies this\n    ensures aadharNo == newAadharNo\n    ensures Valid()\n    ensures panNo == old(panNo)\n    ensures gmailId == old(gmailId)\n    ensures password == old(password)\n  {\n    aadharNo := newAadharNo;\n  }\n  method UpdatePanNo(newPanNo: string)\n    requires |newPanNo| <= 50\n    requires Valid()\n    modifies this\n    ensures panNo == newPanNo\n    ensures Valid()\n    ensures aadharNo == old(aadharNo)\n    ensures gmailId == old(gmailId)\n    ensures password == old(password)\n  {\n    panNo := newPanNo;\n  }\n  method UpdateGmailId(newGmailId: string)\n    requires |newGmailId| <= 100\n    requires IsValidEmail(newGmailId)\n    requires Valid()\n    modifies this\n    ensures gmailId == newGmailId\n    ensures Valid()\n    ensures aadharNo == old(aadharNo)\n    ensures panNo == old(panNo)\n    ensures password == old(password)\n  {\n    gmailId := newGmailId;\n  }\n  method UpdatePassword(newPassword: string)\n    requires |newPassword| <= 50\n    requires Valid()\n    modifies this\n    ensures password == newPassword\n    ensures Valid()\n    ensures aadharNo == old(aadharNo)\n    ensures panNo == old(panNo)\n    ensures gmailId == old(gmailId)\n  {\n    password := newPassword;\n  }\n}\nfunction IsValidEmail(email: string): bool\n{\n  true \n}\nclass BungalowInfo {\n  var bedHK: string\n  var carpetArea: string\n  var groundArea: string\n  var latitude: string\n  var longitude: string\n  var location: string\n  var name: string\n  var price: string\n  constructor()\n    ensures Valid()\n  {\n    bedHK := \"\";\n    carpetArea := \"\";\n    groundArea := \"\";\n    latitude := \"\";\n    longitude := \"\";\n    location := \"\";\n    name := \"\";\n    price := \"\";\n  }\n  predicate Valid()\n    reads this\n  {\n    |bedHK| <= 50 &&\n    |carpetArea| <= 50 &&\n    |groundArea| <= 50 &&\n    |latitude| <= 100 &&\n    |longitude| <= 100 &&\n    |location| <= 50 &&\n    |name| <= 50 &&\n    |price| <= 100\n  }\n}", "name": "py2dfy_404", "id": 404}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module PathOperations {\n  \n  type Path = seq<char>\n  \n  \n  method AppendPath(paths: seq<Path>, newPath: Path) returns (result: seq<Path>)\n    \n    \n    \n    \n  {\n    \n    result := paths + [newPath];\n  }\n  \n  method AddLibPath(currentPaths: seq<Path>) returns (updatedPaths: seq<Path>)\n    \n    \n    \n  {\n    \n    var libPath: Path := \"./lib\";\n    \n    updatedPaths := AppendPath(currentPaths, libPath);\n  }\n}", "output": "module PathOperations {\n  \n  type Path = seq<char>\n  \n  \n  method AppendPath(paths: seq<Path>, newPath: Path) returns (result: seq<Path>)\n    \n    requires |newPath| > 0\n    \n    ensures |result| == |paths| + 1\n    \n    ensures result[|result|-1] == newPath\n    \n    ensures forall i :: 0 <= i < |paths| ==> result[i] == paths[i]\n  {\n    \n    result := paths + [newPath];\n  }\n  \n  method AddLibPath(currentPaths: seq<Path>) returns (updatedPaths: seq<Path>)\n    \n    ensures |updatedPaths| == |currentPaths| + 1\n    \n    ensures updatedPaths[|updatedPaths|-1] == \"./lib\"\n    \n    ensures forall i :: 0 <= i < |currentPaths| ==> updatedPaths[i] == currentPaths[i]\n  {\n    \n    var libPath: Path := \"./lib\";\n    \n    updatedPaths := AppendPath(currentPaths, libPath);\n  }\n}", "name": "py2dfy_429", "id": 429}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype AccelReading = AccelReading(x: real, y: real, z: real, timestamp: int)\nclass AccelDataset {\n    var readings: seq<AccelReading>\n    ghost var Repr: set<object>\n    predicate Valid()\n    {\n        true\n    }\n    constructor()\n    {\n        readings := [];\n        Repr := {this};\n    }\n    \n    method AddReading(x: real, y: real, z: real, ts: int)\n    {\n        readings := readings + [AccelReading(x, y, z, ts)];\n    }\n    \n    method GetCount() returns (count: nat)\n    {\n        count := |readings|;\n    }\n    \n    method GetReading(index: nat) returns (reading: AccelReading)\n    {\n        reading := readings[index];\n    }\n}\nmethod ProcessReadings(dataset: AccelDataset) returns (\n    xVals: seq<real>, \n    yVals: seq<real>, \n    zVals: seq<real>, \n    tVals: seq<int>\n)\n        xVals[i] == dataset.readings[i].x &&\n        yVals[i] == dataset.readings[i].y &&\n        zVals[i] == dataset.readings[i].z &&\n        tVals[i] == dataset.readings[i].timestamp\n{\n    var count := dataset.GetCount();\n    \n    \n    xVals := [];\n    yVals := [];\n    zVals := [];\n    tVals := [];\n    \n    var i := 0;\n    while i < count\n            xVals[j] == dataset.readings[j].x &&\n            yVals[j] == dataset.readings[j].y &&\n            zVals[j] == dataset.readings[j].z &&\n            tVals[j] == dataset.readings[j].timestamp\n    {\n        var reading := dataset.GetReading(i);\n        xVals := xVals + [reading.x];\n        yVals := yVals + [reading.y];\n        zVals := zVals + [reading.z];\n        tVals := tVals + [reading.timestamp];\n        i := i + 1;\n    }\n}", "output": "datatype AccelReading = AccelReading(x: real, y: real, z: real, timestamp: int)\nclass AccelDataset {\n    var readings: seq<AccelReading>\n    ghost var Repr: set<object>\n    predicate Valid()\n        reads this\n    {\n        true\n    }\n    constructor()\n        ensures Valid()\n        ensures fresh(this)\n        ensures readings == []\n    {\n        readings := [];\n        Repr := {this};\n    }\n    \n    method AddReading(x: real, y: real, z: real, ts: int)\n        requires Valid()\n        modifies this\n        ensures Valid()\n        ensures readings == old(readings) + [AccelReading(x, y, z, ts)]\n    {\n        readings := readings + [AccelReading(x, y, z, ts)];\n    }\n    \n    method GetCount() returns (count: nat)\n        requires Valid()\n        ensures count == |readings|\n    {\n        count := |readings|;\n    }\n    \n    method GetReading(index: nat) returns (reading: AccelReading)\n        requires Valid()\n        requires index < |readings|\n        ensures reading == readings[index]\n    {\n        reading := readings[index];\n    }\n}\nmethod ProcessReadings(dataset: AccelDataset) returns (\n    xVals: seq<real>, \n    yVals: seq<real>, \n    zVals: seq<real>, \n    tVals: seq<int>\n)\n    requires dataset.Valid()\n    ensures |xVals| == |dataset.readings|\n    ensures |yVals| == |dataset.readings|\n    ensures |zVals| == |dataset.readings|\n    ensures |tVals| == |dataset.readings|\n    ensures forall i :: 0 <= i < |dataset.readings| ==>\n        xVals[i] == dataset.readings[i].x &&\n        yVals[i] == dataset.readings[i].y &&\n        zVals[i] == dataset.readings[i].z &&\n        tVals[i] == dataset.readings[i].timestamp\n{\n    var count := dataset.GetCount();\n    \n    \n    xVals := [];\n    yVals := [];\n    zVals := [];\n    tVals := [];\n    \n    var i := 0;\n    while i < count\n        invariant 0 <= i <= count\n        invariant |xVals| == i\n        invariant |yVals| == i\n        invariant |zVals| == i\n        invariant |tVals| == i\n        invariant forall j :: 0 <= j < i ==>\n            xVals[j] == dataset.readings[j].x &&\n            yVals[j] == dataset.readings[j].y &&\n            zVals[j] == dataset.readings[j].z &&\n            tVals[j] == dataset.readings[j].timestamp\n    {\n        var reading := dataset.GetReading(i);\n        xVals := xVals + [reading.x];\n        yVals := yVals + [reading.y];\n        zVals := zVals + [reading.z];\n        tVals := tVals + [reading.timestamp];\n        i := i + 1;\n    }\n}", "name": "py2dfy_431", "id": 431}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class LazyMap<T,U> {\n  var data: seq<T>\n  var f: T -> U\n  \n  predicate Valid()\n  {\n    |data| >= 0\n  }\n  constructor(input: seq<T>, fn: T -> U)\n  {\n    data := input;\n    f := fn;\n  }\n  function Length(): nat\n  {\n    |data|\n  }\n  method Get(index: nat) returns (result: U)\n  {\n    result := f(data[index]);\n  }\n  method Slice(start: nat, end: nat) returns (result: LazyMap<T,U>)\n  {\n    var sliced := data[start..end];\n    result := new LazyMap(sliced, f);\n  }\n  function ToString(): string\n  {\n    \"<LazyMap [\" + ToStringHelper(0) + \"]>\"\n  }\n  function ToStringHelper(i: nat): string\n  {\n    if i >= |data| then\n      \"\"\n    else if i == |data| - 1 then\n      DataToString(data[i])\n    else\n      DataToString(data[i]) + \", \" + ToStringHelper(i + 1)\n  }\n  function DataToString(x: T): string\n}\nmethod TestLazyMap()\n{\n  var data := seq(10, i => i);\n  var doubleFunc := (x: int) => 2 * x;\n    \n  var lm := new LazyMap(data, doubleFunc);\n    \n  var len := lm.Length();\n    \n  var val := lm.Get(1);\n    \n  var sliced := lm.Slice(1, 4);\n}", "output": "class LazyMap<T,U> {\n  var data: seq<T>\n  var f: T -> U\n  \n  predicate Valid()\n    reads this\n  {\n    |data| >= 0\n  }\n  constructor(input: seq<T>, fn: T -> U)\n    ensures Valid()\n    ensures data == input\n    ensures f == fn\n  {\n    data := input;\n    f := fn;\n  }\n  function Length(): nat\n    requires Valid()\n    reads this\n    ensures Length() == |data|\n  {\n    |data|\n  }\n  method Get(index: nat) returns (result: U)\n    requires Valid()\n    requires index < |data|\n    ensures result == f(data[index])\n  {\n    result := f(data[index]);\n  }\n  method Slice(start: nat, end: nat) returns (result: LazyMap<T,U>)\n    requires Valid()\n    requires start <= end <= |data|\n    ensures fresh(result)\n    ensures result.Valid()\n    ensures result.data == data[start..end]\n    ensures result.f == f\n  {\n    var sliced := data[start..end];\n    result := new LazyMap(sliced, f);\n  }\n  function ToString(): string\n    requires Valid()\n    reads this\n    ensures ToString() != \"\"\n  {\n    \"<LazyMap [\" + ToStringHelper(0) + \"]>\"\n  }\n  function ToStringHelper(i: nat): string\n    requires Valid()\n    reads this\n    decreases |data| - i\n  {\n    if i >= |data| then\n      \"\"\n    else if i == |data| - 1 then\n      DataToString(data[i])\n    else\n      DataToString(data[i]) + \", \" + ToStringHelper(i + 1)\n  }\n  function DataToString(x: T): string\n}\nmethod TestLazyMap()\n{\n  var data := seq(10, i => i);\n  var doubleFunc := (x: int) => 2 * x;\n    \n  var lm := new LazyMap(data, doubleFunc);\n    \n  var len := lm.Length();\n  assert len == 10;\n    \n  var val := lm.Get(1);\n  assert val == 2;\n    \n  var sliced := lm.Slice(1, 4);\n  assert sliced.Length() == 3;\n}", "name": "py2dfy_394", "id": 394}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Status = DEACTIVATE | ACTIVATE | EMPTY | WARNING | ERROR\nclass Profile {\n  var cookieStatus: Status\n  \n  constructor(status: Status)\n  {\n    cookieStatus := status;\n  }\n}\nclass User {\n  var profile: Profile?\n  \n  constructor(p: Profile)\n  {\n    profile := p;\n  }\n}\ndatatype HttpResponse = Response(content: map<string, string>)\nmethod CheckCookie(userId: string, users: map<string, User>) returns (response: HttpResponse)\n  \n  \n  \n    \"cookie_status\" in response.content &&\n    response.content[\"cookie_status\"] in {\"0\", \"1\", \"2\", \"3\", \"4\"}\n{\n  var result := map[\"status\" := \"true\"];\n  \n  if userId in users {\n    var user := users[userId];\n    if user.profile != null {\n      var cookieStatus := user.profile.cookieStatus;\n      \n      \n      match cookieStatus {\n        case DEACTIVATE => result := result[\"cookie_status\" := \"0\"];\n        case ACTIVATE   => result := result[\"cookie_status\" := \"1\"];\n        case EMPTY      => result := result[\"cookie_status\" := \"2\"];\n        case WARNING    => result := result[\"cookie_status\" := \"3\"];\n        case ERROR      => result := result[\"cookie_status\" := \"4\"];\n      }\n    } else {\n      result := result[\"status\" := \"false\"];\n    }\n  } else {\n    result := result[\"status\" := \"false\"];\n  }\n  \n  return Response(result);\n}", "output": "datatype Status = DEACTIVATE | ACTIVATE | EMPTY | WARNING | ERROR\nclass Profile {\n  var cookieStatus: Status\n  \n  constructor(status: Status)\n    ensures cookieStatus == status\n  {\n    cookieStatus := status;\n  }\n}\nclass User {\n  var profile: Profile?\n  \n  constructor(p: Profile)\n    ensures profile == p\n  {\n    profile := p;\n  }\n}\ndatatype HttpResponse = Response(content: map<string, string>)\nmethod CheckCookie(userId: string, users: map<string, User>) returns (response: HttpResponse)\n  \n  ensures \"status\" in response.content\n  \n  ensures response.content[\"status\"] in {\"true\", \"false\"}\n  \n  ensures response.content[\"status\"] == \"true\" ==>\n    \"cookie_status\" in response.content &&\n    response.content[\"cookie_status\"] in {\"0\", \"1\", \"2\", \"3\", \"4\"}\n{\n  var result := map[\"status\" := \"true\"];\n  \n  if userId in users {\n    var user := users[userId];\n    if user.profile != null {\n      var cookieStatus := user.profile.cookieStatus;\n      \n      \n      match cookieStatus {\n        case DEACTIVATE => result := result[\"cookie_status\" := \"0\"];\n        case ACTIVATE   => result := result[\"cookie_status\" := \"1\"];\n        case EMPTY      => result := result[\"cookie_status\" := \"2\"];\n        case WARNING    => result := result[\"cookie_status\" := \"3\"];\n        case ERROR      => result := result[\"cookie_status\" := \"4\"];\n      }\n    } else {\n      result := result[\"status\" := \"false\"];\n    }\n  } else {\n    result := result[\"status\" := \"false\"];\n  }\n  \n  return Response(result);\n}", "name": "py2dfy_454", "id": 454}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class ModelRegistry {\n  \n  var modelNames: seq<string>\n  \n  method InitializeModelRegistry()\n                          \"sg_model\", \"tinynet_model\", \"vggm_model\"]\n  {\n    modelNames := [\"deepID_model\", \"lenet_model\", \"resnet80_model\", \n                   \"sg_model\", \"tinynet_model\", \"vggm_model\"];\n  }\n  \n  method GetAllModelNames() returns (names: seq<string>)\n  {\n    names := modelNames;\n  }\n  \n  method IsModelRegistered(modelName: string) returns (isRegistered: bool)\n  {\n    isRegistered := modelName in modelNames;\n  }\n}", "output": "class ModelRegistry {\n  \n  var modelNames: seq<string>\n  \n  method InitializeModelRegistry()\n    modifies this\n    ensures modelNames == [\"deepID_model\", \"lenet_model\", \"resnet80_model\", \n                          \"sg_model\", \"tinynet_model\", \"vggm_model\"]\n  {\n    modelNames := [\"deepID_model\", \"lenet_model\", \"resnet80_model\", \n                   \"sg_model\", \"tinynet_model\", \"vggm_model\"];\n  }\n  \n  method GetAllModelNames() returns (names: seq<string>)\n    ensures names == modelNames\n    ensures |names| == |modelNames|\n  {\n    names := modelNames;\n  }\n  \n  method IsModelRegistered(modelName: string) returns (isRegistered: bool)\n    ensures isRegistered <==> modelName in modelNames\n  {\n    isRegistered := modelName in modelNames;\n  }\n}", "name": "py2dfy_455", "id": 455}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module PreprocessScript {\n  datatype ConfigEntry = ConfigEntry(key: string, value: string)\n  \n  datatype ValidationResult = \n    | Success\n    | Failure(errors: seq<string>)\n  class Configuration {\n    var entries: seq<ConfigEntry>\n    \n    ghost var isValid: bool\n    constructor()\n    {\n      entries := [];\n      isValid := false;\n    }\n  }\n  method ValidateConfiguration(config: Configuration) returns (result: ValidationResult)\n  {\n    var errors: seq<string> := [];\n    \n    var i := 0;\n    while i < |config.entries|\n    {\n      if !ValidEntry(config.entries[i]) {\n        var msg := GetErrorMessage(config.entries[i]);\n        errors := errors + [msg];\n      }\n      i := i + 1;\n    }\n    if |errors| == 0 {\n      config.isValid := true;\n      return Success;\n    } else {\n      config.isValid := false;\n      return Failure(errors);\n    }\n  }\n  predicate ValidEntry(entry: ConfigEntry)\n  {\n    |entry.key| > 0 && |entry.value| > 0\n  }\n  method GetErrorMessage(entry: ConfigEntry) returns (msg: string)\n  {\n    msg := \"Invalid entry: \" + entry.key;\n  }\n  method CompileProgram() returns (success: bool, errorMsg: string)\n  {\n    success := true;\n    errorMsg := \"\";\n  }\n  method Main() returns (exitCode: int)\n  {\n    var config := new Configuration();\n    \n    var validationResult := ValidateConfiguration(config);\n    if validationResult.Failure? {\n      return -11;\n    }\n    var compilationSuccess, compilationError := CompileProgram();\n    if !compilationSuccess {\n      return -1;\n    }\n    return 0;\n  }\n}", "output": "module PreprocessScript {\n  datatype ConfigEntry = ConfigEntry(key: string, value: string)\n  \n  datatype ValidationResult = \n    | Success\n    | Failure(errors: seq<string>)\n  class Configuration {\n    var entries: seq<ConfigEntry>\n    \n    ghost var isValid: bool\n    constructor()\n      ensures entries == []\n      ensures isValid == false\n    {\n      entries := [];\n      isValid := false;\n    }\n  }\n  method ValidateConfiguration(config: Configuration) returns (result: ValidationResult)\n    ensures result.Success? ==> config.isValid\n    ensures result.Failure? ==> !config.isValid\n    modifies config\n  {\n    var errors: seq<string> := [];\n    \n    var i := 0;\n    while i < |config.entries|\n      invariant 0 <= i <= |config.entries|\n      invariant |errors| >= 0\n      invariant forall j :: 0 <= j < i ==> !ValidEntry(config.entries[j]) ==> |errors| > 0\n    {\n      if !ValidEntry(config.entries[i]) {\n        var msg := GetErrorMessage(config.entries[i]);\n        errors := errors + [msg];\n      }\n      i := i + 1;\n    }\n    if |errors| == 0 {\n      config.isValid := true;\n      return Success;\n    } else {\n      config.isValid := false;\n      return Failure(errors);\n    }\n  }\n  predicate ValidEntry(entry: ConfigEntry)\n  {\n    |entry.key| > 0 && |entry.value| > 0\n  }\n  method GetErrorMessage(entry: ConfigEntry) returns (msg: string)\n    ensures |msg| > 0\n  {\n    msg := \"Invalid entry: \" + entry.key;\n  }\n  method CompileProgram() returns (success: bool, errorMsg: string)\n    ensures success ==> errorMsg == \"\"\n    ensures !success ==> |errorMsg| > 0\n  {\n    success := true;\n    errorMsg := \"\";\n  }\n  method Main() returns (exitCode: int)\n    ensures exitCode == 0 ==> exitCode >= 0\n    ensures exitCode != 0 ==> exitCode < 0\n  {\n    var config := new Configuration();\n    \n    var validationResult := ValidateConfiguration(config);\n    if validationResult.Failure? {\n      return -11;\n    }\n    var compilationSuccess, compilationError := CompileProgram();\n    if !compilationSuccess {\n      return -1;\n    }\n    return 0;\n  }\n}", "name": "py2dfy_420", "id": 420}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CommonPrefix(str1: string, str2: string) returns (result: string)\n{\n  result := \"\";\n  var i := 0;\n  while i < |str1| && str1[i] in str2\n  {\n    result := result + [str1[i]];\n    i := i + 1;\n  }\n}\nmethod FindFirstCommonChar(str1: string, str2: string) returns (nPos: int)\n{\n  nPos := -1;\n  var i := 0;\n  while i < |str1|\n  {\n    if str1[i] in str2 {\n      nPos := i;\n      break;\n    }\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var str1 := \"12345678\";\n  var str2 := \"456\";\n  var commonPrefix := CommonPrefix(str1, str2);\n  print \"Common prefix: \", commonPrefix, \"\\n\";\n  str1 := \"cekjgdklab\";\n  str2 := \"gka\";\n  var firstCommonPos := FindFirstCommonChar(str1, str2);\n  print \"Position of first common character: \", firstCommonPos, \"\\n\";\n}", "output": "method CommonPrefix(str1: string, str2: string) returns (result: string)\n  ensures |result| <= |str1|\n  ensures forall i :: 0 <= i < |result| ==> str1[i] in str2\n  ensures |result| == |str1| || (|result| < |str1| && str1[|result|] !in str2)\n{\n  result := \"\";\n  var i := 0;\n  while i < |str1| && str1[i] in str2\n    invariant 0 <= i <= |str1|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> str1[j] in str2\n  {\n    result := result + [str1[i]];\n    i := i + 1;\n  }\n}\nmethod FindFirstCommonChar(str1: string, str2: string) returns (nPos: int)\n  ensures -1 <= nPos < |str1|\n  ensures nPos == -1 ==> forall i :: 0 <= i < |str1| ==> str1[i] !in str2\n  ensures nPos != -1 ==> str1[nPos] in str2 && forall i :: 0 <= i < nPos ==> str1[i] !in str2\n{\n  nPos := -1;\n  var i := 0;\n  while i < |str1|\n    invariant 0 <= i <= |str1|\n    invariant -1 <= nPos < i\n    invariant nPos == -1 ==> forall j :: 0 <= j < i ==> str1[j] !in str2\n    invariant nPos != -1 ==> str1[nPos] in str2 && forall j :: 0 <= j < nPos ==> str1[j] !in str2\n  {\n    if str1[i] in str2 {\n      nPos := i;\n      break;\n    }\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  var str1 := \"12345678\";\n  var str2 := \"456\";\n  var commonPrefix := CommonPrefix(str1, str2);\n  print \"Common prefix: \", commonPrefix, \"\\n\";\n  str1 := \"cekjgdklab\";\n  str2 := \"gka\";\n  var firstCommonPos := FindFirstCommonChar(str1, str2);\n  print \"Position of first common character: \", firstCommonPos, \"\\n\";\n}", "name": "py2dfy_432", "id": 432}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Mode = Easy | Hard | Custom\nclass NumberGuessingGame {\n  method PlayGame(secretNumber: int, mode: Mode, customLow: int := 0, customHigh: int := 0) returns (tries: int, success: bool)\n  {\n    var currentTries := 1;\n    var found := false;\n    var guess := 0;\n    \n    while currentTries <= 4 && !found \n    {\n      guess := GetGuess(mode, customLow, customHigh);\n      \n      if guess == secretNumber {\n        found := true;\n      } else {\n        currentTries := currentTries + 1;\n      }\n    }\n    \n    tries := currentTries;\n    success := found;\n  }\n  method GetGuess(mode: Mode, customLow: int, customHigh: int) returns (guess: int)\n  {\n    match mode {\n      case Easy => guess := 1;\n      case Hard => guess := 1;\n      case Custom => guess := customLow;\n    }\n  }\n  method GetGameMode() returns (mode: Mode, customLow: int, customHigh: int)\n  {\n    mode := Easy;\n    customLow := 0;\n    customHigh := 0;\n  }\n}", "output": "datatype Mode = Easy | Hard | Custom\nclass NumberGuessingGame {\n  method PlayGame(secretNumber: int, mode: Mode, customLow: int := 0, customHigh: int := 0) returns (tries: int, success: bool)\n    requires mode == Custom ==> customLow <= customHigh\n    requires mode == Easy ==> 1 <= secretNumber <= 10\n    requires mode == Hard ==> 1 <= secretNumber <= 100 \n    requires mode == Custom ==> customLow <= secretNumber <= customHigh\n    ensures 1 <= tries <= 5\n    ensures success <==> tries <= 4\n  {\n    var currentTries := 1;\n    var found := false;\n    var guess := 0;\n    \n    while currentTries <= 4 && !found \n      invariant 1 <= currentTries <= 5\n      invariant !found ==> currentTries <= 5\n      invariant found ==> guess == secretNumber\n      invariant currentTries > 4 ==> !found\n      decreases 4 - currentTries, if found then 0 else 1\n    {\n      guess := GetGuess(mode, customLow, customHigh);\n      \n      if guess == secretNumber {\n        found := true;\n      } else {\n        currentTries := currentTries + 1;\n      }\n    }\n    \n    tries := currentTries;\n    success := found;\n  }\n  method GetGuess(mode: Mode, customLow: int, customHigh: int) returns (guess: int)\n    requires mode == Custom ==> customLow <= customHigh\n    ensures mode == Easy ==> 1 <= guess <= 10\n    ensures mode == Hard ==> 1 <= guess <= 100\n    ensures mode == Custom ==> customLow <= guess <= customHigh\n  {\n    match mode {\n      case Easy => guess := 1;\n      case Hard => guess := 1;\n      case Custom => guess := customLow;\n    }\n  }\n  method GetGameMode() returns (mode: Mode, customLow: int, customHigh: int)\n    ensures mode == Custom ==> customLow <= customHigh\n  {\n    mode := Easy;\n    customLow := 0;\n    customHigh := 0;\n  }\n}", "name": "py2dfy_428", "id": 428}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintHouse() returns (output: string)\n{\n  output := \n    \"\\t\\t _____/\\\\____\\n\" +\n    \"\\t  __/____/  \\\\___\\\\__\\n\" +\n    \" ____/______/    \\\\______\\\\__\\n\" +\n    \"|\\t\\t\\t\\t\\t\\t   |\\n\" +\n    \"|\\t\\t\\t\\t\\t\\t   |\\n\" +\n    \"|\\t   ___\\t\\t   ___\\t   |\\n\" +\n    \"|\\t  |_|_|\\t\\t  |_|_|\\t   |\\n\" +\n    \"|\\t  |_|_|\\t\\t  |_|_|\\t   |\\n\" +\n    \"|__________________________|\\n\" +\n    \"|\\t\\t    _____\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|__________|_____|_________|\";\n}\nmethod PrintAnimalFace() returns (output: string) \n{\n  var lines := new string[21];\n  lines[0] := \"   /\\\\_\\t\\t\\t\\t\\t\\t   _/\\\\\";\n  lines[1] := \"   |  \\\\_\\t\\t\\t\\t\\t _/  |\";\n  lines[2] := \"   /    |\\t\\t\\t\\t\\t|    \\\\\";\n  lines[3] := \"  | \\\\   \\\\\\t\\t\\t\\t\\t/   / |\";\n  lines[4] := \"  |  _|  \\\\\\t\\t\\t\\t   /  |_  |\";\n  lines[5] := \"  \\\\ /     \\\\_______________/\\t    \\\\ /\";\n  lines[6] := \"    |\\t __/\\t\\t\\t  \\\\___   |\";\n  lines[7] := \"   \\\\___/                      \\\\___/\";\n  lines[8] := \"    /\\t\\t\\t\\t\\t\\t\\t \\\\\";\n  lines[9] := \"   /\\t\\t\\t\\t\\t\\t\\t  \\\\\";\n  lines[10] := \"  /\\t\\t\\t\\t\\t\\t\\t       \\\\\";\n  lines[11] := \"  |\\t\\t  _____\\t\\t    _____\\t   |\";\n  lines[12] := \"  |\\t   _ | ||0|\\t\\t   _| ||0|\\t   |\";\n  lines[13] := \"  |\\t\\t  \\\\__/\\t\\t\\t \\\\__/\\t   |\";\n  lines[14] := \"  |\\t\\t\\t\\t  ___\\t\\t\\t   |\";\n  lines[15] := \"  |\\t\\t\\t\\t /0 0\\\\\\t\\t\\t   |\";\n  lines[16] := \"  |\\t\\t\\t    | || |\\t\\t\\t   |\";\n  lines[17] := \"  \\\\\\t\\t\\t |  \\\\ /\\\\ /  |\\t\\t   /\";\n  lines[18] := \"   \\\\\\t\\t \\\\___/  \\\\___/\\t\\t  /\";\n  lines[19] := \"    \\\\\\t\\t\\t\\t\\t\\t\\t /\";\n  lines[20] := \"        \\\\____________________/\";\n  \n  output := \"\";\n  var i := 0;\n  \n  while i < 21\n  {\n    output := output + lines[i] + \"\\n\";\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var house := PrintHouse();\n  print house;\n  print \"\\n\";\n  var face := PrintAnimalFace();\n  print face;\n}", "output": "method PrintHouse() returns (output: string)\n  ensures |output| > 0  \n{\n  output := \n    \"\\t\\t _____/\\\\____\\n\" +\n    \"\\t  __/____/  \\\\___\\\\__\\n\" +\n    \" ____/______/    \\\\______\\\\__\\n\" +\n    \"|\\t\\t\\t\\t\\t\\t   |\\n\" +\n    \"|\\t\\t\\t\\t\\t\\t   |\\n\" +\n    \"|\\t   ___\\t\\t   ___\\t   |\\n\" +\n    \"|\\t  |_|_|\\t\\t  |_|_|\\t   |\\n\" +\n    \"|\\t  |_|_|\\t\\t  |_|_|\\t   |\\n\" +\n    \"|__________________________|\\n\" +\n    \"|\\t\\t    _____\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|\\t\\t   |     |\\t\\t   |\\n\" +\n    \"|__________|_____|_________|\";\n}\nmethod PrintAnimalFace() returns (output: string) \n  ensures |output| > 0  \n{\n  var lines := new string[21];\n  lines[0] := \"   /\\\\_\\t\\t\\t\\t\\t\\t   _/\\\\\";\n  lines[1] := \"   |  \\\\_\\t\\t\\t\\t\\t _/  |\";\n  lines[2] := \"   /    |\\t\\t\\t\\t\\t|    \\\\\";\n  lines[3] := \"  | \\\\   \\\\\\t\\t\\t\\t\\t/   / |\";\n  lines[4] := \"  |  _|  \\\\\\t\\t\\t\\t   /  |_  |\";\n  lines[5] := \"  \\\\ /     \\\\_______________/\\t    \\\\ /\";\n  lines[6] := \"    |\\t __/\\t\\t\\t  \\\\___   |\";\n  lines[7] := \"   \\\\___/                      \\\\___/\";\n  lines[8] := \"    /\\t\\t\\t\\t\\t\\t\\t \\\\\";\n  lines[9] := \"   /\\t\\t\\t\\t\\t\\t\\t  \\\\\";\n  lines[10] := \"  /\\t\\t\\t\\t\\t\\t\\t       \\\\\";\n  lines[11] := \"  |\\t\\t  _____\\t\\t    _____\\t   |\";\n  lines[12] := \"  |\\t   _ | ||0|\\t\\t   _| ||0|\\t   |\";\n  lines[13] := \"  |\\t\\t  \\\\__/\\t\\t\\t \\\\__/\\t   |\";\n  lines[14] := \"  |\\t\\t\\t\\t  ___\\t\\t\\t   |\";\n  lines[15] := \"  |\\t\\t\\t\\t /0 0\\\\\\t\\t\\t   |\";\n  lines[16] := \"  |\\t\\t\\t    | || |\\t\\t\\t   |\";\n  lines[17] := \"  \\\\\\t\\t\\t |  \\\\ /\\\\ /  |\\t\\t   /\";\n  lines[18] := \"   \\\\\\t\\t \\\\___/  \\\\___/\\t\\t  /\";\n  lines[19] := \"    \\\\\\t\\t\\t\\t\\t\\t\\t /\";\n  lines[20] := \"        \\\\____________________/\";\n  \n  output := \"\";\n  var i := 0;\n  \n  while i < 21\n    invariant 0 <= i <= 21\n    invariant |output| >= 0\n    invariant i > 0 ==> |output| > 0  \n  {\n    output := output + lines[i] + \"\\n\";\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var house := PrintHouse();\n  print house;\n  print \"\\n\";\n  var face := PrintAnimalFace();\n  print face;\n}", "name": "py2dfy_434", "id": 434}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Employee = Employee(\n  firstName: string,\n  lastName: string,\n  patronymic: string,\n  postType: string,\n  post: string,\n  department: Department\n)\ndatatype Department = Department(\n  name: string\n)\ndatatype DepartmentRelation = DepartmentRelation(\n  department: Department,\n  highLevelDepartment: Option<Department>  \n)\ndatatype FormattedDepartmentEntry = FormattedEntry(\n  deptInfo: DepartmentInfo,\n  parentDept: string,\n  description: string\n)\ndatatype DepartmentInfo = DeptInfo(\n  value: string,\n  formattedValue: string\n)\ndatatype Option<T> = None | Some(value: T)  \nmethod FormatDepartmentList(\n  relations: seq<DepartmentRelation>,\n  employees: seq<Employee>\n) returns (result: seq<FormattedDepartmentEntry>)\n{\n  result := [];\n  var i := 0;\n  \n  while i < |relations|\n  \n  {\n    var relation := relations[i];\n    var deptEmployees := GetDepartmentEmployees(employees, relation.department);\n    \n    \n    var baseString := FormatDepartmentHeader(relation.department);\n    var formattedString := FormatEmployeeList(deptEmployees, baseString);\n    \n    var deptInfo := DeptInfo(\n      relation.department.name,\n      formattedString\n    );\n    \n    \n    var parentDept := match relation.highLevelDepartment {\n      case None => \"\"\n      case Some(dept) => dept.name\n    };\n    \n    \n    var entry := FormattedEntry(\n      deptInfo,\n      parentDept,\n      \"Описание отсутствует\"  \n    );\n    \n    result := result + [entry];\n    i := i + 1;\n  }\n}\nmethod GetDepartmentEmployees(\n  employees: seq<Employee>,\n  dept: Department\n) returns (result: seq<Employee>)\n{\n  result := [];\n  var i := 0;\n  \n  while i < |employees|\n  {\n    if employees[i].department == dept {\n      result := result + [employees[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod FormatDepartmentHeader(dept: Department) returns (result: string)\n{\n  result := \"<b>\" + dept.name + \"</b><br>\";\n}\nmethod FormatEmployeeList(\n  employees: seq<Employee>,\n  baseString: string\n) returns (result: string)\n{\n  result := baseString;\n  var i := 0;\n  \n  while i < |employees|\n  {\n    var employee := employees[i];\n    var employeeName := employee.lastName + \" \" + employee.firstName + \" \" + employee.patronymic;\n    \n    if employee.postType == \"MN\" {\n      result := result + employeeName + \n                \"<div style=\\\"color:red; font-style:italic\\\">\" + \n                employee.post + \"</div><br>\";\n    } else if employee.postType == \"SB\" {\n      result := result + employeeName + \n                \"<div style=\\\"color:red; font-style:italic\\\">\" + \n                employee.post + \"</div>\";\n    }\n    \n    i := i + 1;\n  }\n}", "output": "datatype Employee = Employee(\n  firstName: string,\n  lastName: string,\n  patronymic: string,\n  postType: string,\n  post: string,\n  department: Department\n)\ndatatype Department = Department(\n  name: string\n)\ndatatype DepartmentRelation = DepartmentRelation(\n  department: Department,\n  highLevelDepartment: Option<Department>  \n)\ndatatype FormattedDepartmentEntry = FormattedEntry(\n  deptInfo: DepartmentInfo,\n  parentDept: string,\n  description: string\n)\ndatatype DepartmentInfo = DeptInfo(\n  value: string,\n  formattedValue: string\n)\ndatatype Option<T> = None | Some(value: T)  \nmethod FormatDepartmentList(\n  relations: seq<DepartmentRelation>,\n  employees: seq<Employee>\n) returns (result: seq<FormattedDepartmentEntry>)\nrequires |relations| >= 0  \nrequires |employees| >= 0  \nrequires forall e :: e in employees ==> exists r :: r in relations && e.department == r.department\nensures |result| == |relations|  \n{\n  result := [];\n  var i := 0;\n  \n  while i < |relations|\n  \n  invariant 0 <= i <= |relations|\n  invariant |result| == i\n  {\n    var relation := relations[i];\n    var deptEmployees := GetDepartmentEmployees(employees, relation.department);\n    \n    \n    var baseString := FormatDepartmentHeader(relation.department);\n    var formattedString := FormatEmployeeList(deptEmployees, baseString);\n    \n    var deptInfo := DeptInfo(\n      relation.department.name,\n      formattedString\n    );\n    \n    \n    var parentDept := match relation.highLevelDepartment {\n      case None => \"\"\n      case Some(dept) => dept.name\n    };\n    \n    \n    var entry := FormattedEntry(\n      deptInfo,\n      parentDept,\n      \"Описание отсутствует\"  \n    );\n    \n    result := result + [entry];\n    i := i + 1;\n  }\n}\nmethod GetDepartmentEmployees(\n  employees: seq<Employee>,\n  dept: Department\n) returns (result: seq<Employee>)\nrequires |employees| >= 0\nensures |result| <= |employees|\nensures forall e :: e in result ==> e in employees && e.department == dept\n{\n  result := [];\n  var i := 0;\n  \n  while i < |employees|\n  invariant 0 <= i <= |employees|\n  invariant |result| <= i\n  invariant forall e :: e in result ==> e in employees && e.department == dept\n  {\n    if employees[i].department == dept {\n      result := result + [employees[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod FormatDepartmentHeader(dept: Department) returns (result: string)\nensures |result| > 0\n{\n  result := \"<b>\" + dept.name + \"</b><br>\";\n}\nmethod FormatEmployeeList(\n  employees: seq<Employee>,\n  baseString: string\n) returns (result: string)\nrequires |employees| >= 0\nrequires |baseString| > 0\nensures |result| >= |baseString|\n{\n  result := baseString;\n  var i := 0;\n  \n  while i < |employees|\n  invariant 0 <= i <= |employees|\n  invariant |result| >= |baseString|\n  {\n    var employee := employees[i];\n    var employeeName := employee.lastName + \" \" + employee.firstName + \" \" + employee.patronymic;\n    \n    if employee.postType == \"MN\" {\n      result := result + employeeName + \n                \"<div style=\\\"color:red; font-style:italic\\\">\" + \n                employee.post + \"</div><br>\";\n    } else if employee.postType == \"SB\" {\n      result := result + employeeName + \n                \"<div style=\\\"color:red; font-style:italic\\\">\" + \n                employee.post + \"</div>\";\n    }\n    \n    i := i + 1;\n  }\n}", "name": "py2dfy_417", "id": 417}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Point {\n    var x: real\n    var y: real\n    constructor(x': real, y': real)\n    {\n        x := x';\n        y := y';\n    }\n}\nclass Screen {\n    \n    var currentPosition: Point\n    \n    var clickHistory: seq<Point>\n    \n    ghost var Valid: bool\n    constructor()\n    {\n        currentPosition := new Point(0.0, 0.0);\n        clickHistory := [];\n        Valid := true;\n    }\n    \n    method HandleClick(x: real, y: real)\n    {\n        var newPoint := new Point(x, y);\n        clickHistory := clickHistory + [newPoint];\n    }\n    \n    method SetSpeed(speed: nat)\n    {\n        \n    }\n    \n    method GetLastClickCoordinates() returns (x: real, y: real)\n    {\n        x := clickHistory[|clickHistory|-1].x;\n        y := clickHistory[|clickHistory|-1].y;\n    }\n}\nmethod Main()\n{\n    var screen := new Screen();\n    \n    \n    screen.HandleClick(100.0, 200.0);\n    screen.SetSpeed(10);\n    \n    var x, y := screen.GetLastClickCoordinates();\n    \n}", "output": "class Point {\n    var x: real\n    var y: real\n    constructor(x': real, y': real)\n    ensures this.x == x' && this.y == y'\n    {\n        x := x';\n        y := y';\n    }\n}\nclass Screen {\n    \n    var currentPosition: Point\n    \n    var clickHistory: seq<Point>\n    \n    ghost var Valid: bool\n    constructor()\n    ensures Valid\n    ensures fresh(currentPosition)\n    ensures clickHistory == []\n    {\n        currentPosition := new Point(0.0, 0.0);\n        clickHistory := [];\n        Valid := true;\n    }\n    \n    method HandleClick(x: real, y: real)\n    requires Valid\n    modifies this\n    ensures Valid\n    ensures |clickHistory| == old(|clickHistory|) + 1\n    ensures fresh(clickHistory[|clickHistory|-1])\n    ensures clickHistory[|clickHistory|-1].x == x\n    ensures clickHistory[|clickHistory|-1].y == y\n    {\n        var newPoint := new Point(x, y);\n        clickHistory := clickHistory + [newPoint];\n    }\n    \n    method SetSpeed(speed: nat)\n    requires Valid\n    requires 0 <= speed <= 10\n    ensures Valid\n    {\n        \n    }\n    \n    method GetLastClickCoordinates() returns (x: real, y: real)\n    requires Valid\n    requires |clickHistory| > 0\n    ensures x == clickHistory[|clickHistory|-1].x\n    ensures y == clickHistory[|clickHistory|-1].y\n    {\n        x := clickHistory[|clickHistory|-1].x;\n        y := clickHistory[|clickHistory|-1].y;\n    }\n}\nmethod Main()\n{\n    var screen := new Screen();\n    \n    \n    screen.HandleClick(100.0, 200.0);\n    screen.SetSpeed(10);\n    \n    var x, y := screen.GetLastClickCoordinates();\n    \n}", "name": "py2dfy_437", "id": 437}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Robot {\n  var state: int\n  const STATE_IDLE: int := 0\n  const STATE_UP: int := 1  \n  const STATE_DOWN: int := 2\n  const STATE_RIGHT: int := 3\n  const STATE_LEFT: int := 4\n  constructor()\n  {\n    state := STATE_IDLE;\n  }\n  method Up()\n  {\n    state := STATE_UP;\n  }\n  method Down()\n  {\n    state := STATE_DOWN;\n  }\n  method Left()\n  {\n    state := STATE_LEFT;\n  }\n  method Right()\n  {\n    state := STATE_RIGHT;\n  }\n  method Stop()\n  {\n    state := STATE_IDLE;\n  }\n  method Kick()\n  {\n    Stop();\n  }\n  method GetState() returns (currentState: int)\n  {\n    return state;\n  }\n}\nclass GTK_Main {\n  var robot: Robot?\n  constructor()\n  {\n    robot := null;\n  }\n  method OnKeyPress(keyValue: int)\n  {\n    if keyValue == 65362 && robot.state != robot.STATE_UP {\n      robot.Up();\n    } else if keyValue == 65364 && robot.state != robot.STATE_DOWN {\n      robot.Down();\n    } else if keyValue == 65361 && robot.state != robot.STATE_LEFT {\n      robot.Left();\n    } else if keyValue == 65363 && robot.state != robot.STATE_RIGHT {\n      robot.Right();\n    } else if keyValue == 32 {\n      robot.Stop();\n      robot.Kick();\n    } else if keyValue == 115 { \n      robot.Stop();\n    } else {\n      \n      if robot.state !in {robot.STATE_IDLE, robot.STATE_UP, robot.STATE_DOWN, robot.STATE_LEFT, robot.STATE_RIGHT} {\n        robot.Stop();\n      }\n    }\n  }\n  method OnKeyRelease()\n  {\n    robot.Stop();\n  }\n  method Connect()\n  {\n    robot := new Robot();\n  }\n}", "output": "class Robot {\n  var state: int\n  const STATE_IDLE: int := 0\n  const STATE_UP: int := 1  \n  const STATE_DOWN: int := 2\n  const STATE_RIGHT: int := 3\n  const STATE_LEFT: int := 4\n  constructor()\n    ensures state == STATE_IDLE\n  {\n    state := STATE_IDLE;\n  }\n  method Up()\n    modifies this\n    ensures state == STATE_UP\n  {\n    state := STATE_UP;\n  }\n  method Down()\n    modifies this\n    ensures state == STATE_DOWN\n  {\n    state := STATE_DOWN;\n  }\n  method Left()\n    modifies this\n    ensures state == STATE_LEFT\n  {\n    state := STATE_LEFT;\n  }\n  method Right()\n    modifies this\n    ensures state == STATE_RIGHT\n  {\n    state := STATE_RIGHT;\n  }\n  method Stop()\n    modifies this\n    ensures state == STATE_IDLE\n  {\n    state := STATE_IDLE;\n  }\n  method Kick()\n    modifies this\n    ensures state == STATE_IDLE\n  {\n    Stop();\n  }\n  method GetState() returns (currentState: int)\n    ensures currentState == state\n  {\n    return state;\n  }\n}\nclass GTK_Main {\n  var robot: Robot?\n  constructor()\n    ensures robot == null\n  {\n    robot := null;\n  }\n  method OnKeyPress(keyValue: int)\n    modifies this, robot\n    requires robot != null\n    ensures robot != null\n    ensures robot.state in {robot.STATE_IDLE, robot.STATE_UP, robot.STATE_DOWN, robot.STATE_LEFT, robot.STATE_RIGHT}\n  {\n    if keyValue == 65362 && robot.state != robot.STATE_UP {\n      robot.Up();\n    } else if keyValue == 65364 && robot.state != robot.STATE_DOWN {\n      robot.Down();\n    } else if keyValue == 65361 && robot.state != robot.STATE_LEFT {\n      robot.Left();\n    } else if keyValue == 65363 && robot.state != robot.STATE_RIGHT {\n      robot.Right();\n    } else if keyValue == 32 {\n      robot.Stop();\n      robot.Kick();\n    } else if keyValue == 115 { \n      robot.Stop();\n    } else {\n      \n      if robot.state !in {robot.STATE_IDLE, robot.STATE_UP, robot.STATE_DOWN, robot.STATE_LEFT, robot.STATE_RIGHT} {\n        robot.Stop();\n      }\n    }\n  }\n  method OnKeyRelease()\n    modifies this, robot\n    requires robot != null\n    ensures robot != null\n    ensures robot.state == robot.STATE_IDLE\n  {\n    robot.Stop();\n  }\n  method Connect()\n    modifies this\n    ensures robot != null\n  {\n    robot := new Robot();\n  }\n}", "name": "py2dfy_413", "id": 413}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Site {\n  var polygon: seq<int>\n  var name: string\n}\nclass ResearchEvent {\n  var polygon: seq<int>\n  var name: string\n}\nclass ArchEnt {\n  var polygon: seq<int>\n  var name: string\n}\nclass MonumentProtection {\n  var polygon: seq<int>\n  var name: string\n}\nmethod CopySitePoly(currentId: int, currentClass: string, targetClass: string) returns (success: bool, targetObject: object?)\n{\n  var sourceObject: object?;\n  \n  if currentClass == \"Site\" {\n    sourceObject := new Site;\n  } else if currentClass == \"ResearchEvent\" {\n    sourceObject := new ResearchEvent;\n  } else if currentClass == \"ArchEnt\" {\n    sourceObject := new ArchEnt;\n  } else if currentClass == \"MonumentProtection\" {\n    sourceObject := new MonumentProtection;\n  }\n  if sourceObject == null {\n    success := false;\n    targetObject := null;\n    return;\n  }\n  \n  if targetClass == \"Site\" {\n    var site := new Site;\n    targetObject := site;\n  } else if targetClass == \"ResearchEvent\" {\n    var researchEvent := new ResearchEvent;\n    targetObject := researchEvent;\n  } else if targetClass == \"ArchEnt\" {\n    var archEnt := new ArchEnt;\n    targetObject := archEnt;\n  } else if targetClass == \"MonumentProtection\" {\n    var monumentProtection := new MonumentProtection;\n    targetObject := monumentProtection;\n  } else {\n    success := false;\n    targetObject := null;\n    return;\n  }\n  \n  if sourceObject is Site && targetObject is Site {\n    var source := sourceObject as Site;\n    var target := targetObject as Site;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is ResearchEvent {\n    var source := sourceObject as Site;\n    var target := targetObject as ResearchEvent;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is ArchEnt {\n    var source := sourceObject as Site;\n    var target := targetObject as ArchEnt;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is MonumentProtection {\n    var source := sourceObject as Site;\n    var target := targetObject as MonumentProtection;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  }\n  \n  success := true;\n}", "output": "class Site {\n  var polygon: seq<int>\n  var name: string\n}\nclass ResearchEvent {\n  var polygon: seq<int>\n  var name: string\n}\nclass ArchEnt {\n  var polygon: seq<int>\n  var name: string\n}\nclass MonumentProtection {\n  var polygon: seq<int>\n  var name: string\n}\nmethod CopySitePoly(currentId: int, currentClass: string, targetClass: string) returns (success: bool, targetObject: object?)\n  requires currentClass in {\"Site\", \"ResearchEvent\", \"ArchEnt\", \"MonumentProtection\"}\n  requires targetClass in {\"Site\", \"ResearchEvent\", \"ArchEnt\", \"MonumentProtection\"}\n  ensures success ==> targetObject != null \n  ensures success ==> fresh(targetObject)\n{\n  var sourceObject: object?;\n  \n  if currentClass == \"Site\" {\n    sourceObject := new Site;\n  } else if currentClass == \"ResearchEvent\" {\n    sourceObject := new ResearchEvent;\n  } else if currentClass == \"ArchEnt\" {\n    sourceObject := new ArchEnt;\n  } else if currentClass == \"MonumentProtection\" {\n    sourceObject := new MonumentProtection;\n  }\n  if sourceObject == null {\n    success := false;\n    targetObject := null;\n    return;\n  }\n  \n  if targetClass == \"Site\" {\n    var site := new Site;\n    targetObject := site;\n  } else if targetClass == \"ResearchEvent\" {\n    var researchEvent := new ResearchEvent;\n    targetObject := researchEvent;\n  } else if targetClass == \"ArchEnt\" {\n    var archEnt := new ArchEnt;\n    targetObject := archEnt;\n  } else if targetClass == \"MonumentProtection\" {\n    var monumentProtection := new MonumentProtection;\n    targetObject := monumentProtection;\n  } else {\n    success := false;\n    targetObject := null;\n    return;\n  }\n  \n  if sourceObject is Site && targetObject is Site {\n    var source := sourceObject as Site;\n    var target := targetObject as Site;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is ResearchEvent {\n    var source := sourceObject as Site;\n    var target := targetObject as ResearchEvent;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is ArchEnt {\n    var source := sourceObject as Site;\n    var target := targetObject as ArchEnt;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  } else if sourceObject is Site && targetObject is MonumentProtection {\n    var source := sourceObject as Site;\n    var target := targetObject as MonumentProtection;\n    target.polygon := source.polygon;\n    target.name := \"POLYGON COPIED FROM \" + source.name;\n  }\n  \n  success := true;\n}", "name": "py2dfy_433", "id": 433}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method Main()\n{\n    var sm := ReadInput();\n    var result := CheckString(sm);\n    PrintResult(result);\n}\nmethod ReadInput() returns (s: string)\n{\n    s := \"\"; \n    \n    \n}\nmethod PrintResult(result: bool)\n{\n    if result {\n        print \"Yes\\n\";\n    } else {\n        print \"No\\n\";\n    }\n}\nmethod CheckString(sm: string) returns (result: bool)\n{\n    var i := 0;\n    while i < |sm|\n    {\n        if IsAlpha(sm[i]) && IsDigit(sm[i]) {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nfunction IsAlpha(c: char): bool\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\nfunction IsDigit(c: char): bool\n{\n    '0' <= c <= '9'\n}", "output": "method Main()\n{\n    var sm := ReadInput();\n    var result := CheckString(sm);\n    PrintResult(result);\n}\nmethod ReadInput() returns (s: string)\nensures |s| >= 0\n{\n    s := \"\"; \n    \n    \n}\nmethod PrintResult(result: bool)\n{\n    if result {\n        print \"Yes\\n\";\n    } else {\n        print \"No\\n\";\n    }\n}\nmethod CheckString(sm: string) returns (result: bool)\nrequires |sm| >= 0\nensures result == forall i :: 0 <= i < |sm| ==> !(IsAlpha(sm[i]) && IsDigit(sm[i]))\n{\n    var i := 0;\n    while i < |sm|\n    invariant 0 <= i <= |sm|\n    invariant forall k :: 0 <= k < i ==> !(IsAlpha(sm[k]) && IsDigit(sm[k]))\n    {\n        if IsAlpha(sm[i]) && IsDigit(sm[i]) {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nfunction IsAlpha(c: char): bool\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\nfunction IsDigit(c: char): bool\n{\n    '0' <= c <= '9'\n}", "name": "py2dfy_447", "id": 447}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Message {\n  var time: int\n  var sentBy: string  \n  var content: string\n  var status: string\n  constructor(t: int, sender: string, msg: string, s: string)\n  {\n    time := t;\n    sentBy := sender;\n    content := msg;\n    status := s;\n  }\n}\nclass ChatClient {\n  var username: string\n  \n  var friends: map<string, seq<Message>>\n  var isConnected: bool\n  \n  constructor()\n  {\n    friends := map[];\n    isConnected := false;\n  }\n  \n  method LogIn(usr: string, pwd: string) returns (success: bool)\n  {\n    \n    if ValidCredentials(usr, pwd) {\n      username := usr;\n      isConnected := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method AddFriend(friendName: string) returns (success: bool)\n  {\n    if friendName in friends {\n      return false;\n    }\n    \n    if UserExists(friendName) {\n      friends := friends[friendName := []];\n      return true;\n    }\n    return false;\n  }\n  \n  method SendMessage(recipient: string, content: string) returns (success: bool)\n  {\n    var msg := new Message(CurrentTime(), username, content, \"V\");\n    var oldMessages := friends[recipient];\n    friends := friends[recipient := oldMessages + [msg]];\n    return true;\n  }\n  \n  predicate ValidCredentials(usr: string, pwd: string)\n  {\n    \n    true\n  }\n  predicate UserExists(name: string)\n  {\n    \n    true\n  }\n  function CurrentTime(): int\n  {\n    \n    0\n  }\n}\nmethod Main() {\n  var client := new ChatClient();\n  var loginSuccess := client.LogIn(\"testUser\", \"password123\");\n  if loginSuccess {\n    var addFriendSuccess := client.AddFriend(\"friend1\");\n    if addFriendSuccess {\n      var msgSuccess := client.SendMessage(\"friend1\", \"Hello!\");\n    }\n  }\n}", "output": "class Message {\n  var time: int\n  var sentBy: string  \n  var content: string\n  var status: string\n  constructor(t: int, sender: string, msg: string, s: string)\n    ensures time == t\n    ensures sentBy == sender \n    ensures content == msg\n    ensures status == s\n  {\n    time := t;\n    sentBy := sender;\n    content := msg;\n    status := s;\n  }\n}\nclass ChatClient {\n  var username: string\n  \n  var friends: map<string, seq<Message>>\n  var isConnected: bool\n  \n  constructor()\n    ensures friends == map[]\n    ensures isConnected == false\n  {\n    friends := map[];\n    isConnected := false;\n  }\n  \n  method LogIn(usr: string, pwd: string) returns (success: bool)\n    requires usr != \"\"\n    requires |pwd| >= 5\n    modifies this\n    ensures old(friends) == friends\n    ensures success ==> username == usr\n    ensures success ==> isConnected\n  {\n    \n    if ValidCredentials(usr, pwd) {\n      username := usr;\n      isConnected := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method AddFriend(friendName: string) returns (success: bool)\n    requires isConnected\n    requires friendName != \"\"\n    requires friendName != username\n    modifies this`friends\n    ensures success ==> friendName in friends\n    ensures success ==> friends[friendName] == []\n    ensures !success ==> friends == old(friends)\n  {\n    if friendName in friends {\n      return false;\n    }\n    \n    if UserExists(friendName) {\n      friends := friends[friendName := []];\n      return true;\n    }\n    return false;\n  }\n  \n  method SendMessage(recipient: string, content: string) returns (success: bool)\n    requires isConnected\n    requires recipient in friends\n    requires content != \"\"\n    modifies this`friends\n    ensures success ==> recipient in friends\n    ensures success ==> |friends[recipient]| == |old(friends[recipient])| + 1\n    ensures !success ==> friends == old(friends)\n  {\n    var msg := new Message(CurrentTime(), username, content, \"V\");\n    var oldMessages := friends[recipient];\n    friends := friends[recipient := oldMessages + [msg]];\n    return true;\n  }\n  \n  predicate ValidCredentials(usr: string, pwd: string)\n    requires usr != \"\"\n    requires |pwd| >= 5\n  {\n    \n    true\n  }\n  predicate UserExists(name: string)\n    requires name != \"\"\n  {\n    \n    true\n  }\n  function CurrentTime(): int\n  {\n    \n    0\n  }\n}\nmethod Main() {\n  var client := new ChatClient();\n  var loginSuccess := client.LogIn(\"testUser\", \"password123\");\n  if loginSuccess {\n    var addFriendSuccess := client.AddFriend(\"friend1\");\n    if addFriendSuccess {\n      var msgSuccess := client.SendMessage(\"friend1\", \"Hello!\");\n      assert addFriendSuccess ==> \"friend1\" in client.friends;\n      assert msgSuccess ==> |client.friends[\"friend1\"]| == 1;\n    }\n  }\n}", "name": "py2dfy_406", "id": 406}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype LoginCredentials = LoginCredentials(\n  userName: string,\n  password: string,\n  verifyCode: string,\n  verifyId: string,\n  regType: string\n)\ndatatype LoginResponse = LoginResponse(\n  statusCode: int,\n  contentType: string,\n  code: string,\n  msg: string,\n  token: string,\n  sessionId: string\n)\ndatatype VerifyCodeResponse = VerifyCodeResponse(\n  statusCode: int,\n  contentType: string,\n  code: string,\n  msg: string,\n  verifyId: string\n)\nclass TestRunner {\n  \n  var baseUrl: string\n  var tenantId: string\n  var appId: string\n  \n  \n  method GetVerificationCode() returns (response: VerifyCodeResponse)\n  {\n    \n    response := VerifyCodeResponse(\n      200,\n      \"application/json;charset=UTF-8\",\n      \"000000\",\n      \"Success\",\n      \"generated-verify-id\"\n    );\n  }\n  \n  method Login(creds: LoginCredentials) returns (response: LoginResponse)\n  {\n    \n    response := LoginResponse(\n      200,\n      \"application/json;charset=UTF-8\",\n      \"000000\",\n      \"Success\",\n      \"generated-token\",\n      \"generated-session-id\"\n    );\n  }\n  \n  method RunLoginTest(userName: string, password: string, verifyCode: string, regType: string) \n    returns (success: bool, token: string, sessionId: string)\n  {\n    \n    var verifyResponse := GetVerificationCode();\n    if verifyResponse.statusCode != 200 {\n      success := false;\n      token := \"\";\n      sessionId := \"\";\n      return;\n    }\n    \n    var loginCreds := LoginCredentials(\n      userName,\n      password,\n      verifyCode,\n      verifyResponse.verifyId,\n      regType\n    );\n    var loginResponse := Login(loginCreds);\n    if loginResponse.statusCode != 200 {\n      success := false;\n      token := \"\";\n      sessionId := \"\";\n      return;\n    }\n    success := true;\n    token := loginResponse.token;\n    sessionId := loginResponse.sessionId;\n  }\n}", "output": "datatype LoginCredentials = LoginCredentials(\n  userName: string,\n  password: string,\n  verifyCode: string,\n  verifyId: string,\n  regType: string\n)\ndatatype LoginResponse = LoginResponse(\n  statusCode: int,\n  contentType: string,\n  code: string,\n  msg: string,\n  token: string,\n  sessionId: string\n)\ndatatype VerifyCodeResponse = VerifyCodeResponse(\n  statusCode: int,\n  contentType: string,\n  code: string,\n  msg: string,\n  verifyId: string\n)\nclass TestRunner {\n  \n  var baseUrl: string\n  var tenantId: string\n  var appId: string\n  \n  \n  method GetVerificationCode() returns (response: VerifyCodeResponse)\n    ensures response.statusCode == 200 ==> response.code == \"000000\" \n    ensures response.statusCode == 200 ==> response.msg == \"Success\"\n    ensures response.statusCode == 200 ==> |response.verifyId| > 0 \n  {\n    \n    response := VerifyCodeResponse(\n      200,\n      \"application/json;charset=UTF-8\",\n      \"000000\",\n      \"Success\",\n      \"generated-verify-id\"\n    );\n  }\n  \n  method Login(creds: LoginCredentials) returns (response: LoginResponse)\n    requires |creds.userName| > 0 \n    requires |creds.password| > 0 \n    requires |creds.verifyCode| > 0 \n    requires |creds.verifyId| > 0 \n    ensures response.statusCode == 200 ==> response.code == \"000000\" \n    ensures response.statusCode == 200 ==> response.msg == \"Success\"\n    ensures response.statusCode == 200 ==> |response.token| > 0 \n    ensures response.statusCode == 200 ==> |response.sessionId| > 0 \n  {\n    \n    response := LoginResponse(\n      200,\n      \"application/json;charset=UTF-8\",\n      \"000000\",\n      \"Success\",\n      \"generated-token\",\n      \"generated-session-id\"\n    );\n  }\n  \n  method RunLoginTest(userName: string, password: string, verifyCode: string, regType: string) \n    returns (success: bool, token: string, sessionId: string)\n    requires |userName| > 0\n    requires |password| > 0\n    requires |verifyCode| > 0\n    ensures success ==> |token| > 0 && |sessionId| > 0 \n  {\n    \n    var verifyResponse := GetVerificationCode();\n    if verifyResponse.statusCode != 200 {\n      success := false;\n      token := \"\";\n      sessionId := \"\";\n      return;\n    }\n    \n    var loginCreds := LoginCredentials(\n      userName,\n      password,\n      verifyCode,\n      verifyResponse.verifyId,\n      regType\n    );\n    var loginResponse := Login(loginCreds);\n    if loginResponse.statusCode != 200 {\n      success := false;\n      token := \"\";\n      sessionId := \"\";\n      return;\n    }\n    success := true;\n    token := loginResponse.token;\n    sessionId := loginResponse.sessionId;\n  }\n}", "name": "py2dfy_448", "id": 448}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Properties {\n  var props: map<string, string>\n  constructor()\n  {\n    props := map[];\n  }\n  method get(key: string) returns (value: string)\n  {\n    value := props[key];\n  }\n  method load(contents: seq<string>) returns (success: bool)\n  {\n    var oldProps := props;\n    var newProps := map[\"admin.url\" := \"/\"]; \n    \n    \n    var keys := set k | k in oldProps;\n    newProps := newProps + oldProps; \n    \n    props := newProps;\n    success := true;\n  }\n}\nclass DataSourceManager {\n  var isConnected: bool\n  var adminUrl: string\n  var currentPath: string\n  constructor()\n  {\n    isConnected := false;\n    currentPath := \"/\";\n  }\n  method connect(username: string, password: string, url: string) returns (success: bool)\n  {\n    adminUrl := url;\n    isConnected := true;\n    success := true;\n  }\n  method cd(path: string) returns (success: bool)\n  {\n    currentPath := path;\n    success := true;\n  }\n  method destroyDataSource(dsName: string) returns (success: bool)\n  {\n    success := true;\n  }\n}\nmethod DeleteDataSource(propertyFile: string, dsName: string) returns (success: bool)\n{\n  var props := new Properties();\n  var loadSuccess := props.load([]);\n  if !loadSuccess {\n    success := false;\n    return;\n  }\n  var dsManager := new DataSourceManager();\n  \n  var adminUrl := \"/\";\n  var connected := dsManager.connect(\"admin\", \"password\", adminUrl);\n  if !connected {\n    success := false;\n    return;\n  }\n  var cdSuccess := dsManager.cd(\"/JDBCSystemResources/\" + dsName);\n  if !cdSuccess {\n    success := false;\n    return;\n  }\n  success := dsManager.destroyDataSource(dsName);\n}", "output": "class Properties {\n  var props: map<string, string>\n  constructor()\n    ensures props == map[]\n  {\n    props := map[];\n  }\n  method get(key: string) returns (value: string)\n    requires key in props\n    ensures value == props[key]\n  {\n    value := props[key];\n  }\n  method load(contents: seq<string>) returns (success: bool)\n    modifies this\n    ensures success ==> |props| > 0\n    ensures !success ==> props == old(props)\n    ensures forall k :: k in old(props) ==> k in props && old(props)[k] == props[k]\n  {\n    var oldProps := props;\n    var newProps := map[\"admin.url\" := \"/\"]; \n    \n    \n    var keys := set k | k in oldProps;\n    newProps := newProps + oldProps; \n    \n    props := newProps;\n    success := true;\n  }\n}\nclass DataSourceManager {\n  var isConnected: bool\n  var adminUrl: string\n  var currentPath: string\n  constructor()\n    ensures !isConnected\n    ensures currentPath == \"/\"\n  {\n    isConnected := false;\n    currentPath := \"/\";\n  }\n  method connect(username: string, password: string, url: string) returns (success: bool)\n    modifies this\n    requires username != \"\"\n    requires url != \"\"\n    ensures success ==> isConnected\n    ensures !success ==> !isConnected\n    ensures old(currentPath) == currentPath\n    ensures success ==> adminUrl == url\n  {\n    adminUrl := url;\n    isConnected := true;\n    success := true;\n  }\n  method cd(path: string) returns (success: bool)\n    modifies this\n    requires isConnected\n    requires path != \"\"\n    ensures success ==> currentPath == path\n    ensures !success ==> currentPath == old(currentPath)\n    ensures success ==> isConnected == old(isConnected)\n    ensures !success ==> isConnected == old(isConnected)\n  {\n    currentPath := path;\n    success := true;\n  }\n  method destroyDataSource(dsName: string) returns (success: bool)\n    modifies this\n    requires isConnected\n    requires dsName != \"\"\n    requires currentPath == \"/JDBCSystemResources/\" + dsName\n    ensures success ==> currentPath == old(currentPath)\n    ensures isConnected == old(isConnected)\n  {\n    success := true;\n  }\n}\nmethod DeleteDataSource(propertyFile: string, dsName: string) returns (success: bool)\n  requires propertyFile != \"\"\n  requires dsName != \"\"\n  ensures success ==> true\n{\n  var props := new Properties();\n  var loadSuccess := props.load([]);\n  if !loadSuccess {\n    success := false;\n    return;\n  }\n  var dsManager := new DataSourceManager();\n  \n  var adminUrl := \"/\";\n  var connected := dsManager.connect(\"admin\", \"password\", adminUrl);\n  if !connected {\n    success := false;\n    return;\n  }\n  assert dsManager.isConnected;\n  var cdSuccess := dsManager.cd(\"/JDBCSystemResources/\" + dsName);\n  if !cdSuccess {\n    success := false;\n    return;\n  }\n  assert dsManager.isConnected;\n  assert dsManager.currentPath == \"/JDBCSystemResources/\" + dsName;\n  success := dsManager.destroyDataSource(dsName);\n}", "name": "py2dfy_411", "id": 411}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "function TriangleNumber(n: nat): nat\n{\n  (n * (n + 1)) / 2\n}\nfunction AbsDiff(a: nat, b: nat): nat\n{\n  if a > b then a - b else b - a\n}\nfunction ComputeRectangles(length: nat, width: nat): nat\n{\n  TriangleNumber(length) * TriangleNumber(width)\n}\nmethod FindClosestRectangle(maxSize: nat, target: nat) returns (l: nat, w: nat, diff: nat)\n          AbsDiff(rectCount, target) == diff\n          var currCount := ComputeRectangles(i, j);\n          diff <= AbsDiff(currCount, target)\n{\n  l, w := 0, 0;\n  diff := target; \n  \n  var i := 0;\n  while i <= maxSize\n              AbsDiff(rectCount, target) == diff\n              var currCount := ComputeRectangles(x, y);\n              diff <= AbsDiff(currCount, target)\n  {\n    var j := 0;\n    while j <= maxSize\n                AbsDiff(rectCount, target) == diff\n                var currCount := ComputeRectangles(x, y);\n                diff <= AbsDiff(currCount, target)\n    {\n      var rectCount := ComputeRectangles(i, j);\n      var currDiff := AbsDiff(rectCount, target);\n      \n      if currDiff < diff {\n        l, w := i, j;\n        diff := currDiff;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nmethod Solve() returns (area: nat)\n{\n  var maxSize := 1000;\n  var target := 2000000; \n  \n  var l, w, diff := FindClosestRectangle(maxSize, target);\n  area := l * w;\n}", "output": "function TriangleNumber(n: nat): nat\n{\n  (n * (n + 1)) / 2\n}\nfunction AbsDiff(a: nat, b: nat): nat\n{\n  if a > b then a - b else b - a\n}\nfunction ComputeRectangles(length: nat, width: nat): nat\n{\n  TriangleNumber(length) * TriangleNumber(width)\n}\nmethod FindClosestRectangle(maxSize: nat, target: nat) returns (l: nat, w: nat, diff: nat)\n  requires maxSize > 0\n  ensures 0 <= l <= maxSize && 0 <= w <= maxSize\n  ensures var rectCount := ComputeRectangles(l, w);\n          AbsDiff(rectCount, target) == diff\n  ensures forall i, j :: 0 <= i <= maxSize && 0 <= j <= maxSize ==>\n          var currCount := ComputeRectangles(i, j);\n          diff <= AbsDiff(currCount, target)\n{\n  l, w := 0, 0;\n  diff := target; \n  \n  var i := 0;\n  while i <= maxSize\n    invariant 0 <= i <= maxSize + 1\n    invariant 0 <= l <= maxSize && 0 <= w <= maxSize\n    invariant var rectCount := ComputeRectangles(l, w);\n              AbsDiff(rectCount, target) == diff\n    invariant forall x, y :: 0 <= x < i && 0 <= y <= maxSize ==>\n              var currCount := ComputeRectangles(x, y);\n              diff <= AbsDiff(currCount, target)\n  {\n    var j := 0;\n    while j <= maxSize\n      invariant 0 <= j <= maxSize + 1\n      invariant 0 <= l <= maxSize && 0 <= w <= maxSize\n      invariant var rectCount := ComputeRectangles(l, w);\n                AbsDiff(rectCount, target) == diff\n      invariant forall x, y :: (0 <= x < i && 0 <= y <= maxSize) || (x == i && 0 <= y < j) ==>\n                var currCount := ComputeRectangles(x, y);\n                diff <= AbsDiff(currCount, target)\n    {\n      var rectCount := ComputeRectangles(i, j);\n      var currDiff := AbsDiff(rectCount, target);\n      \n      if currDiff < diff {\n        l, w := i, j;\n        diff := currDiff;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nmethod Solve() returns (area: nat)\n  ensures area >= 0\n{\n  var maxSize := 1000;\n  var target := 2000000; \n  \n  var l, w, diff := FindClosestRectangle(maxSize, target);\n  area := l * w;\n}", "name": "py2dfy_426", "id": 426}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Request = Request(values: map<string, string>)\ndatatype Response = Response(\n  status: int,\n  body: string,\n  contentType: string\n)\ndatatype Result<T> = \n  | Success(value: T)\n  | Error(code: int, message: string)\nclass WebApplication {\n  \n  var predictions: map<string, seq<string>>\n  \n  \n  constructor()\n  {\n    predictions := map[];\n  }\n  \n  method ValidateParameter(req: Request, param: string) returns (r: Result<string>)\n  {\n    if param in req.values {\n      return Success(req.values[param]);\n    }\n    return Error(400, \"Missing required parameter: \" + param);\n  }\n  \n  method ConvertTextToSpeech(req: Request) returns (r: Result<Response>)\n  {\n    var textResult := ValidateParameter(req, \"text_to_convert\");\n    if textResult.Error? {\n      return Error(400, textResult.message);\n    }\n    \n    \n    var audioData := textResult.value;\n    return Success(Response(\n      200,\n      audioData,\n      \"audio/mpeg\"\n    ));\n  }\n  \n  method GetSuggestion(req: Request) returns (r: Result<seq<string>>)\n  {\n    var wordsResult := ValidateParameter(req, \"words\");\n    if wordsResult.Error? {\n      return Error(400, wordsResult.message);\n    }\n    var words := wordsResult.value;\n    var wordCount := CountWords(words);\n    var suggestions;\n    \n    if wordCount > 1 {\n      suggestions := SplitPredict(words);\n      return Success(suggestions);\n    } else {\n      suggestions := PredictCurrentWord(words);\n      return Success(suggestions);\n    }\n  }\n  \n  method CountWords(text: string) returns (count: int)\n  {\n    \n    count := 1;\n    var i := 0;\n    while i < |text|\n    {\n      if text[i] == ' ' {\n        count := count + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method SplitPredict(text: string) returns (suggestions: seq<string>)\n  {\n    \n    suggestions := [];\n  }\n  method PredictCurrentWord(text: string) returns (suggestions: seq<string>)\n  {\n    \n    suggestions := [];\n  }\n  \n  method SendText(req: Request) returns (r: Result<Response>)\n  {\n    var textResult := ValidateParameter(req, \"text\");\n    if textResult.Error? {\n      return Error(400, textResult.message);\n    }\n    var toResult := ValidateParameter(req, \"to\");\n    if toResult.Error? {\n      return Error(400, toResult.message);\n    }\n    \n    var messageStatus := Response(\n      200,\n      textResult.value,\n      \"application/json\"\n    );\n    \n    return Success(messageStatus);\n  }\n}", "output": "datatype Request = Request(values: map<string, string>)\ndatatype Response = Response(\n  status: int,\n  body: string,\n  contentType: string\n)\ndatatype Result<T> = \n  | Success(value: T)\n  | Error(code: int, message: string)\nclass WebApplication {\n  \n  var predictions: map<string, seq<string>>\n  \n  \n  constructor()\n    ensures fresh(this)\n  {\n    predictions := map[];\n  }\n  \n  method ValidateParameter(req: Request, param: string) returns (r: Result<string>)\n    ensures r.Success? ==> param in req.values && r.value == req.values[param]\n    ensures r.Error? ==> r.code == 400\n  {\n    if param in req.values {\n      return Success(req.values[param]);\n    }\n    return Error(400, \"Missing required parameter: \" + param);\n  }\n  \n  method ConvertTextToSpeech(req: Request) returns (r: Result<Response>)\n    ensures r.Success? ==> r.value.status == 200\n    ensures r.Error? ==> r.code == 400\n  {\n    var textResult := ValidateParameter(req, \"text_to_convert\");\n    if textResult.Error? {\n      return Error(400, textResult.message);\n    }\n    \n    \n    var audioData := textResult.value;\n    return Success(Response(\n      200,\n      audioData,\n      \"audio/mpeg\"\n    ));\n  }\n  \n  method GetSuggestion(req: Request) returns (r: Result<seq<string>>)\n    ensures r.Success? ==> |r.value| <= 10\n    ensures r.Error? ==> r.code == 400\n  {\n    var wordsResult := ValidateParameter(req, \"words\");\n    if wordsResult.Error? {\n      return Error(400, wordsResult.message);\n    }\n    var words := wordsResult.value;\n    var wordCount := CountWords(words);\n    var suggestions;\n    \n    if wordCount > 1 {\n      suggestions := SplitPredict(words);\n      return Success(suggestions);\n    } else {\n      suggestions := PredictCurrentWord(words);\n      return Success(suggestions);\n    }\n  }\n  \n  method CountWords(text: string) returns (count: int)\n    ensures count >= 1\n  {\n    \n    count := 1;\n    var i := 0;\n    while i < |text|\n      invariant 0 <= i <= |text|\n      invariant count >= 1\n    {\n      if text[i] == ' ' {\n        count := count + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method SplitPredict(text: string) returns (suggestions: seq<string>)\n    ensures |suggestions| <= 10\n  {\n    \n    suggestions := [];\n  }\n  method PredictCurrentWord(text: string) returns (suggestions: seq<string>)\n    ensures |suggestions| <= 10\n  {\n    \n    suggestions := [];\n  }\n  \n  method SendText(req: Request) returns (r: Result<Response>)\n    ensures r.Success? ==> r.value.status == 200\n    ensures r.Error? ==> r.code == 400\n  {\n    var textResult := ValidateParameter(req, \"text\");\n    if textResult.Error? {\n      return Error(400, textResult.message);\n    }\n    var toResult := ValidateParameter(req, \"to\");\n    if toResult.Error? {\n      return Error(400, toResult.message);\n    }\n    \n    var messageStatus := Response(\n      200,\n      textResult.value,\n      \"application/json\"\n    );\n    \n    return Success(messageStatus);\n  }\n}", "name": "py2dfy_443", "id": 443}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method WatermarkImage(cover: array2<int>, watermark: array2<bool>, alpha: int) returns (result: array2<int>)\n{\n  var rows := cover.Length0;\n  var cols := cover.Length1;\n  result := new int[rows, cols];\n  var k1 := GenerateRandomSequence(8);\n  var k2 := GenerateRandomSequence(8);\n  var i := 0;\n  while i < watermark.Length0\n  {\n    var j := 0;\n    while j < watermark.Length1\n    {\n      var x := i * 8;\n      var y := j * 8;\n      var k := if watermark[i, j] then k1 else k2;\n      result[x, y+7] := cover[x, y+7] + alpha * k[0];\n      result[x+1, y+6] := cover[x+1, y+6] + alpha * k[1];\n      result[x+2, y+5] := cover[x+2, y+5] + alpha * k[2];\n      result[x+3, y+4] := cover[x+3, y+4] + alpha * k[3];\n      result[x+4, y+3] := cover[x+4, y+3] + alpha * k[4];\n      result[x+5, y+2] := cover[x+5, y+2] + alpha * k[5];\n      result[x+6, y+1] := cover[x+6, y+1] + alpha * k[6];\n      result[x+7, y] := cover[x+7, y] + alpha * k[7];\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  \n  i := 0;\n  while i < rows\n  {\n    var j := 0;\n    while j < cols\n    {\n      if i >= watermark.Length0 * 8 || j >= watermark.Length1 * 8 {\n        result[i, j] := cover[i, j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nmethod GenerateRandomSequence(length: int) returns (result: array<int>)\n{\n  \n  \n  result := new int[length];\n}", "output": "method WatermarkImage(cover: array2<int>, watermark: array2<bool>, alpha: int) returns (result: array2<int>)\n  requires cover.Length0 > 0 && cover.Length1 > 0\n  requires watermark.Length0 > 0 && watermark.Length1 > 0\n  requires cover.Length0 % 8 == 0 && cover.Length1 % 8 == 0\n  requires watermark.Length0 * 8 <= cover.Length0 && watermark.Length1 * 8 <= cover.Length1\n  requires alpha > 0\n  ensures fresh(result)\n  ensures result.Length0 == cover.Length0 && result.Length1 == cover.Length1\n{\n  var rows := cover.Length0;\n  var cols := cover.Length1;\n  result := new int[rows, cols];\n  var k1 := GenerateRandomSequence(8);\n  var k2 := GenerateRandomSequence(8);\n  var i := 0;\n  while i < watermark.Length0\n    invariant 0 <= i <= watermark.Length0\n    invariant forall r, c :: 0 <= r < i * 8 && 0 <= c < result.Length1 ==> result[r, c] == result[r, c]\n  {\n    var j := 0;\n    while j < watermark.Length1\n      invariant 0 <= j <= watermark.Length1\n      invariant forall r, c :: 0 <= r < i * 8 && 0 <= c < result.Length1 ==> result[r, c] == result[r, c]\n      invariant forall r, c :: i * 8 <= r < (i + 1) * 8 && 0 <= c < j * 8 ==> result[r, c] == result[r, c]\n    {\n      var x := i * 8;\n      var y := j * 8;\n      var k := if watermark[i, j] then k1 else k2;\n      result[x, y+7] := cover[x, y+7] + alpha * k[0];\n      result[x+1, y+6] := cover[x+1, y+6] + alpha * k[1];\n      result[x+2, y+5] := cover[x+2, y+5] + alpha * k[2];\n      result[x+3, y+4] := cover[x+3, y+4] + alpha * k[3];\n      result[x+4, y+3] := cover[x+4, y+3] + alpha * k[4];\n      result[x+5, y+2] := cover[x+5, y+2] + alpha * k[5];\n      result[x+6, y+1] := cover[x+6, y+1] + alpha * k[6];\n      result[x+7, y] := cover[x+7, y] + alpha * k[7];\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  \n  i := 0;\n  while i < rows\n    invariant 0 <= i <= rows\n    invariant forall r, c :: 0 <= r < i && 0 <= c < cols ==> result[r, c] == result[r, c]\n  {\n    var j := 0;\n    while j < cols\n      invariant 0 <= j <= cols\n      invariant forall r, c :: 0 <= r < i && 0 <= c < cols ==> result[r, c] == result[r, c]\n      invariant forall c :: 0 <= c < j ==> result[i, c] == result[i, c]\n    {\n      if i >= watermark.Length0 * 8 || j >= watermark.Length1 * 8 {\n        result[i, j] := cover[i, j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\nmethod GenerateRandomSequence(length: int) returns (result: array<int>)\n  requires length > 0\n  ensures fresh(result)\n  ensures result.Length == length\n{\n  \n  \n  result := new int[length];\n}", "name": "py2dfy_393", "id": 393}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype TimeResult = TimeResult(elapsed: real)\ndatatype PerformanceData = PerformanceData(sizes: seq<int>, times: seq<real>)\ndatatype FileHandle = FileHandle(name: string)\ndatatype CSVFile = CSVFile(path: string, data: PerformanceData)\nclass PerformanceAnalyzer {\n  \n  predicate IsValidParticleCount(n: int)\n  {\n    n > 0\n  }\n  \n  predicate IsValidPerformanceData(data: PerformanceData)\n  {\n    |data.sizes| == |data.times| && \n    |data.sizes| > 0 &&\n    (forall i :: 0 <= i < |data.sizes| ==> data.sizes[i] > 0) &&\n    (forall i :: 0 <= i < |data.times| ==> data.times[i] >= 0.0)\n  }\n  \n  method SaveToCsv(filename: string, data: PerformanceData) returns (success: bool)\n  {\n    \n    success := true;\n  }\n  \n  method MeasureSequential(maxParticles: int) returns (result: PerformanceData)\n  {\n    \n    var sizes: seq<int> := [1];  \n    var times: seq<real> := [1.0];  \n    var n := 1;\n    while n < maxParticles\n    {\n      var next_n := (n * 3) / 2 + 1;  \n      if next_n >= maxParticles { break; }\n      n := next_n;\n      \n      \n      var executionTime: real := 1.0;  \n      \n      sizes := sizes + [n];\n      times := times + [executionTime];\n    }\n    result := PerformanceData(sizes, times);\n  }\n  \n  method MeasureParallel(maxParticles: int, numProcs: int) returns (result: PerformanceData)\n  {\n    \n    var n: int;\n    var sizes: seq<int>;\n    var times: seq<real>;\n    \n    if maxParticles >= 2 {\n      \n      n := 2;\n      sizes := [2];\n      times := [1.0];\n    } else {\n      \n      n := 1;\n      sizes := [1];\n      times := [1.0];\n    }\n    while n < maxParticles\n    {\n      var next_n := (n * 3) / 2;\n      if next_n % 2 == 1 { next_n := next_n + 1; }  \n      if next_n >= maxParticles { break; }\n      n := next_n;\n      \n      \n      var executionTime: real := 1.0;  \n      \n      sizes := sizes + [n];\n      times := times + [executionTime];\n    }\n    result := PerformanceData(sizes, times);\n  }\n  \n  method CalculateSpeedup(seqTime: real, parTimes: seq<real>) returns (speedup: seq<real>)\n  {\n    speedup := [];\n    var i := 0;\n    \n    while i < |parTimes|\n    {\n      speedup := speedup + [seqTime / parTimes[i]];\n      i := i + 1;\n    }\n  }\n}", "output": "datatype TimeResult = TimeResult(elapsed: real)\ndatatype PerformanceData = PerformanceData(sizes: seq<int>, times: seq<real>)\ndatatype FileHandle = FileHandle(name: string)\ndatatype CSVFile = CSVFile(path: string, data: PerformanceData)\nclass PerformanceAnalyzer {\n  \n  predicate IsValidParticleCount(n: int)\n  {\n    n > 0\n  }\n  \n  predicate IsValidPerformanceData(data: PerformanceData)\n  {\n    |data.sizes| == |data.times| && \n    |data.sizes| > 0 &&\n    (forall i :: 0 <= i < |data.sizes| ==> data.sizes[i] > 0) &&\n    (forall i :: 0 <= i < |data.times| ==> data.times[i] >= 0.0)\n  }\n  \n  method SaveToCsv(filename: string, data: PerformanceData) returns (success: bool)\n    requires IsValidPerformanceData(data)\n    ensures success ==> true  \n  {\n    \n    success := true;\n  }\n  \n  method MeasureSequential(maxParticles: int) returns (result: PerformanceData)\n    requires IsValidParticleCount(maxParticles)\n    ensures IsValidPerformanceData(result)\n    ensures forall i :: 0 <= i < |result.sizes| ==> result.sizes[i] <= maxParticles\n  {\n    \n    var sizes: seq<int> := [1];  \n    var times: seq<real> := [1.0];  \n    var n := 1;\n    while n < maxParticles\n      invariant n > 0\n      invariant |sizes| == |times|\n      invariant |sizes| > 0  \n      invariant forall i :: 0 <= i < |sizes| ==> sizes[i] > 0\n      invariant forall i :: 0 <= i < |times| ==> times[i] >= 0.0\n      invariant forall i :: 0 <= i < |sizes| ==> sizes[i] <= maxParticles\n      invariant n <= maxParticles  \n    {\n      var next_n := (n * 3) / 2 + 1;  \n      if next_n >= maxParticles { break; }\n      n := next_n;\n      \n      \n      var executionTime: real := 1.0;  \n      \n      sizes := sizes + [n];\n      times := times + [executionTime];\n    }\n    result := PerformanceData(sizes, times);\n  }\n  \n  method MeasureParallel(maxParticles: int, numProcs: int) returns (result: PerformanceData)\n    requires IsValidParticleCount(maxParticles)\n    requires numProcs > 0\n    ensures IsValidPerformanceData(result)\n    ensures forall i :: 0 <= i < |result.sizes| ==> result.sizes[i] <= maxParticles\n  {\n    \n    var n: int;\n    var sizes: seq<int>;\n    var times: seq<real>;\n    \n    if maxParticles >= 2 {\n      \n      n := 2;\n      sizes := [2];\n      times := [1.0];\n    } else {\n      \n      n := 1;\n      sizes := [1];\n      times := [1.0];\n    }\n    while n < maxParticles\n      invariant n > 0\n      invariant |sizes| == |times|\n      invariant |sizes| > 0  \n      invariant forall i :: 0 <= i < |sizes| ==> sizes[i] > 0\n      invariant forall i :: 0 <= i < |times| ==> times[i] >= 0.0\n      invariant forall i :: 0 <= i < |sizes| ==> sizes[i] <= maxParticles\n      invariant n <= maxParticles  \n    {\n      var next_n := (n * 3) / 2;\n      if next_n % 2 == 1 { next_n := next_n + 1; }  \n      if next_n >= maxParticles { break; }\n      n := next_n;\n      \n      \n      var executionTime: real := 1.0;  \n      \n      sizes := sizes + [n];\n      times := times + [executionTime];\n    }\n    result := PerformanceData(sizes, times);\n  }\n  \n  method CalculateSpeedup(seqTime: real, parTimes: seq<real>) returns (speedup: seq<real>)\n    requires seqTime > 0.0\n    requires |parTimes| > 0\n    requires forall i :: 0 <= i < |parTimes| ==> parTimes[i] > 0.0\n    ensures |speedup| == |parTimes|\n    ensures forall i :: 0 <= i < |speedup| ==> speedup[i] == seqTime / parTimes[i]\n  {\n    speedup := [];\n    var i := 0;\n    \n    while i < |parTimes|\n      invariant 0 <= i <= |parTimes|\n      invariant |speedup| == i\n      invariant forall k :: 0 <= k < i ==> speedup[k] == seqTime / parTimes[k]\n    {\n      speedup := speedup + [seqTime / parTimes[i]];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_425", "id": 425}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Position = Position(x: int, y: int)\ndatatype Player = Player(position: Position, walls: int)\ndatatype MoveType = Movement | HorizontalWall | VerticalWall \ndatatype Move = Move(moveType: MoveType, position: Position)\ndatatype GameState = GameState(players: seq<Player>, walls: seq<Position>)\nclass Quoridor {\n  var state: GameState\n  \n  \n  constructor(players: seq<Player>, walls: seq<Position>)\n  {\n    state := GameState(players, walls);\n  }\n  \n  predicate IsValidMove(move: Move, playerIndex: int)\n  {\n    \n    if move.position.x < 0 || move.position.x >= 9 ||\n       move.position.y < 0 || move.position.y >= 9 then\n      false\n    else\n      match move.moveType\n      case Movement =>\n        \n        true\n      case HorizontalWall =>\n        \n        state.players[playerIndex].walls > 0\n      case VerticalWall =>\n        \n        state.players[playerIndex].walls > 0\n  }\n  \n  method ApplyMove(move: Move, playerIndex: int) returns (newState: GameState)\n  {\n    var players := state.players;\n    var walls := state.walls;\n    \n    match move.moveType {\n      case Movement =>\n        \n        var updatedPlayer := Player(move.position, players[playerIndex].walls);\n        players := players[playerIndex := updatedPlayer];\n      case HorizontalWall =>\n        \n        walls := walls + [move.position];\n        var updatedPlayer := Player(\n          players[playerIndex].position,\n          players[playerIndex].walls - 1\n        );\n        players := players[playerIndex := updatedPlayer];\n      case VerticalWall =>\n        \n        walls := walls + [move.position];\n        var updatedPlayer := Player(\n          players[playerIndex].position,\n          players[playerIndex].walls - 1\n        );\n        players := players[playerIndex := updatedPlayer];\n    }\n    \n    newState := GameState(players, walls);\n  }\n  \n  method IsGameWon() returns (won: bool, winner: int)\n  {\n    won := false;\n    winner := 0;\n    \n    \n    if state.players[0].position.y == 8 {\n      won := true;\n      winner := 0;\n    }\n    \n    else if state.players[1].position.y == 0 {\n      won := true;\n      winner := 1;\n    }\n  }\n}", "output": "datatype Position = Position(x: int, y: int)\ndatatype Player = Player(position: Position, walls: int)\ndatatype MoveType = Movement | HorizontalWall | VerticalWall \ndatatype Move = Move(moveType: MoveType, position: Position)\ndatatype GameState = GameState(players: seq<Player>, walls: seq<Position>)\nclass Quoridor {\n  var state: GameState\n  \n  \n  constructor(players: seq<Player>, walls: seq<Position>)\n    requires |players| == 2  \n    requires forall p :: p in players ==> 0 <= p.position.x < 9 && 0 <= p.position.y < 9  \n    ensures state.players == players && state.walls == walls\n  {\n    state := GameState(players, walls);\n  }\n  \n  predicate IsValidMove(move: Move, playerIndex: int)\n    requires 0 <= playerIndex < |state.players|\n    reads this\n  {\n    \n    if move.position.x < 0 || move.position.x >= 9 ||\n       move.position.y < 0 || move.position.y >= 9 then\n      false\n    else\n      match move.moveType\n      case Movement =>\n        \n        true\n      case HorizontalWall =>\n        \n        state.players[playerIndex].walls > 0\n      case VerticalWall =>\n        \n        state.players[playerIndex].walls > 0\n  }\n  \n  method ApplyMove(move: Move, playerIndex: int) returns (newState: GameState)\n    requires 0 <= playerIndex < |state.players|\n    requires IsValidMove(move, playerIndex)\n    ensures |newState.players| == |state.players|\n    ensures |newState.walls| >= |state.walls|\n    modifies this\n  {\n    var players := state.players;\n    var walls := state.walls;\n    \n    match move.moveType {\n      case Movement =>\n        \n        var updatedPlayer := Player(move.position, players[playerIndex].walls);\n        players := players[playerIndex := updatedPlayer];\n      case HorizontalWall =>\n        \n        walls := walls + [move.position];\n        var updatedPlayer := Player(\n          players[playerIndex].position,\n          players[playerIndex].walls - 1\n        );\n        players := players[playerIndex := updatedPlayer];\n      case VerticalWall =>\n        \n        walls := walls + [move.position];\n        var updatedPlayer := Player(\n          players[playerIndex].position,\n          players[playerIndex].walls - 1\n        );\n        players := players[playerIndex := updatedPlayer];\n    }\n    \n    newState := GameState(players, walls);\n  }\n  \n  method IsGameWon() returns (won: bool, winner: int)\n    requires |state.players| == 2\n    ensures won ==> (0 <= winner < |state.players|)\n  {\n    won := false;\n    winner := 0;\n    \n    \n    if state.players[0].position.y == 8 {\n      won := true;\n      winner := 0;\n    }\n    \n    else if state.players[1].position.y == 0 {\n      won := true;\n      winner := 1;\n    }\n  }\n}", "name": "py2dfy_452", "id": 452}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module GiftSystem {\n  method SendGift()\n  {\n    \n  }\n  method ShowGift()\n  {\n    \n  }\n  method Main()\n  {\n    SendGift();\n    ShowGift();\n  }\n}", "output": "module GiftSystem {\n  method SendGift()\n    modifies {} \n    ensures true \n  {\n    \n  }\n  method ShowGift()\n    requires true \n    ensures true \n  {\n    \n  }\n  method Main()\n  {\n    SendGift();\n    ShowGift();\n  }\n}", "name": "py2dfy_462", "id": 462}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype URLParam = \n  | StringParam(strValue: string)\n  | IntParam(intValue: int) \n  | NoParam\nclass Route {\n  var path: seq<string>  \n  var paramType: URLParam\n  var handlerName: string\n  var routeName: string\n  constructor(p: seq<string>, param: URLParam, handler: string, name: string)\n  {\n    path := p;\n    paramType := param;\n    handlerName := handler;\n    routeName := name;\n  }\n}\nclass URLRouter {\n  var routes: seq<Route>\n  constructor()\n  {\n    routes := [];\n  }\n  \n  method AddRoute(route: Route?)\n  {\n    routes := routes + [route];\n  }\n  \n  method MatchPath(urlPath: seq<string>) returns (result: (Route?, URLParam))\n  {\n    var i := 0;\n    while i < |routes|\n    {\n      var currentRoute := routes[i];\n      if PathMatches(urlPath, currentRoute.path)\n      {\n        var param := ExtractParam(urlPath, currentRoute.paramType);\n        return (currentRoute, param);\n      }\n      i := i + 1;\n    }\n    \n    return (null, NoParam);\n  }\n  \n  predicate PathMatches(urlPath: seq<string>, routePath: seq<string>)\n  {\n    |urlPath| == |routePath| &&\n    forall i :: 0 <= i < |urlPath| ==>\n      ((|routePath[i]| > 0 && routePath[i][0] == '<') || urlPath[i] == routePath[i])\n  }\n  \n  method ExtractParam(urlPath: seq<string>, paramType: URLParam) returns (result: URLParam)\n      case StringParam(_) => result.StringParam?\n      case IntParam(_) => result.IntParam?\n      case NoParam => result.NoParam?\n  {\n    \n    \n    return paramType;\n  }\n}", "output": "datatype URLParam = \n  | StringParam(strValue: string)\n  | IntParam(intValue: int) \n  | NoParam\nclass Route {\n  var path: seq<string>  \n  var paramType: URLParam\n  var handlerName: string\n  var routeName: string\n  constructor(p: seq<string>, param: URLParam, handler: string, name: string)\n    ensures this.path == p\n    ensures this.paramType == param\n    ensures this.handlerName == handler\n    ensures this.routeName == name\n  {\n    path := p;\n    paramType := param;\n    handlerName := handler;\n    routeName := name;\n  }\n}\nclass URLRouter {\n  var routes: seq<Route>\n  constructor()\n    ensures |routes| == 0\n  {\n    routes := [];\n  }\n  \n  method AddRoute(route: Route?)\n    modifies this\n    requires route != null\n    ensures |routes| == |old(routes)| + 1\n    ensures routes[|routes|-1] == route\n  {\n    routes := routes + [route];\n  }\n  \n  method MatchPath(urlPath: seq<string>) returns (result: (Route?, URLParam))\n    requires |routes| > 0\n    ensures result.0 != null ==> result.0 in routes\n  {\n    var i := 0;\n    while i < |routes|\n      invariant 0 <= i <= |routes|\n    {\n      var currentRoute := routes[i];\n      if PathMatches(urlPath, currentRoute.path)\n      {\n        var param := ExtractParam(urlPath, currentRoute.paramType);\n        return (currentRoute, param);\n      }\n      i := i + 1;\n    }\n    \n    return (null, NoParam);\n  }\n  \n  predicate PathMatches(urlPath: seq<string>, routePath: seq<string>)\n  {\n    |urlPath| == |routePath| &&\n    forall i :: 0 <= i < |urlPath| ==>\n      ((|routePath[i]| > 0 && routePath[i][0] == '<') || urlPath[i] == routePath[i])\n  }\n  \n  method ExtractParam(urlPath: seq<string>, paramType: URLParam) returns (result: URLParam)\n    ensures match paramType\n      case StringParam(_) => result.StringParam?\n      case IntParam(_) => result.IntParam?\n      case NoParam => result.NoParam?\n  {\n    \n    \n    return paramType;\n  }\n}", "name": "py2dfy_449", "id": 449}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype ProjectInfo = ProjectInfo(\n  product: string,\n  field: string, \n  platform: string,\n  location: string,\n  homepage: string,\n  establishTime: string,\n  status: string,\n  tags: string,\n  description: string,\n  contact: string,\n  leadership: seq<string>,\n  logoUrl: string,\n  url: string\n)\nclass {:extern} ExternalOperations {\n  constructor() {} \n  \n  method {:axiom} FetchUrl(url: string) returns (content: string)\n  \n  method {:axiom} SaveToDatabase(info: ProjectInfo)\n}\nclass NewseedScraper {\n  var external: ExternalOperations\n  var crawledUrls: set<string>\n  var allUrls: set<string>\n  constructor()\n  {\n    external := new ExternalOperations();\n    crawledUrls := {};\n    allUrls := {};\n  }\n  \n  method GetUncrawledUrls() returns (urls: seq<string>)\n  {\n    var uncrawled := allUrls - crawledUrls;\n    \n    urls := [];\n    var remaining := uncrawled;\n    while remaining != {}\n    {\n      var url :| url in remaining;\n      urls := urls + [url];\n      remaining := remaining - {url};\n    }\n  }\n  \n  method ParseUrl(url: string) returns (info: ProjectInfo)\n  {\n    var content := external.FetchUrl(url);\n    \n    \n    \n    info := ProjectInfo(\n      \"Product\", \n      \"Field\",\n      \"Platform\", \n      \"Location\",\n      \"Homepage\",\n      \"EstablishTime\",\n      \"Status\",\n      \"Tags\",\n      \"Description\",\n      \"Contact\",\n      [],  \n      \"LogoUrl\",\n      url\n    );\n  }\n  \n  method ProcessUrls(urls: seq<string>) returns (results: seq<ProjectInfo>)\n  {\n    results := [];\n    var i := 0;\n    \n    while i < |urls|\n    {\n      var info := ParseUrl(urls[i]);\n      results := results + [info];\n      i := i + 1;\n    }\n  }\n}", "output": "datatype ProjectInfo = ProjectInfo(\n  product: string,\n  field: string, \n  platform: string,\n  location: string,\n  homepage: string,\n  establishTime: string,\n  status: string,\n  tags: string,\n  description: string,\n  contact: string,\n  leadership: seq<string>,\n  logoUrl: string,\n  url: string\n)\nclass {:extern} ExternalOperations {\n  constructor() {} \n  \n  method {:axiom} FetchUrl(url: string) returns (content: string)\n    requires url != \"\"\n    ensures content != \"\"\n  \n  method {:axiom} SaveToDatabase(info: ProjectInfo)\n    requires info.url != \"\"\n}\nclass NewseedScraper {\n  var external: ExternalOperations\n  var crawledUrls: set<string>\n  var allUrls: set<string>\n  constructor()\n    ensures fresh(external)\n    ensures crawledUrls == {}\n    ensures allUrls == {}\n  {\n    external := new ExternalOperations();\n    crawledUrls := {};\n    allUrls := {};\n  }\n  \n  method GetUncrawledUrls() returns (urls: seq<string>)\n    ensures forall u :: u in urls ==> u in allUrls && u !in crawledUrls\n    ensures forall u :: u in allUrls && u !in crawledUrls ==> u in urls\n  {\n    var uncrawled := allUrls - crawledUrls;\n    \n    urls := [];\n    var remaining := uncrawled;\n    while remaining != {}\n      decreases |remaining|\n      invariant remaining <= uncrawled\n      invariant forall u :: u in urls ==> u in uncrawled\n      invariant forall u :: u in uncrawled ==> u in urls || u in remaining\n    {\n      var url :| url in remaining;\n      urls := urls + [url];\n      remaining := remaining - {url};\n    }\n  }\n  \n  method ParseUrl(url: string) returns (info: ProjectInfo)\n    requires url != \"\"\n    ensures info.url == url\n  {\n    var content := external.FetchUrl(url);\n    \n    \n    \n    info := ProjectInfo(\n      \"Product\", \n      \"Field\",\n      \"Platform\", \n      \"Location\",\n      \"Homepage\",\n      \"EstablishTime\",\n      \"Status\",\n      \"Tags\",\n      \"Description\",\n      \"Contact\",\n      [],  \n      \"LogoUrl\",\n      url\n    );\n  }\n  \n  method ProcessUrls(urls: seq<string>) returns (results: seq<ProjectInfo>)\n    requires forall i :: 0 <= i < |urls| ==> urls[i] != \"\"\n    ensures |results| == |urls|\n    ensures forall i :: 0 <= i < |results| ==> results[i].url == urls[i]\n  {\n    results := [];\n    var i := 0;\n    \n    while i < |urls|\n      invariant 0 <= i <= |urls|\n      invariant |results| == i\n      invariant forall j :: 0 <= j < i ==> results[j].url == urls[j]\n    {\n      var info := ParseUrl(urls[i]);\n      results := results + [info];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_424", "id": 424}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class CompilerState {\n  var filepath: string\n  var filename: string  \n  var filetag: bool\n  \n  constructor()\n  {\n    filepath := \"\";\n    filename := \"\";\n    filetag := false;\n  }\n}\nmodule FileOperations {\n  \n  method CleanFiles(workingDir: string) returns (success: bool)\n  {\n    success := true;\n  }\n  \n  predicate FileExists(path: string)\n  {\n    \n    true\n  }\n}\ndatatype SyntaxRule = \n  | Keyword(pattern: string)\n  | Operator(symbol: string)\n  | Number\n  | Comment\n  | String\nclass SyntaxHighlighter {\n  var rules: seq<SyntaxRule>\n  \n  constructor()\n  {\n    rules := [];\n  }\n  \n  method AddRule(rule: SyntaxRule)\n  {\n    rules := rules + [rule];\n  }\n  \n  method HighlightText(text: string) returns (highlighted: string)\n  {\n    \n    highlighted := text;\n  }\n}\nclass X0Compiler {\n  var state: CompilerState\n  var highlighter: SyntaxHighlighter\n  \n  constructor()\n  {\n    state := new CompilerState();\n    highlighter := new SyntaxHighlighter();\n  }\n  \n  method FileInit()\n  {\n    state.filepath := \"\";\n    state.filename := \"\";\n    state.filetag := false;\n  }\n  \n  method OpenFile(path: string) returns (success: bool)\n  {\n    if FileOperations.FileExists(path) {\n      \n      \n      state.filepath := path;\n      state.filename := path;\n      state.filetag := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method SaveFile(content: string) returns (success: bool)\n  {\n    if state.filetag {\n      \n      success := true;\n    } else {\n      \n      success := false;\n    }\n  }\n}", "output": "class CompilerState {\n  var filepath: string\n  var filename: string  \n  var filetag: bool\n  \n  constructor()\n    ensures filepath == \"\"\n    ensures filename == \"\"\n    ensures !filetag\n  {\n    filepath := \"\";\n    filename := \"\";\n    filetag := false;\n  }\n}\nmodule FileOperations {\n  \n  method CleanFiles(workingDir: string) returns (success: bool)\n    requires workingDir != \"\"\n    ensures success <==> true \n  {\n    success := true;\n  }\n  \n  predicate FileExists(path: string)\n    requires path != \"\"\n  {\n    \n    true\n  }\n}\ndatatype SyntaxRule = \n  | Keyword(pattern: string)\n  | Operator(symbol: string)\n  | Number\n  | Comment\n  | String\nclass SyntaxHighlighter {\n  var rules: seq<SyntaxRule>\n  \n  constructor()\n    ensures fresh(this)\n    ensures |rules| == 0\n  {\n    rules := [];\n  }\n  \n  method AddRule(rule: SyntaxRule)\n    modifies this\n    ensures |rules| == old(|rules|) + 1\n    ensures rules[|rules|-1] == rule\n  {\n    rules := rules + [rule];\n  }\n  \n  method HighlightText(text: string) returns (highlighted: string)\n    requires text != \"\"\n    ensures highlighted != \"\"\n    ensures |highlighted| >= |text|\n  {\n    \n    highlighted := text;\n  }\n}\nclass X0Compiler {\n  var state: CompilerState\n  var highlighter: SyntaxHighlighter\n  \n  constructor()\n    ensures fresh(this)\n    ensures fresh(state)\n    ensures fresh(highlighter)\n  {\n    state := new CompilerState();\n    highlighter := new SyntaxHighlighter();\n  }\n  \n  method FileInit()\n    modifies state\n    ensures state.filepath == \"\"\n    ensures state.filename == \"\"\n    ensures !state.filetag\n  {\n    state.filepath := \"\";\n    state.filename := \"\";\n    state.filetag := false;\n  }\n  \n  method OpenFile(path: string) returns (success: bool)\n    requires path != \"\"\n    modifies state\n    ensures success ==> state.filetag\n    ensures !success ==> !state.filetag\n  {\n    if FileOperations.FileExists(path) {\n      \n      \n      state.filepath := path;\n      state.filename := path;\n      state.filetag := true;\n      success := true;\n    } else {\n      success := false;\n    }\n  }\n  \n  method SaveFile(content: string) returns (success: bool)\n    requires content != \"\"\n    modifies state\n    ensures old(state.filetag) ==> success\n  {\n    if state.filetag {\n      \n      success := true;\n    } else {\n      \n      success := false;\n    }\n  }\n}", "name": "py2dfy_459", "id": 459}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Image = Image(\n  pixels: seq<seq<int>>,  \n  width: nat,             \n  height: nat             \n)\ndatatype Size = Size(width: nat, height: nat)\nclass ImageProcessor {\n  \n  predicate ValidImage(img: Image)\n  {\n    && img.height == |img.pixels|\n    && (img.height > 0 ==> img.width == |img.pixels[0]|)\n    && forall i :: 0 <= i < img.height ==> |img.pixels[i]| == img.width\n  }\n  \n  method NewImage(size: Size) returns (img: Image)\n      0 <= i < img.height && 0 <= j < img.width ==> img.pixels[i][j] == 0\n  {\n    var pixels := seq(size.height, i => seq(size.width, j => 0));\n    img := Image(pixels, size.width, size.height);\n  }\n  \n  method ModifyImage(source: Image, targetSize: Size) returns (result: Image)\n  {\n    \n    var xOffset := (targetSize.width - source.width) / 2;\n    var yOffset := (targetSize.height - source.height) / 2;\n    \n    \n    result := NewImage(targetSize);\n    \n    \n    var i := 0;\n    while i < source.height\n    {\n      var j := 0;\n      while j < source.width\n      {\n        if 0 <= yOffset + i < result.height && 0 <= xOffset + j < result.width {\n          \n          var newPixels := result.pixels[yOffset + i := \n            result.pixels[yOffset + i][xOffset + j := source.pixels[i][j]]];\n          result := Image(newPixels, result.width, result.height);\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method ModifyImages(images: seq<Image>, targetSize: Size) returns (results: seq<Image>)\n      results[i].width == targetSize.width && results[i].height == targetSize.height\n  {\n    results := [];\n    var i := 0;\n    while i < |images|\n        results[j].width == targetSize.width && results[j].height == targetSize.height\n    {\n      var modifiedImage := ModifyImage(images[i], targetSize);\n      results := results + [modifiedImage];\n      i := i + 1;\n    }\n  }\n}", "output": "datatype Image = Image(\n  pixels: seq<seq<int>>,  \n  width: nat,             \n  height: nat             \n)\ndatatype Size = Size(width: nat, height: nat)\nclass ImageProcessor {\n  \n  predicate ValidImage(img: Image)\n  {\n    && img.height == |img.pixels|\n    && (img.height > 0 ==> img.width == |img.pixels[0]|)\n    && forall i :: 0 <= i < img.height ==> |img.pixels[i]| == img.width\n  }\n  \n  method NewImage(size: Size) returns (img: Image)\n    requires size.width > 0 && size.height > 0\n    ensures ValidImage(img)\n    ensures img.width == size.width && img.height == size.height\n    ensures forall i, j :: \n      0 <= i < img.height && 0 <= j < img.width ==> img.pixels[i][j] == 0\n  {\n    var pixels := seq(size.height, i => seq(size.width, j => 0));\n    img := Image(pixels, size.width, size.height);\n  }\n  \n  method ModifyImage(source: Image, targetSize: Size) returns (result: Image)\n    requires ValidImage(source)\n    requires targetSize.width > 0 && targetSize.height > 0\n    ensures ValidImage(result)\n    ensures result.width == targetSize.width && result.height == targetSize.height\n  {\n    \n    var xOffset := (targetSize.width - source.width) / 2;\n    var yOffset := (targetSize.height - source.height) / 2;\n    \n    \n    result := NewImage(targetSize);\n    \n    \n    var i := 0;\n    while i < source.height\n      invariant 0 <= i <= source.height\n      invariant ValidImage(result)\n      invariant result.width == targetSize.width \n      invariant result.height == targetSize.height\n    {\n      var j := 0;\n      while j < source.width\n        invariant 0 <= j <= source.width\n        invariant ValidImage(result)\n        invariant result.width == targetSize.width\n        invariant result.height == targetSize.height\n      {\n        if 0 <= yOffset + i < result.height && 0 <= xOffset + j < result.width {\n          \n          var newPixels := result.pixels[yOffset + i := \n            result.pixels[yOffset + i][xOffset + j := source.pixels[i][j]]];\n          result := Image(newPixels, result.width, result.height);\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n  \n  method ModifyImages(images: seq<Image>, targetSize: Size) returns (results: seq<Image>)\n    requires forall img :: img in images ==> ValidImage(img)\n    requires targetSize.width > 0 && targetSize.height > 0\n    ensures |results| == |images|\n    ensures forall i :: 0 <= i < |results| ==> ValidImage(results[i])\n    ensures forall i :: 0 <= i < |results| ==> \n      results[i].width == targetSize.width && results[i].height == targetSize.height\n  {\n    results := [];\n    var i := 0;\n    while i < |images|\n      invariant 0 <= i <= |images|\n      invariant |results| == i\n      invariant forall j :: 0 <= j < i ==> ValidImage(results[j])\n      invariant forall j :: 0 <= j < i ==> \n        results[j].width == targetSize.width && results[j].height == targetSize.height\n    {\n      var modifiedImage := ModifyImage(images[i], targetSize);\n      results := results + [modifiedImage];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_445", "id": 445}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DataFrame {\n  var rows: seq<Row>\n  ghost var Valid: bool\n  \n  constructor()\n  {\n    rows := [];\n    Valid := true;\n  }\n}\nclass Row {\n  var values: map<string, string>\n  ghost var Valid: bool\n  constructor()\n  {\n    values := map[];\n    Valid := true;\n  }\n}\nmethod ProcessTargetUniprot(df: DataFrame?, proteins: DataFrame?) returns (result: DataFrame?)\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n  {\n    var row := df.rows[i];\n    if \"target_uniprot\" in row.values && row.values[\"target_uniprot\"] != \"\"\n    {\n      var targetUniprot := row.values[\"target_uniprot\"];\n      var found := false;\n      \n      var j := 0;\n      while j < |proteins.rows|\n      {\n        if \"uniprot\" in proteins.rows[j].values && \n           proteins.rows[j].values[\"uniprot\"] == targetUniprot\n        {\n          found := true;\n          break;\n        }\n        j := j + 1;\n      }\n      \n      if found {\n        filteredRows := filteredRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod ProcessLigandGeneSymbol(df: DataFrame?, genes: DataFrame?) returns (result: DataFrame?)\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n  {\n    var row := df.rows[i];\n    if \"ligand_gene_symbol\" in row.values && row.values[\"ligand_gene_symbol\"] != \"\"\n    {\n      var geneSymbol := row.values[\"ligand_gene_symbol\"];\n      var found := false;\n      \n      var j := 0;\n      while j < |genes.rows|\n      {\n        if \"gene_name\" in genes.rows[j].values &&\n           genes.rows[j].values[\"gene_name\"] == geneSymbol\n        {\n          found := true;\n          break;\n        }\n        j := j + 1;\n      }\n      \n      if found {\n        filteredRows := filteredRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod CreateCellphoneFormat(df: DataFrame?) returns (result: DataFrame?)\n{\n  result := new DataFrame();\n  var newRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n  {\n    var row := new Row();\n    if \"uniprot\" in df.rows[i].values && \"target_uniprot\" in df.rows[i].values {\n      row.values := map[\n        \"uniprot_1\" := df.rows[i].values[\"uniprot\"],\n        \"uniprot_2\" := df.rows[i].values[\"target_uniprot\"],\n        \"annotation_strategy\" := \"guidetopharmacology.org\",\n        \"iuphar\" := \"true\"\n      ];\n      row.Valid := true;\n      newRows := newRows + [row];\n    }\n    i := i + 1;\n  }\n  \n  result.rows := newRows;\n  result.Valid := true;\n}\nmethod ProcessInteractions(\n  iuphar: DataFrame?, \n  genes: DataFrame?, \n  proteins: DataFrame?\n) returns (result: DataFrame?)\n{\n  \n  var filtered := FilterBySpecies(iuphar);\n  \n  \n  filtered := ProcessTargetUniprot(filtered, proteins);\n  \n  \n  filtered := ProcessLigandGeneSymbol(filtered, genes);\n  \n  \n  var cellphoneFormat := CreateCellphoneFormat(filtered);\n  \n  \n  result := DropDuplicates(cellphoneFormat);\n}\nmethod FilterBySpecies(df: DataFrame?) returns (result: DataFrame?)\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n  {\n    var row := df.rows[i];\n    if \"target_species\" in row.values && \"ligand_species\" in row.values &&\n       row.values[\"target_species\"] == \"Human\" && \n       row.values[\"ligand_species\"] == \"Human\"\n    {\n      filteredRows := filteredRows + [row];\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod DropDuplicates(df: DataFrame?) returns (result: DataFrame?)\n{\n  result := new DataFrame();\n  var seen := map[];\n  var uniqueRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n  {\n    var row := df.rows[i];\n    if \"uniprot_1\" in row.values && \"uniprot_2\" in row.values\n    {\n      var key := (row.values[\"uniprot_1\"], row.values[\"uniprot_2\"]);\n      if key !in seen {\n        seen := seen[key := true];\n        uniqueRows := uniqueRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := uniqueRows;\n  result.Valid := true;\n}", "output": "class DataFrame {\n  var rows: seq<Row>\n  ghost var Valid: bool\n  \n  constructor()\n    ensures Valid\n    ensures |rows| == 0\n  {\n    rows := [];\n    Valid := true;\n  }\n}\nclass Row {\n  var values: map<string, string>\n  ghost var Valid: bool\n  constructor()\n    ensures Valid\n    ensures |values| == 0\n  {\n    values := map[];\n    Valid := true;\n  }\n}\nmethod ProcessTargetUniprot(df: DataFrame?, proteins: DataFrame?) returns (result: DataFrame?)\n  requires df != null && df.Valid && proteins != null && proteins.Valid\n  ensures result != null && result.Valid\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n    invariant 0 <= i <= |df.rows|\n  {\n    var row := df.rows[i];\n    if \"target_uniprot\" in row.values && row.values[\"target_uniprot\"] != \"\"\n    {\n      var targetUniprot := row.values[\"target_uniprot\"];\n      var found := false;\n      \n      var j := 0;\n      while j < |proteins.rows|\n        invariant 0 <= j <= |proteins.rows|\n      {\n        if \"uniprot\" in proteins.rows[j].values && \n           proteins.rows[j].values[\"uniprot\"] == targetUniprot\n        {\n          found := true;\n          break;\n        }\n        j := j + 1;\n      }\n      \n      if found {\n        filteredRows := filteredRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod ProcessLigandGeneSymbol(df: DataFrame?, genes: DataFrame?) returns (result: DataFrame?)\n  requires df != null && df.Valid && genes != null && genes.Valid\n  ensures result != null && result.Valid\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n    invariant 0 <= i <= |df.rows|\n  {\n    var row := df.rows[i];\n    if \"ligand_gene_symbol\" in row.values && row.values[\"ligand_gene_symbol\"] != \"\"\n    {\n      var geneSymbol := row.values[\"ligand_gene_symbol\"];\n      var found := false;\n      \n      var j := 0;\n      while j < |genes.rows|\n        invariant 0 <= j <= |genes.rows|\n      {\n        if \"gene_name\" in genes.rows[j].values &&\n           genes.rows[j].values[\"gene_name\"] == geneSymbol\n        {\n          found := true;\n          break;\n        }\n        j := j + 1;\n      }\n      \n      if found {\n        filteredRows := filteredRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod CreateCellphoneFormat(df: DataFrame?) returns (result: DataFrame?)\n  requires df != null && df.Valid\n  ensures result != null && result.Valid\n{\n  result := new DataFrame();\n  var newRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n    invariant 0 <= i <= |df.rows|\n  {\n    var row := new Row();\n    if \"uniprot\" in df.rows[i].values && \"target_uniprot\" in df.rows[i].values {\n      row.values := map[\n        \"uniprot_1\" := df.rows[i].values[\"uniprot\"],\n        \"uniprot_2\" := df.rows[i].values[\"target_uniprot\"],\n        \"annotation_strategy\" := \"guidetopharmacology.org\",\n        \"iuphar\" := \"true\"\n      ];\n      row.Valid := true;\n      newRows := newRows + [row];\n    }\n    i := i + 1;\n  }\n  \n  result.rows := newRows;\n  result.Valid := true;\n}\nmethod ProcessInteractions(\n  iuphar: DataFrame?, \n  genes: DataFrame?, \n  proteins: DataFrame?\n) returns (result: DataFrame?)\n  requires iuphar != null && genes != null && proteins != null\n  requires iuphar.Valid && genes.Valid && proteins.Valid\n  ensures result != null && result.Valid\n{\n  \n  var filtered := FilterBySpecies(iuphar);\n  \n  \n  filtered := ProcessTargetUniprot(filtered, proteins);\n  \n  \n  filtered := ProcessLigandGeneSymbol(filtered, genes);\n  \n  \n  var cellphoneFormat := CreateCellphoneFormat(filtered);\n  \n  \n  result := DropDuplicates(cellphoneFormat);\n}\nmethod FilterBySpecies(df: DataFrame?) returns (result: DataFrame?)\n  requires df != null && df.Valid\n  ensures result != null && result.Valid\n{\n  result := new DataFrame();\n  var filteredRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n    invariant 0 <= i <= |df.rows|\n  {\n    var row := df.rows[i];\n    if \"target_species\" in row.values && \"ligand_species\" in row.values &&\n       row.values[\"target_species\"] == \"Human\" && \n       row.values[\"ligand_species\"] == \"Human\"\n    {\n      filteredRows := filteredRows + [row];\n    }\n    i := i + 1;\n  }\n  \n  result.rows := filteredRows;\n  result.Valid := true;\n}\nmethod DropDuplicates(df: DataFrame?) returns (result: DataFrame?)\n  requires df != null && df.Valid\n  ensures result != null && result.Valid\n{\n  result := new DataFrame();\n  var seen := map[];\n  var uniqueRows := [];\n  \n  var i := 0;\n  while i < |df.rows|\n    invariant 0 <= i <= |df.rows|\n  {\n    var row := df.rows[i];\n    if \"uniprot_1\" in row.values && \"uniprot_2\" in row.values\n    {\n      var key := (row.values[\"uniprot_1\"], row.values[\"uniprot_2\"]);\n      if key !in seen {\n        seen := seen[key := true];\n        uniqueRows := uniqueRows + [row];\n      }\n    }\n    i := i + 1;\n  }\n  \n  result.rows := uniqueRows;\n  result.Valid := true;\n}", "name": "py2dfy_451", "id": 451}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class User {\n  var fname: string\n  var lname: string \n  var email: string\n  var password: string\n  var contactNo: string\n  var address: string\n}\nclass Contact {\n  var name: string\n  var email: string\n  var phoneNo: string\n  var message: string\n}\nclass Database {\n  var users: seq<User>\n  var contacts: seq<Contact>\n  constructor()\n  {\n    users := [];\n    contacts := [];\n  }\n  method RegisterUser(u: User) returns (success: bool)\n  {\n    users := users + [u];\n    success := true;\n  }\n  method LoginUser(email: string, password: string) returns (user: User?)\n  {\n    var i := 0;\n    while i < |users|\n    {\n      if users[i].email == email && users[i].password == password {\n        user := users[i];\n        return;\n      }\n      i := i + 1;\n    }\n    user := null;\n  }\n  method AddContact(c: Contact) returns (success: bool)\n  {\n    contacts := contacts + [c];\n    success := true;\n  }\n}\nmethod Main()\n{\n  var db := new Database();\n  \n  var newUser := new User;\n  newUser.fname := \"John\";\n  newUser.lname := \"Doe\";\n  newUser.email := \"john@example.com\";\n  newUser.password := \"password123\";\n  newUser.contactNo := \"1234567890\";\n  newUser.address := \"123 Main St\";\n  var registerSuccess := db.RegisterUser(newUser);\n  \n  var loggedInUser := db.LoginUser(\"john@example.com\", \"password123\");\n  \n  var newContact := new Contact;\n  newContact.name := \"Jane Smith\";\n  newContact.email := \"jane@example.com\";\n  newContact.phoneNo := \"9876543210\";\n  newContact.message := \"Hello, this is a test message.\";\n  var contactSuccess := db.AddContact(newContact);\n}", "output": "class User {\n  var fname: string\n  var lname: string \n  var email: string\n  var password: string\n  var contactNo: string\n  var address: string\n}\nclass Contact {\n  var name: string\n  var email: string\n  var phoneNo: string\n  var message: string\n}\nclass Database {\n  var users: seq<User>\n  var contacts: seq<Contact>\n  constructor()\n    ensures fresh(users) && fresh(contacts)\n    ensures |users| == 0 && |contacts| == 0\n  {\n    users := [];\n    contacts := [];\n  }\n  method RegisterUser(u: User) returns (success: bool)\n    modifies this`users\n    ensures success \n    ensures |users| == old(|users|) + 1 \n    ensures users[|users|-1] == u\n  {\n    users := users + [u];\n    success := true;\n  }\n  method LoginUser(email: string, password: string) returns (user: User?)\n    ensures user != null ==> exists i :: 0 <= i < |users| && users[i].email == email && users[i].password == password && user == users[i]\n    ensures user == null ==> forall i :: 0 <= i < |users| ==> users[i].email != email || users[i].password != password\n  {\n    var i := 0;\n    while i < |users|\n      invariant 0 <= i <= |users|\n      invariant forall j :: 0 <= j < i ==> users[j].email != email || users[j].password != password\n    {\n      if users[i].email == email && users[i].password == password {\n        user := users[i];\n        return;\n      }\n      i := i + 1;\n    }\n    user := null;\n  }\n  method AddContact(c: Contact) returns (success: bool)\n    modifies this`contacts\n    ensures success\n    ensures |contacts| == old(|contacts|) + 1\n    ensures contacts[|contacts|-1] == c\n  {\n    contacts := contacts + [c];\n    success := true;\n  }\n}\nmethod Main()\n{\n  var db := new Database();\n  \n  var newUser := new User;\n  newUser.fname := \"John\";\n  newUser.lname := \"Doe\";\n  newUser.email := \"john@example.com\";\n  newUser.password := \"password123\";\n  newUser.contactNo := \"1234567890\";\n  newUser.address := \"123 Main St\";\n  var registerSuccess := db.RegisterUser(newUser);\n  assert registerSuccess;\n  \n  var loggedInUser := db.LoginUser(\"john@example.com\", \"password123\");\n  assert loggedInUser != null;\n  assert loggedInUser.fname == \"John\";\n  \n  var newContact := new Contact;\n  newContact.name := \"Jane Smith\";\n  newContact.email := \"jane@example.com\";\n  newContact.phoneNo := \"9876543210\";\n  newContact.message := \"Hello, this is a test message.\";\n  var contactSuccess := db.AddContact(newContact);\n  assert contactSuccess;\n}", "name": "py2dfy_446", "id": 446}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DateTime {\n  var year: int\n  var month: int\n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  \n  predicate Valid()\n  {\n    && 1 <= month <= 12\n    && 1 <= day <= 31  \n    && 0 <= hour <= 23\n    && 0 <= minute <= 59\n    && 0 <= second <= 59\n  }\n  \n  constructor(y: int, m: int, d: int, h: int, min: int, s: int)\n  {\n    year := y;\n    month := m;\n    day := d;\n    hour := h;\n    minute := min;\n    second := s;\n  }\n  \n  \n  method GetWeekday() returns (weekday: int)\n  {\n    var m := if month <= 2 then month + 12 else month;\n    var y := if month <= 2 then year - 1 else year;\n    \n    var k := y % 100;\n    var j := y / 100;\n    \n    weekday := (day + ((13 * (m + 1)) / 5) + k + (k / 4) + (j / 4) - (2 * j)) % 7;\n    if weekday < 0 { weekday := weekday + 7; }\n    \n    weekday := (weekday + 5) % 7;\n  }\n  \n  method AddSeconds(seconds: int) returns (newDateTime: DateTime?)\n  {\n    \n    var newSecond := second + seconds;\n    if 0 <= newSecond <= 59 {\n      newDateTime := new DateTime(year, month, day, hour, minute, newSecond);\n      return;\n    }\n    \n    return null;\n  }\n  \n  method AddDays(days: int) returns (newDateTime: DateTime?)\n  {\n    \n    var newDay := day + days;\n    if 1 <= newDay <= 31 {  \n      newDateTime := new DateTime(year, month, newDay, hour, minute, second);\n      return;\n    }\n    \n    return null;\n  }\n  \n  method PrintInfo()\n  {\n    print \"Year: \", year, \"\\n\";\n    print \"Month: \", month, \"\\n\";\n    var w := GetWeekday();\n    print \"Week: \", w, \"\\n\";\n  }\n}\nmethod Main()\n{\n  \n  var dt := new DateTime(2024, 3, 15, 12, 0, 0);\n  \n  dt.PrintInfo();\n  \n  var futureDate := dt.AddDays(5);\n  if futureDate != null {\n    print \"+5 days: \";\n    futureDate.PrintInfo();\n  }\n  \n  var futureTime := dt.AddSeconds(5);\n  if futureTime != null {\n    print \"+5 seconds: \";\n    futureTime.PrintInfo();\n  }\n}", "output": "class DateTime {\n  var year: int\n  var month: int\n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  \n  predicate Valid()\n    reads this\n  {\n    && 1 <= month <= 12\n    && 1 <= day <= 31  \n    && 0 <= hour <= 23\n    && 0 <= minute <= 59\n    && 0 <= second <= 59\n  }\n  \n  constructor(y: int, m: int, d: int, h: int, min: int, s: int)\n    requires 1 <= m <= 12\n    requires 1 <= d <= 31\n    requires 0 <= h <= 23\n    requires 0 <= min <= 59\n    requires 0 <= s <= 59\n    ensures Valid()\n    ensures year == y\n    ensures month == m\n    ensures day == d\n    ensures hour == h\n    ensures minute == min\n    ensures second == s\n  {\n    year := y;\n    month := m;\n    day := d;\n    hour := h;\n    minute := min;\n    second := s;\n  }\n  \n  \n  method GetWeekday() returns (weekday: int)\n    requires Valid()\n    ensures 0 <= weekday <= 6\n  {\n    var m := if month <= 2 then month + 12 else month;\n    var y := if month <= 2 then year - 1 else year;\n    \n    var k := y % 100;\n    var j := y / 100;\n    \n    weekday := (day + ((13 * (m + 1)) / 5) + k + (k / 4) + (j / 4) - (2 * j)) % 7;\n    if weekday < 0 { weekday := weekday + 7; }\n    \n    weekday := (weekday + 5) % 7;\n  }\n  \n  method AddSeconds(seconds: int) returns (newDateTime: DateTime?)\n    requires Valid()\n    ensures newDateTime != null ==> newDateTime.Valid()\n  {\n    \n    var newSecond := second + seconds;\n    if 0 <= newSecond <= 59 {\n      newDateTime := new DateTime(year, month, day, hour, minute, newSecond);\n      return;\n    }\n    \n    return null;\n  }\n  \n  method AddDays(days: int) returns (newDateTime: DateTime?)\n    requires Valid()\n    ensures newDateTime != null ==> newDateTime.Valid()\n  {\n    \n    var newDay := day + days;\n    if 1 <= newDay <= 31 {  \n      newDateTime := new DateTime(year, month, newDay, hour, minute, second);\n      return;\n    }\n    \n    return null;\n  }\n  \n  method PrintInfo()\n    requires Valid()\n  {\n    print \"Year: \", year, \"\\n\";\n    print \"Month: \", month, \"\\n\";\n    var w := GetWeekday();\n    print \"Week: \", w, \"\\n\";\n  }\n}\nmethod Main()\n{\n  \n  var dt := new DateTime(2024, 3, 15, 12, 0, 0);\n  \n  dt.PrintInfo();\n  \n  var futureDate := dt.AddDays(5);\n  if futureDate != null {\n    print \"+5 days: \";\n    futureDate.PrintInfo();\n  }\n  \n  var futureTime := dt.AddSeconds(5);\n  if futureTime != null {\n    print \"+5 seconds: \";\n    futureTime.PrintInfo();\n  }\n}", "name": "py2dfy_435", "id": 435}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class CouplingMap {\n  var edges: seq<(int, int)>\n  constructor() {\n    edges := [];\n  }\n  method FromGrid(rows: int, cols: int) returns (result: seq<(int, int)>)\n  {\n    var grid: seq<(int, int)> := [];\n    var r := 0;\n    while r < rows \n    {\n      var c := 0;\n      while c < cols - 1\n      {\n        grid := grid + [(r * cols + c, r * cols + c + 1)];\n        c := c + 1;\n      }\n      r := r + 1;\n    }\n    r := 0;\n    while r < rows - 1\n    {\n      var c := 0;\n      while c < cols\n      {\n        grid := grid + [(r * cols + c, (r + 1) * cols + c)];\n        c := c + 1;\n      }\n      r := r + 1;\n    }\n    return grid;\n  }\n}\nclass FakeChalmers {\n  var nQubits: int\n  var basisGates: seq<string>\n  var couplingMap: seq<(int, int)>\n  \n  constructor()\n  {\n    nQubits := 20;\n    basisGates := [\"rx\", \"rz\", \"iswap\", \"cz\", \"id\"];\n    \n    var coupling := new CouplingMap();\n    var tempCouplingMap := coupling.FromGrid(4, 5);\n    couplingMap := tempCouplingMap;\n  }\n}", "output": "class CouplingMap {\n  var edges: seq<(int, int)>\n  constructor() {\n    edges := [];\n  }\n  method FromGrid(rows: int, cols: int) returns (result: seq<(int, int)>)\n    requires rows > 0 && cols > 0\n    ensures |result| >= 0\n  {\n    var grid: seq<(int, int)> := [];\n    var r := 0;\n    while r < rows \n      invariant 0 <= r <= rows\n      invariant |grid| >= 0\n    {\n      var c := 0;\n      while c < cols - 1\n        invariant 0 <= c <= cols - 1\n        invariant |grid| >= 0\n      {\n        grid := grid + [(r * cols + c, r * cols + c + 1)];\n        c := c + 1;\n      }\n      r := r + 1;\n    }\n    r := 0;\n    while r < rows - 1\n      invariant 0 <= r <= rows - 1\n      invariant |grid| >= 0\n    {\n      var c := 0;\n      while c < cols\n        invariant 0 <= c <= cols\n        invariant |grid| >= 0\n      {\n        grid := grid + [(r * cols + c, (r + 1) * cols + c)];\n        c := c + 1;\n      }\n      r := r + 1;\n    }\n    return grid;\n  }\n}\nclass FakeChalmers {\n  var nQubits: int\n  var basisGates: seq<string>\n  var couplingMap: seq<(int, int)>\n  \n  constructor()\n    ensures nQubits == 20\n    ensures |basisGates| == 5\n    ensures basisGates[0] == \"rx\"\n  {\n    nQubits := 20;\n    basisGates := [\"rx\", \"rz\", \"iswap\", \"cz\", \"id\"];\n    \n    var coupling := new CouplingMap();\n    var tempCouplingMap := coupling.FromGrid(4, 5);\n    couplingMap := tempCouplingMap;\n  }\n}", "name": "py2dfy_473", "id": 473}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Scenario = Scenario(path: string)\ndatatype TestCase = TestCase(a: string, b: string, x: string)\ndatatype Answer = Answer(\n    questionNum: nat,\n    xAnswerAlpha: string,\n    aValue: string,\n    bValue: string\n)\nclass ABXTest {\n    \n    const USER_ANSWER_CASE_A: string\n    const USER_ANSWER_CASE_B: string\n    const MAX_CASE_NUM: nat\n    \n    constructor()\n    {\n        USER_ANSWER_CASE_A := \"A\";\n        USER_ANSWER_CASE_B := \"B\";\n        MAX_CASE_NUM := 24;\n    }\n    \n    method ValidateScenarios(scenario1: Scenario, scenario2: Scenario) returns (valid: bool)\n    {\n        valid := scenario1.path != \"\" && scenario2.path != \"\";\n    }\n    \n    method CreateTestCase(caseNum: nat, file1: string, file2: string) returns (testCase: TestCase, answer: Answer)\n    {\n        \n        var switchAB := if caseNum % 2 == 0 then true else false;\n        \n        \n        var xAnswer := if caseNum % 2 == 0 then true else false;\n        \n        var (aFile, bFile, xFile, xAnswerAlpha, aValue, bValue) := if switchAB then\n            if xAnswer then\n                (file2, file1, file2, USER_ANSWER_CASE_A, \"scenario_two\", \"scenario_one\")\n            else\n                (file2, file1, file1, USER_ANSWER_CASE_B, \"scenario_two\", \"scenario_one\")\n        else\n            if xAnswer then\n                (file1, file2, file1, USER_ANSWER_CASE_A, \"scenario_one\", \"scenario_two\")\n            else\n                (file1, file2, file2, USER_ANSWER_CASE_B, \"scenario_one\", \"scenario_two\");\n                \n        testCase := TestCase(aFile, bFile, xFile);\n        answer := Answer(caseNum, xAnswerAlpha, aValue, bValue);\n    }\n    \n    method CreateABXCases(files: seq<(string, string)>) returns (cases: seq<TestCase>, answers: seq<Answer>)\n            files[i].0 != \"\" && files[i].1 != \"\"\n    {\n        var numCases := if |files| > MAX_CASE_NUM + 1 then MAX_CASE_NUM + 1 else |files|;\n        \n        \n        cases := [];\n        answers := [];\n        \n        var i := 0;\n        while i < numCases\n                answers[j].questionNum == j &&\n                answers[j].xAnswerAlpha in {USER_ANSWER_CASE_A, USER_ANSWER_CASE_B}\n        {\n            var testCase, answer := CreateTestCase(i, files[i].0, files[i].1);\n            cases := cases + [testCase];\n            answers := answers + [answer];\n            i := i + 1;\n        }\n    }\n}", "output": "datatype Scenario = Scenario(path: string)\ndatatype TestCase = TestCase(a: string, b: string, x: string)\ndatatype Answer = Answer(\n    questionNum: nat,\n    xAnswerAlpha: string,\n    aValue: string,\n    bValue: string\n)\nclass ABXTest {\n    \n    const USER_ANSWER_CASE_A: string\n    const USER_ANSWER_CASE_B: string\n    const MAX_CASE_NUM: nat\n    \n    constructor()\n    {\n        USER_ANSWER_CASE_A := \"A\";\n        USER_ANSWER_CASE_B := \"B\";\n        MAX_CASE_NUM := 24;\n    }\n    \n    method ValidateScenarios(scenario1: Scenario, scenario2: Scenario) returns (valid: bool)\n        ensures valid ==> scenario1.path != \"\" && scenario2.path != \"\"\n    {\n        valid := scenario1.path != \"\" && scenario2.path != \"\";\n    }\n    \n    method CreateTestCase(caseNum: nat, file1: string, file2: string) returns (testCase: TestCase, answer: Answer)\n        requires caseNum <= MAX_CASE_NUM\n        requires file1 != \"\" && file2 != \"\"\n        ensures answer.questionNum == caseNum\n        ensures answer.xAnswerAlpha in {USER_ANSWER_CASE_A, USER_ANSWER_CASE_B}\n    {\n        \n        var switchAB := if caseNum % 2 == 0 then true else false;\n        \n        \n        var xAnswer := if caseNum % 2 == 0 then true else false;\n        \n        var (aFile, bFile, xFile, xAnswerAlpha, aValue, bValue) := if switchAB then\n            if xAnswer then\n                (file2, file1, file2, USER_ANSWER_CASE_A, \"scenario_two\", \"scenario_one\")\n            else\n                (file2, file1, file1, USER_ANSWER_CASE_B, \"scenario_two\", \"scenario_one\")\n        else\n            if xAnswer then\n                (file1, file2, file1, USER_ANSWER_CASE_A, \"scenario_one\", \"scenario_two\")\n            else\n                (file1, file2, file2, USER_ANSWER_CASE_B, \"scenario_one\", \"scenario_two\");\n                \n        testCase := TestCase(aFile, bFile, xFile);\n        answer := Answer(caseNum, xAnswerAlpha, aValue, bValue);\n    }\n    \n    method CreateABXCases(files: seq<(string, string)>) returns (cases: seq<TestCase>, answers: seq<Answer>)\n        requires |files| > 0\n        requires forall i :: 0 <= i < |files| ==> \n            files[i].0 != \"\" && files[i].1 != \"\"\n        ensures |cases| == |answers|\n        ensures if |files| > MAX_CASE_NUM + 1 then |cases| == MAX_CASE_NUM + 1 else |cases| == |files|\n    {\n        var numCases := if |files| > MAX_CASE_NUM + 1 then MAX_CASE_NUM + 1 else |files|;\n        \n        \n        cases := [];\n        answers := [];\n        \n        var i := 0;\n        while i < numCases\n            invariant 0 <= i <= numCases\n            invariant |cases| == |answers| == i\n            invariant forall j :: 0 <= j < i ==>\n                answers[j].questionNum == j &&\n                answers[j].xAnswerAlpha in {USER_ANSWER_CASE_A, USER_ANSWER_CASE_B}\n        {\n            var testCase, answer := CreateTestCase(i, files[i].0, files[i].1);\n            cases := cases + [testCase];\n            answers := answers + [answer];\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_468", "id": 468}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class BoundingBox {\n  var coords: seq<real>\n  constructor(c: seq<real>)\n  {\n    coords := c;\n  }\n  method repr() returns (s: string)\n  {\n    \n    s := \"0 0 0 0\";  \n  }\n}\nclass Image {\n  var index: nat\n  var bboxes: seq<BoundingBox>\n  constructor(idx: nat)\n  {\n    index := idx;\n    bboxes := [];\n  }\n}\nclass Detector {\n  var modelPath: string\n  var imagePath: string\n  constructor(mPath: string, iPath: string)\n  {\n    modelPath := mPath;\n    imagePath := iPath;\n  }\n  \n  method detect(imgPath: string) returns (boxes: seq<BoundingBox>)\n  {\n    \n    boxes := [];\n  }\n}\nmethod ProcessImages(imageList: seq<string>, modelPath: string, imagePath: string) \n  returns (frames: seq<Image>)\n{\n  var detector := new Detector(modelPath, imagePath);\n  frames := [];\n  \n  \n  var i := 0;\n  while i < |imageList|\n  {\n    var img := new Image(i + 1);  \n    var boxes := detector.detect(imageList[i]);\n    img.bboxes := boxes;\n    frames := frames + [img];\n    i := i + 1;\n  }\n}\nmethod WriteDetections(frames: seq<Image>, filename: string)\n{\n  \n  \n}", "output": "class BoundingBox {\n  var coords: seq<real>\n  constructor(c: seq<real>)\n    requires |c| == 4  \n    ensures coords == c\n  {\n    coords := c;\n  }\n  method repr() returns (s: string)\n    ensures |s| > 0  \n  {\n    \n    s := \"0 0 0 0\";  \n  }\n}\nclass Image {\n  var index: nat\n  var bboxes: seq<BoundingBox>\n  constructor(idx: nat)\n    requires idx > 0  \n    ensures index == idx\n    ensures |bboxes| == 0\n  {\n    index := idx;\n    bboxes := [];\n  }\n}\nclass Detector {\n  var modelPath: string\n  var imagePath: string\n  constructor(mPath: string, iPath: string)\n    requires |mPath| > 0 && |iPath| > 0\n    ensures modelPath == mPath && imagePath == iPath\n  {\n    modelPath := mPath;\n    imagePath := iPath;\n  }\n  \n  method detect(imgPath: string) returns (boxes: seq<BoundingBox>)\n    requires |imgPath| > 0\n    ensures |boxes| >= 0  \n  {\n    \n    boxes := [];\n  }\n}\nmethod ProcessImages(imageList: seq<string>, modelPath: string, imagePath: string) \n  returns (frames: seq<Image>)\n  requires |imageList| > 0\n  requires |modelPath| > 0 && |imagePath| > 0\n  requires forall i :: 0 <= i < |imageList| ==> |imageList[i]| > 0\n  ensures |frames| == |imageList|  \n{\n  var detector := new Detector(modelPath, imagePath);\n  frames := [];\n  \n  \n  var i := 0;\n  while i < |imageList|\n    invariant 0 <= i <= |imageList|\n    invariant |frames| == i  \n  {\n    var img := new Image(i + 1);  \n    var boxes := detector.detect(imageList[i]);\n    img.bboxes := boxes;\n    frames := frames + [img];\n    i := i + 1;\n  }\n}\nmethod WriteDetections(frames: seq<Image>, filename: string)\n  requires |filename| > 0\n  requires |frames| > 0\n{\n  \n  \n}", "name": "py2dfy_469", "id": 469}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype LogLevel = DebugLevel | InfoLevel | WarningLevel | ErrorLevel \nclass LogMessage {\n  var level: LogLevel\n  var message: string\n  constructor(lvl: LogLevel, msg: string)\n  {\n    level := lvl;\n    message := msg;\n  }\n}\nclass Logger {\n  \n  var logHistory: seq<LogMessage>\n  constructor()\n  {\n    logHistory := [];\n  }\n  \n  method Log(level: LogLevel, message: string)\n            logHistory[i] == old(logHistory[i])  \n  {\n    var newMessage := new LogMessage(level, message);\n    logHistory := logHistory + [newMessage];\n  }\n  \n  method Debug(message: string)\n  {\n    Log(DebugLevel, message);\n  }\n  method Info(message: string)\n  {\n    Log(InfoLevel, message);\n  }\n  method Warning(message: string)\n  {\n    Log(WarningLevel, message);\n  }\n  method Error(message: string)\n  {\n    Log(ErrorLevel, message);\n  }\n}\nmethod Main()\n{\n  var logger := new Logger();\n  logger.Debug(\"这是一条debug日志\");\n  logger.Info(\"这是一条info日志\"); \n  logger.Error(\"这是一条error日志\");\n  logger.Warning(\"这是一条warning日志\");\n}", "output": "datatype LogLevel = DebugLevel | InfoLevel | WarningLevel | ErrorLevel \nclass LogMessage {\n  var level: LogLevel\n  var message: string\n  constructor(lvl: LogLevel, msg: string)\n    ensures this.level == lvl\n    ensures this.message == msg\n  {\n    level := lvl;\n    message := msg;\n  }\n}\nclass Logger {\n  \n  var logHistory: seq<LogMessage>\n  constructor()\n    ensures |logHistory| == 0  \n  {\n    logHistory := [];\n  }\n  \n  method Log(level: LogLevel, message: string)\n    modifies this\n    ensures |logHistory| == old(|logHistory|) + 1  \n    ensures logHistory[|logHistory|-1].level == level  \n    ensures logHistory[|logHistory|-1].message == message  \n    ensures forall i :: 0 <= i < old(|logHistory|) ==> \n            logHistory[i] == old(logHistory[i])  \n  {\n    var newMessage := new LogMessage(level, message);\n    logHistory := logHistory + [newMessage];\n  }\n  \n  method Debug(message: string)\n    modifies this\n    ensures |logHistory| == old(|logHistory|) + 1\n    ensures logHistory[|logHistory|-1].level == DebugLevel\n    ensures logHistory[|logHistory|-1].message == message\n  {\n    Log(DebugLevel, message);\n  }\n  method Info(message: string)\n    modifies this\n    ensures |logHistory| == old(|logHistory|) + 1\n    ensures logHistory[|logHistory|-1].level == InfoLevel\n    ensures logHistory[|logHistory|-1].message == message\n  {\n    Log(InfoLevel, message);\n  }\n  method Warning(message: string)\n    modifies this\n    ensures |logHistory| == old(|logHistory|) + 1\n    ensures logHistory[|logHistory|-1].level == WarningLevel\n    ensures logHistory[|logHistory|-1].message == message\n  {\n    Log(WarningLevel, message);\n  }\n  method Error(message: string)\n    modifies this\n    ensures |logHistory| == old(|logHistory|) + 1\n    ensures logHistory[|logHistory|-1].level == ErrorLevel\n    ensures logHistory[|logHistory|-1].message == message\n  {\n    Log(ErrorLevel, message);\n  }\n}\nmethod Main()\n{\n  var logger := new Logger();\n  logger.Debug(\"这是一条debug日志\");\n  logger.Info(\"这是一条info日志\"); \n  logger.Error(\"这是一条error日志\");\n  logger.Warning(\"这是一条warning日志\");\n}", "name": "py2dfy_465", "id": 465}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait Provider {\n  \n  var name: string\n  var enabled: bool\n  \n  \n  predicate Valid()\n  {\n    name != \"\" && enabled == true\n  }\n  \n  \n  method Init(providerName: string)\n  {\n    name := providerName;\n    enabled := true;\n  }\n  \n  \n  method Enable()\n  {\n    enabled := true;\n  }\n  \n  \n  method Disable()\n  {\n    enabled := false;\n  }\n  \n  \n  method IsEnabled() returns (isEnabled: bool)\n  {\n    return enabled;\n  }\n  \n  \n  method GetName() returns (providerName: string)\n  {\n    return name;\n  }\n}\nclass External extends Provider {\n  constructor(providerName: string)\n  {\n    this.name := providerName;\n    this.enabled := true;\n  }\n}", "output": "trait Provider {\n  \n  var name: string\n  var enabled: bool\n  \n  \n  predicate Valid()\n    reads this\n  {\n    name != \"\" && enabled == true\n  }\n  \n  \n  method Init(providerName: string)\n    requires providerName != \"\"  \n    modifies this\n    ensures name == providerName \n    ensures enabled == true      \n    ensures Valid()\n  {\n    name := providerName;\n    enabled := true;\n  }\n  \n  \n  method Enable()\n    modifies this\n    ensures enabled == true      \n    ensures name == old(name)    \n  {\n    enabled := true;\n  }\n  \n  \n  method Disable()\n    modifies this\n    ensures enabled == false     \n    ensures name == old(name)    \n  {\n    enabled := false;\n  }\n  \n  \n  method IsEnabled() returns (isEnabled: bool)\n    ensures isEnabled == enabled  \n  {\n    return enabled;\n  }\n  \n  \n  method GetName() returns (providerName: string)\n    ensures providerName == name  \n  {\n    return name;\n  }\n}\nclass External extends Provider {\n  constructor(providerName: string)\n    requires providerName != \"\"\n    ensures Valid()\n  {\n    this.name := providerName;\n    this.enabled := true;\n  }\n}", "name": "py2dfy_475", "id": 475}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype PathComponent = Literal(s: string) | Parameter(name: string, paramType: string)\ndatatype Consumer = BoardConsumer\nclass Route {\n  var path: seq<PathComponent>\n  var consumer: Consumer\n  \n  constructor(p: seq<PathComponent>, c: Consumer)\n  {\n    path := p;\n    consumer := c;\n  }\n}\nclass Router {\n  var routes: seq<Route>\n  \n  constructor()\n  {\n    routes := [];\n  }\n  \n  \n  method AddRoute(path: seq<PathComponent>, consumer: Consumer) returns (success: bool)\n  {\n    var newRoute := new Route(path, consumer);\n    routes := routes + [newRoute];\n    return true;\n  }\n  \n  \n  method MatchUrl(url: string) returns (consumer: Consumer, found: bool)\n  {\n    var i := 0;\n    consumer := BoardConsumer; \n    found := false; \n    \n    \n    while i < |routes|\n    {\n      if UrlMatchesRoute(url, routes[i].path) {\n        consumer := routes[i].consumer;\n        found := true;\n        return;\n      }\n      i := i + 1;\n    }\n  }\n  \n  \n  predicate UrlMatchesRoute(url: string, pattern: seq<PathComponent>)\n  {\n    \n    true  \n  }\n}\nmethod Main()\n{\n  var router := new Router();\n  \n  \n  var boardPath := [Parameter(\"board_url\", \"slug\")];\n  \n  \n  var success := router.AddRoute(boardPath, BoardConsumer);\n  \n  \n  var consumer, found := router.MatchUrl(\"some-board-123\");\n}", "output": "datatype PathComponent = Literal(s: string) | Parameter(name: string, paramType: string)\ndatatype Consumer = BoardConsumer\nclass Route {\n  var path: seq<PathComponent>\n  var consumer: Consumer\n  \n  constructor(p: seq<PathComponent>, c: Consumer)\n    ensures path == p && consumer == c\n  {\n    path := p;\n    consumer := c;\n  }\n}\nclass Router {\n  var routes: seq<Route>\n  \n  constructor()\n    ensures |routes| == 0\n  {\n    routes := [];\n  }\n  \n  \n  method AddRoute(path: seq<PathComponent>, consumer: Consumer) returns (success: bool)\n    modifies this\n    ensures success ==> |routes| == old(|routes|) + 1\n    ensures !success ==> routes == old(routes)\n    ensures success ==> routes[|routes|-1].path == path && routes[|routes|-1].consumer == consumer\n  {\n    var newRoute := new Route(path, consumer);\n    routes := routes + [newRoute];\n    return true;\n  }\n  \n  \n  method MatchUrl(url: string) returns (consumer: Consumer, found: bool)\n    requires |url| > 0\n    ensures !found ==> consumer == BoardConsumer \n    ensures found ==> exists i :: 0 <= i < |routes| && UrlMatchesRoute(url, routes[i].path)\n  {\n    var i := 0;\n    consumer := BoardConsumer; \n    found := false; \n    \n    \n    while i < |routes|\n      invariant 0 <= i <= |routes|\n      invariant !found ==> consumer == BoardConsumer\n      decreases |routes| - i\n    {\n      if UrlMatchesRoute(url, routes[i].path) {\n        consumer := routes[i].consumer;\n        found := true;\n        return;\n      }\n      i := i + 1;\n    }\n  }\n  \n  \n  predicate UrlMatchesRoute(url: string, pattern: seq<PathComponent>)\n    requires |url| > 0\n  {\n    \n    true  \n  }\n}\nmethod Main()\n{\n  var router := new Router();\n  \n  \n  var boardPath := [Parameter(\"board_url\", \"slug\")];\n  \n  \n  var success := router.AddRoute(boardPath, BoardConsumer);\n  \n  \n  var consumer, found := router.MatchUrl(\"some-board-123\");\n}", "name": "py2dfy_463", "id": 463}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype IPAddress = IPAddr(octets: seq<int>)\ndatatype MACAddress = MacAddr(bytes: seq<int>) \ndatatype PacketStats = PacketStats(\n  packetCount: int,\n  byteCount: int,\n  durationSec: int,\n  durationNsec: int\n)\nclass FlowMatch {\n  var inPort: int\n  var dlSrc: MACAddress\n  var dlDst: MACAddress\n  var nwSrc: IPAddress\n  var nwDst: IPAddress\n  var nwProto: int\n  var tpSrc: int\n  var tpDst: int\n  constructor()\n  {\n    inPort := 0;\n    dlSrc := MacAddr([]);\n    dlDst := MacAddr([]);\n    nwSrc := IPAddr([]);\n    nwDst := IPAddr([]);\n    nwProto := 0;\n    tpSrc := 0;\n    tpDst := 0;\n  }\n  predicate Valid()\n  {\n    true\n  }\n}\nclass FlowMonitor {\n  var switches: map<int, PacketStats>\n  var paths: map<seq<int>, set<FlowMatch>>\n  var pathsByMatch: map<FlowMatch, seq<int>>\n  var prevStats: map<FlowMatch, map<int, PacketStats>>\n  \n  constructor()\n  {\n    switches := map[];\n    paths := map[];\n    pathsByMatch := map[];\n    prevStats := map[];\n  }\n  predicate Valid()\n  {\n    true\n  }\n  \n  method CalculateThroughput(stats: PacketStats, prevStats: PacketStats) returns (throughput: real)\n  {\n    var deltaBytes := stats.byteCount - prevStats.byteCount;\n    var deltaDurationSec := stats.durationSec - prevStats.durationSec;\n    var deltaDurationNsec := stats.durationNsec - prevStats.durationNsec;\n    \n    if deltaDurationSec > 0 {\n      var duration := deltaDurationSec as real + (deltaDurationNsec as real / 1000000000.0);\n      if duration > 0.0 {\n        throughput := deltaBytes as real / duration;\n      } else {\n        throughput := 0.0;\n      }\n    } else {\n      throughput := 0.0;\n    }\n  }\n  \n  method HandleFlowStats(dpid: int, m: FlowMatch, stats: PacketStats)\n  {\n    if m !in prevStats {\n      prevStats := prevStats[m := map[]];\n    }\n    \n    if dpid !in prevStats[m] {\n      \n      var initialStats := PacketStats(0, 0, 0, 0);\n      prevStats := prevStats[m := prevStats[m][dpid := initialStats]];\n    }\n    \n    var oldStats := prevStats[m][dpid];\n    if stats.durationSec >= oldStats.durationSec && stats.byteCount >= oldStats.byteCount {\n      var throughput := CalculateThroughput(stats, oldStats);\n      \n      prevStats := prevStats[m := prevStats[m][dpid := stats]];\n    }\n  }\n  \n  method AddFlow(m: FlowMatch, path: seq<int>)\n  {\n    if path !in paths {\n      paths := paths[path := {}];\n    }\n    paths := paths[path := paths[path] + {m}];\n    pathsByMatch := pathsByMatch[m := path];\n  }\n}", "output": "datatype IPAddress = IPAddr(octets: seq<int>)\ndatatype MACAddress = MacAddr(bytes: seq<int>) \ndatatype PacketStats = PacketStats(\n  packetCount: int,\n  byteCount: int,\n  durationSec: int,\n  durationNsec: int\n)\nclass FlowMatch {\n  var inPort: int\n  var dlSrc: MACAddress\n  var dlDst: MACAddress\n  var nwSrc: IPAddress\n  var nwDst: IPAddress\n  var nwProto: int\n  var tpSrc: int\n  var tpDst: int\n  constructor()\n    ensures Valid()\n  {\n    inPort := 0;\n    dlSrc := MacAddr([]);\n    dlDst := MacAddr([]);\n    nwSrc := IPAddr([]);\n    nwDst := IPAddr([]);\n    nwProto := 0;\n    tpSrc := 0;\n    tpDst := 0;\n  }\n  predicate Valid()\n  {\n    true\n  }\n}\nclass FlowMonitor {\n  var switches: map<int, PacketStats>\n  var paths: map<seq<int>, set<FlowMatch>>\n  var pathsByMatch: map<FlowMatch, seq<int>>\n  var prevStats: map<FlowMatch, map<int, PacketStats>>\n  \n  constructor()\n    ensures Valid()\n  {\n    switches := map[];\n    paths := map[];\n    pathsByMatch := map[];\n    prevStats := map[];\n  }\n  predicate Valid()\n  {\n    true\n  }\n  \n  method CalculateThroughput(stats: PacketStats, prevStats: PacketStats) returns (throughput: real)\n    requires stats.durationSec >= prevStats.durationSec\n    requires stats.byteCount >= prevStats.byteCount\n    ensures throughput >= 0.0\n  {\n    var deltaBytes := stats.byteCount - prevStats.byteCount;\n    var deltaDurationSec := stats.durationSec - prevStats.durationSec;\n    var deltaDurationNsec := stats.durationNsec - prevStats.durationNsec;\n    \n    if deltaDurationSec > 0 {\n      var duration := deltaDurationSec as real + (deltaDurationNsec as real / 1000000000.0);\n      if duration > 0.0 {\n        throughput := deltaBytes as real / duration;\n      } else {\n        throughput := 0.0;\n      }\n    } else {\n      throughput := 0.0;\n    }\n  }\n  \n  method HandleFlowStats(dpid: int, m: FlowMatch, stats: PacketStats)\n    requires Valid()\n    requires dpid >= 0\n    requires stats.durationSec >= 0\n    requires stats.byteCount >= 0\n    modifies this\n    ensures Valid()\n  {\n    if m !in prevStats {\n      prevStats := prevStats[m := map[]];\n    }\n    \n    if dpid !in prevStats[m] {\n      \n      var initialStats := PacketStats(0, 0, 0, 0);\n      prevStats := prevStats[m := prevStats[m][dpid := initialStats]];\n    }\n    \n    var oldStats := prevStats[m][dpid];\n    if stats.durationSec >= oldStats.durationSec && stats.byteCount >= oldStats.byteCount {\n      var throughput := CalculateThroughput(stats, oldStats);\n      \n      prevStats := prevStats[m := prevStats[m][dpid := stats]];\n    }\n  }\n  \n  method AddFlow(m: FlowMatch, path: seq<int>)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures m in pathsByMatch\n    ensures pathsByMatch[m] == path\n    ensures path in paths\n    ensures m in paths[path]\n  {\n    if path !in paths {\n      paths := paths[path := {}];\n    }\n    paths := paths[path := paths[path] + {m}];\n    pathsByMatch := pathsByMatch[m := path];\n  }\n}", "name": "py2dfy_472", "id": 472}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype TimeData = TimeData(time: real, textscore: real)\nclass HourlyScoreCalculator {\n    var hourScores: array<real>\n    var hourCounts: array<int>\n    \n    constructor()\n    {\n        var newHourScores := new real[24];\n        var newHourCounts := new int[24];\n        var i := 0;\n        while i < 24\n        {\n            newHourScores[i] := 0.0;\n            newHourCounts[i] := 0;\n            i := i + 1;\n        }\n        hourScores := newHourScores;\n        hourCounts := newHourCounts;\n    }\n    method ConvertTimestampToHour(timestamp: real) returns (hour: int)\n    {\n        var utcHour := ((timestamp / 3600.0).Floor as int) % 24;\n        hour := utcHour - 8;\n        if hour < 0 {\n            hour := hour + 24;\n        }\n        if hour >= 24 {\n            hour := 0;\n        }\n    }\n    method UpdateHourScore(hour: int, score: real)\n            (old(hourScores[hour]) * (old(hourCounts[hour]) as real) + score) / \n            ((old(hourCounts[hour]) + 1) as real), 2)\n            hourCounts[i] == old(hourCounts[i]) && hourScores[i] == old(hourScores[i])\n    {\n        var oldCount := hourCounts[hour];\n        var newTotal := hourScores[hour] * (oldCount as real) + score;\n        hourCounts[hour] := oldCount + 1;\n        hourScores[hour] := Round(newTotal / ((oldCount + 1) as real), 2);\n    }\n    function Round(value: real, places: int): real\n    {\n        var factor := Pow(10.0, places);\n        ((value * factor).Floor as real) / factor\n    }\n    function Pow(base: real, exp: int): real\n    {\n        if exp == 0 then 1.0\n        else base * Pow(base, exp-1)\n    }\n    method ProcessTimeData(data: TimeData)\n    {\n        var hour := ConvertTimestampToHour(data.time);\n        UpdateHourScore(hour, data.textscore);\n    }\n    method GetResults() returns (result: array<real>)\n    {\n        result := new real[24];\n        var i := 0;\n        while i < 24\n        {\n            result[i] := hourScores[i];\n            i := i + 1;\n        }\n    }\n}", "output": "datatype TimeData = TimeData(time: real, textscore: real)\nclass HourlyScoreCalculator {\n    var hourScores: array<real>\n    var hourCounts: array<int>\n    \n    constructor()\n        ensures hourScores.Length == 24\n        ensures hourCounts.Length == 24\n        ensures fresh(hourScores) && fresh(hourCounts)\n        ensures forall i :: 0 <= i < 24 ==> hourScores[i] == 0.0\n        ensures forall i :: 0 <= i < 24 ==> hourCounts[i] == 0\n    {\n        var newHourScores := new real[24];\n        var newHourCounts := new int[24];\n        var i := 0;\n        while i < 24\n            invariant 0 <= i <= 24\n            invariant forall k :: 0 <= k < i ==> newHourScores[k] == 0.0\n            invariant forall k :: 0 <= k < i ==> newHourCounts[k] == 0\n        {\n            newHourScores[i] := 0.0;\n            newHourCounts[i] := 0;\n            i := i + 1;\n        }\n        hourScores := newHourScores;\n        hourCounts := newHourCounts;\n    }\n    method ConvertTimestampToHour(timestamp: real) returns (hour: int)\n        ensures 0 <= hour < 24\n    {\n        var utcHour := ((timestamp / 3600.0).Floor as int) % 24;\n        hour := utcHour - 8;\n        if hour < 0 {\n            hour := hour + 24;\n        }\n        if hour >= 24 {\n            hour := 0;\n        }\n    }\n    method UpdateHourScore(hour: int, score: real)\n        requires 0 <= hour < 24\n        requires hourScores.Length == 24 && hourCounts.Length == 24\n        requires (hourCounts[hour] + 1) as real > 0.0\n        modifies hourScores, hourCounts\n        ensures hourCounts[hour] == old(hourCounts[hour]) + 1\n        ensures hourScores[hour] == Round(\n            (old(hourScores[hour]) * (old(hourCounts[hour]) as real) + score) / \n            ((old(hourCounts[hour]) + 1) as real), 2)\n        ensures forall i :: 0 <= i < 24 && i != hour ==> \n            hourCounts[i] == old(hourCounts[i]) && hourScores[i] == old(hourScores[i])\n    {\n        var oldCount := hourCounts[hour];\n        assert (oldCount + 1) as real > 0.0;\n        var newTotal := hourScores[hour] * (oldCount as real) + score;\n        hourCounts[hour] := oldCount + 1;\n        hourScores[hour] := Round(newTotal / ((oldCount + 1) as real), 2);\n    }\n    function Round(value: real, places: int): real\n        requires places >= 0\n    {\n        var factor := Pow(10.0, places);\n        assert factor > 0.0;\n        ((value * factor).Floor as real) / factor\n    }\n    function Pow(base: real, exp: int): real\n        requires exp >= 0\n        requires base > 0.0\n        ensures Pow(base, exp) > 0.0\n        decreases exp\n    {\n        if exp == 0 then 1.0\n        else base * Pow(base, exp-1)\n    }\n    method ProcessTimeData(data: TimeData)\n        requires hourScores.Length == 24 && hourCounts.Length == 24\n        requires forall i :: 0 <= i < 24 ==> hourCounts[i] >= 0\n        modifies hourScores, hourCounts\n        ensures forall i :: 0 <= i < 24 ==> hourCounts[i] >= old(hourCounts[i])\n    {\n        var hour := ConvertTimestampToHour(data.time);\n        assert 0 <= hour < 24;\n        assert hourCounts[hour] >= 0;\n        assert hourCounts[hour] + 1 > 0;\n        UpdateHourScore(hour, data.textscore);\n    }\n    method GetResults() returns (result: array<real>)\n        requires hourScores.Length == 24\n        ensures fresh(result)\n        ensures result.Length == 24\n        ensures forall i :: 0 <= i < 24 ==> result[i] == hourScores[i]\n    {\n        result := new real[24];\n        var i := 0;\n        while i < 24\n            invariant 0 <= i <= 24\n            invariant forall k :: 0 <= k < i ==> result[k] == hourScores[k]\n        {\n            result[i] := hourScores[i];\n            i := i + 1;\n        }\n    }\n}", "name": "py2dfy_460", "id": 460}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Sound {\n  var samples: array?<int>\n  var rate: real\n  predicate Valid()\n  {\n    samples != null && \n    rate > 0.0 &&\n    forall i :: 0 <= i < samples.Length ==> -32768 <= samples[i] <= 32767\n  }\n  constructor(size: nat, samplingRate: real)\n  {\n    rate := samplingRate;\n    var newSamples := new int[size];\n    var i := 0;\n    while i < size\n    {\n      newSamples[i] := 0;\n      i := i + 1;\n    }\n    samples := newSamples;\n  }\n  static function Clamp(value: int): int\n  {\n    if value < -32768 then\n      -32768\n    else if value > 32767 then\n      32767\n    else\n      value\n  }\n  method GetSample(index: int) returns (value: int)\n  {\n    return samples[index];\n  }\n  method SetSample(index: int, value: int)\n            samples[i] == old(samples[i])\n  {\n    samples[index] := Clamp(value);\n  }\n  method Length() returns (len: nat)\n  {\n    return samples.Length;\n  }\n  method Duration() returns (duration: real)\n  {\n    return samples.Length as real / rate;\n  }\n  method Copy() returns (newSound: Sound)\n            newSound.samples[i] == this.samples[i]\n  {\n    newSound := new Sound(samples.Length, rate);\n    var i := 0;\n    while i < samples.Length\n                newSound.samples[k] == this.samples[k]\n    {\n      newSound.samples[i] := samples[i];\n      i := i + 1;\n    }\n  }\n}", "output": "class Sound {\n  var samples: array?<int>\n  var rate: real\n  predicate Valid()\n    reads this, this.samples\n  {\n    samples != null && \n    rate > 0.0 &&\n    forall i :: 0 <= i < samples.Length ==> -32768 <= samples[i] <= 32767\n  }\n  constructor(size: nat, samplingRate: real)\n    requires samplingRate > 0.0\n    ensures Valid()\n    ensures fresh(samples)\n    ensures samples.Length == size\n    ensures rate == samplingRate\n    ensures forall i :: 0 <= i < samples.Length ==> samples[i] == 0\n  {\n    rate := samplingRate;\n    var newSamples := new int[size];\n    var i := 0;\n    while i < size\n      invariant 0 <= i <= size\n      invariant forall k :: 0 <= k < i ==> newSamples[k] == 0\n    {\n      newSamples[i] := 0;\n      i := i + 1;\n    }\n    samples := newSamples;\n  }\n  static function Clamp(value: int): int\n    ensures -32768 <= Clamp(value) <= 32767\n    ensures value <= -32768 ==> Clamp(value) == -32768\n    ensures -32768 <= value <= 32767 ==> Clamp(value) == value\n    ensures value >= 32767 ==> Clamp(value) == 32767\n  {\n    if value < -32768 then\n      -32768\n    else if value > 32767 then\n      32767\n    else\n      value\n  }\n  method GetSample(index: int) returns (value: int)\n    requires Valid()\n    requires 0 <= index < samples.Length\n    ensures -32768 <= value <= 32767\n  {\n    return samples[index];\n  }\n  method SetSample(index: int, value: int)\n    requires Valid()\n    requires 0 <= index < samples.Length\n    modifies this.samples\n    ensures Valid()\n    ensures samples[index] == Clamp(value)\n    ensures forall i :: 0 <= i < samples.Length && i != index ==> \n            samples[i] == old(samples[i])\n  {\n    samples[index] := Clamp(value);\n  }\n  method Length() returns (len: nat)\n    requires Valid()\n    ensures len == samples.Length\n  {\n    return samples.Length;\n  }\n  method Duration() returns (duration: real)\n    requires Valid()\n    ensures duration == samples.Length as real / rate\n  {\n    return samples.Length as real / rate;\n  }\n  method Copy() returns (newSound: Sound)\n    requires Valid()\n    ensures fresh(newSound)\n    ensures newSound.Valid()\n    ensures newSound.samples.Length == this.samples.Length\n    ensures newSound.rate == this.rate\n    ensures forall i :: 0 <= i < samples.Length ==> \n            newSound.samples[i] == this.samples[i]\n  {\n    newSound := new Sound(samples.Length, rate);\n    var i := 0;\n    while i < samples.Length\n      invariant 0 <= i <= samples.Length\n      invariant newSound.Valid()\n      invariant newSound.samples.Length == this.samples.Length\n      invariant newSound.rate == this.rate\n      invariant forall k :: 0 <= k < i ==> \n                newSound.samples[k] == this.samples[k]\n      modifies newSound.samples\n    {\n      newSound.samples[i] := samples[i];\n      i := i + 1;\n    }\n  }\n}", "name": "py2dfy_466", "id": 466}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type UUID = seq<int>\nclass ItemSlot {\n  var order: int\n  var id: UUID\n  \n  constructor(ord: int, identifier: UUID)\n  {\n    order := ord;\n    id := identifier;\n  }\n}\nclass ItemTypeTranslation {\n  var itemType: ItemType?\n  constructor()\n  {\n    itemType := null;\n  }\n}\nclass Item {\n  var itemType: ItemType?\n  constructor()\n  {\n    itemType := null;\n  }\n}\nclass ItemType {\n  var id: UUID\n  var eligibleItemSlots: seq<ItemSlot>\n  var items: seq<Item>\n  var translations: seq<ItemTypeTranslation>\n  \n  constructor()\n  {\n    eligibleItemSlots := [];\n    items := [];\n    translations := [];\n  }\n  static method GetSlotsByName(types: seq<ItemType>, name: string) returns (slots: seq<ItemSlot>)\n  {\n    slots := types[0].eligibleItemSlots;\n  }\n  method AddEligibleSlot(slot: ItemSlot?)\n  {\n    eligibleItemSlots := eligibleItemSlots + [slot];\n  }\n  predicate AreSlotsOrdered()\n  {\n    forall i, j :: \n      0 <= i < j < |eligibleItemSlots| ==>\n      eligibleItemSlots[i].order <= eligibleItemSlots[j].order\n  }\n}", "output": "type UUID = seq<int>\nclass ItemSlot {\n  var order: int\n  var id: UUID\n  \n  constructor(ord: int, identifier: UUID)\n    requires ord >= 0\n    requires |identifier| > 0\n    ensures order == ord\n    ensures id == identifier\n  {\n    order := ord;\n    id := identifier;\n  }\n}\nclass ItemTypeTranslation {\n  var itemType: ItemType?\n  constructor()\n    ensures itemType == null\n  {\n    itemType := null;\n  }\n}\nclass Item {\n  var itemType: ItemType?\n  constructor()\n    ensures itemType == null\n  {\n    itemType := null;\n  }\n}\nclass ItemType {\n  var id: UUID\n  var eligibleItemSlots: seq<ItemSlot>\n  var items: seq<Item>\n  var translations: seq<ItemTypeTranslation>\n  \n  constructor()\n    ensures fresh(this)\n    ensures |eligibleItemSlots| == 0\n    ensures |items| == 0\n    ensures |translations| == 0\n  {\n    eligibleItemSlots := [];\n    items := [];\n    translations := [];\n  }\n  static method GetSlotsByName(types: seq<ItemType>, name: string) returns (slots: seq<ItemSlot>)\n    requires |types| > 0\n    requires |types[0].eligibleItemSlots| > 0\n    ensures |slots| > 0\n  {\n    slots := types[0].eligibleItemSlots;\n  }\n  method AddEligibleSlot(slot: ItemSlot?)\n    requires slot != null\n    modifies this\n    ensures eligibleItemSlots == old(eligibleItemSlots) + [slot]\n    ensures |eligibleItemSlots| == |old(eligibleItemSlots)| + 1\n  {\n    eligibleItemSlots := eligibleItemSlots + [slot];\n  }\n  predicate AreSlotsOrdered()\n    reads this, eligibleItemSlots\n  {\n    forall i, j :: \n      0 <= i < j < |eligibleItemSlots| ==>\n      eligibleItemSlots[i].order <= eligibleItemSlots[j].order\n  }\n}", "name": "py2dfy_474", "id": 474}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintRow(i: int)\n{\n    \n    print i, \"\\t\", i*i, \"\\t\", i*i*i, \"\\n\";\n}\nmethod PrintNumberTable(n: int)\n{\n    \n    print \"n\\tn^2\\tn^3\\n\";\n    \n    \n    var i: int := 1;\n    \n    while i <= n\n    {\n        PrintRow(i);\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n    var n := 5; \n    PrintNumberTable(n);\n}", "output": "method PrintRow(i: int)\n{\n    \n    print i, \"\\t\", i*i, \"\\t\", i*i*i, \"\\n\";\n}\nmethod PrintNumberTable(n: int)\n    requires n >= 0  \n    ensures true     \n{\n    \n    print \"n\\tn^2\\tn^3\\n\";\n    \n    \n    var i: int := 1;\n    \n    while i <= n\n        invariant 1 <= i <= n + 1  \n        invariant i >= 1           \n        decreases n - i + 1        \n    {\n        PrintRow(i);\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n    var n := 5; \n    PrintNumberTable(n);\n}", "name": "py2dfy_476", "id": 476}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module FileSystem {\n  \n  type File\n  \n  predicate IsValidFilePath(path: string)\n  {\n    |path| > 0\n  }\n  \n  predicate IsValidSTLFile(f: File)\n  \n  method {:axiom} CheckSTLFile(path: string) returns (isValid: bool)\n}\nmodule GUI {\n  \n  type GUIState\n  \n  predicate IsValidGUIState(state: GUIState)\n  \n  method {:axiom} RunGUI() returns (state: GUIState)\n}\nmethod Main() \n{\n  var path := \"file.stl\";\n  \n  \n  \n  var isValid := FileSystem.CheckSTLFile(path);\n  if !isValid {\n    print \"Invalid STL file\\n\";\n    return;\n  }\n  \n  var guiState := GUI.RunGUI();\n}", "output": "module FileSystem {\n  \n  type File\n  \n  predicate IsValidFilePath(path: string)\n    ensures IsValidFilePath(path) ==> |path| > 0\n  {\n    |path| > 0\n  }\n  \n  predicate IsValidSTLFile(f: File)\n  \n  method {:axiom} CheckSTLFile(path: string) returns (isValid: bool)\n    requires IsValidFilePath(path)\n    ensures isValid ==> exists f :: IsValidSTLFile(f)\n    ensures !isValid ==> forall f :: !IsValidSTLFile(f)\n}\nmodule GUI {\n  \n  type GUIState\n  \n  predicate IsValidGUIState(state: GUIState)\n  \n  method {:axiom} RunGUI() returns (state: GUIState)\n    ensures IsValidGUIState(state)\n}\nmethod Main() \n  decreases *  \n{\n  var path := \"file.stl\";\n  \n  \n  assert |path| > 0;\n  assert FileSystem.IsValidFilePath(path);\n  \n  var isValid := FileSystem.CheckSTLFile(path);\n  if !isValid {\n    print \"Invalid STL file\\n\";\n    return;\n  }\n  \n  var guiState := GUI.RunGUI();\n  assert GUI.IsValidGUIState(guiState);\n}", "name": "py2dfy_471", "id": 471}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class CellsExtractor {\n  var fileName: string\n  constructor(fileName: string)\n  {\n    this.fileName := fileName;\n  }\n  method GetPicture(worksheetName: string, pictureIndex: int, imageFormat: string) returns (result: string)\n  {\n    var uri := BuildUri(\"pictures\", worksheetName, pictureIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetOleObject(worksheetName: string, oleObjectIndex: int, imageFormat: string) returns (result: string)\n  {\n    var uri := BuildUri(\"oleobjects\", worksheetName, oleObjectIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetChart(worksheetName: string, chartIndex: int, imageFormat: string) returns (result: string)\n  {\n    var uri := BuildUri(\"charts\", worksheetName, chartIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetAutoShape(worksheetName: string, autoShapeIndex: int, imageFormat: string) returns (result: string)\n  {\n    var uri := BuildUri(\"autoshapes\", worksheetName, autoShapeIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method BuildUri(objectType: string, worksheetName: string, index: int, imageFormat: string) returns (uri: string)\n  {\n    \n    uri := \"some_uri_string\";\n  }\n  method ProcessRequest(uri: string) returns (result: string)\n  {\n    \n    result := \"processed_result\";\n  }\n}", "output": "class CellsExtractor {\n  var fileName: string\n  constructor(fileName: string)\n    ensures this.fileName == fileName\n  {\n    this.fileName := fileName;\n  }\n  method GetPicture(worksheetName: string, pictureIndex: int, imageFormat: string) returns (result: string)\n    requires fileName != \"\"\n    requires pictureIndex >= 0\n    ensures result != \"\"\n  {\n    var uri := BuildUri(\"pictures\", worksheetName, pictureIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetOleObject(worksheetName: string, oleObjectIndex: int, imageFormat: string) returns (result: string)\n    requires fileName != \"\"\n    requires oleObjectIndex >= 0\n    ensures result != \"\"\n  {\n    var uri := BuildUri(\"oleobjects\", worksheetName, oleObjectIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetChart(worksheetName: string, chartIndex: int, imageFormat: string) returns (result: string)\n    requires fileName != \"\"\n    requires chartIndex >= 0\n    ensures result != \"\"\n  {\n    var uri := BuildUri(\"charts\", worksheetName, chartIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method GetAutoShape(worksheetName: string, autoShapeIndex: int, imageFormat: string) returns (result: string)\n    requires fileName != \"\"\n    requires autoShapeIndex >= 0\n    ensures result != \"\"\n  {\n    var uri := BuildUri(\"autoshapes\", worksheetName, autoShapeIndex, imageFormat);\n    result := ProcessRequest(uri);\n  }\n  method BuildUri(objectType: string, worksheetName: string, index: int, imageFormat: string) returns (uri: string)\n    requires index >= 0\n    ensures uri != \"\"\n  {\n    \n    uri := \"some_uri_string\";\n  }\n  method ProcessRequest(uri: string) returns (result: string)\n    requires uri != \"\"\n    ensures result != \"\"\n  {\n    \n    result := \"processed_result\";\n  }\n}", "name": "py2dfy_487", "id": 487}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PrintLine(spaces: nat, stars: nat)\n  \n{\n  \n  var i := 0;\n  while i < spaces\n  {\n    print \" \";\n    i := i + 1;\n  }\n  \n  \n  i := 0;\n  while i < stars\n  {\n    print \"*\";\n    i := i + 1;\n  }\n  \n  print \"\\n\";  \n}\nmethod PrintStarPattern(n: nat)\n{\n  var line := 1;\n  while line <= n\n  {\n    PrintLine(n - line, line);\n    line := line + 1;\n  }\n}\nmethod Main() {\n  print \"Enter n: \";\n  var n := 5;  \n  PrintStarPattern(n);\n}", "output": "method PrintLine(spaces: nat, stars: nat)\n  \n{\n  \n  var i := 0;\n  while i < spaces\n    invariant 0 <= i <= spaces  \n  {\n    print \" \";\n    i := i + 1;\n  }\n  \n  \n  i := 0;\n  while i < stars\n    invariant 0 <= i <= stars  \n  {\n    print \"*\";\n    i := i + 1;\n  }\n  \n  print \"\\n\";  \n}\nmethod PrintStarPattern(n: nat)\n  requires n > 0  \n  ensures true    \n{\n  var line := 1;\n  while line <= n\n    invariant 1 <= line <= n + 1  \n    invariant line - 1 <= n       \n  {\n    PrintLine(n - line, line);\n    line := line + 1;\n  }\n}\nmethod Main() {\n  print \"Enter n: \";\n  var n := 5;  \n  PrintStarPattern(n);\n}", "name": "py2dfy_492", "id": 492}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module SurveyConfig {\n  class Configuration {\n    \n    const CSV_FILENAME: string\n    const TIDY_DATA_EXPORT_FILENAME: string\n    \n    \n    const NOT_PYTHON_STR: string\n    const DROP_NA: int\n    const REPLACE_NA: int\n    const CUSTOM_PROCESSING_FUNC: int\n    const BOTH_PYTHON_AND_NON_PYTHON_USERS: int\n    \n    constructor()\n    {\n      CSV_FILENAME := \"raw_survey_data.csv\";\n      TIDY_DATA_EXPORT_FILENAME := \"2018 Tidy Data.xlsx\";\n      NOT_PYTHON_STR := \"No, I don't use Python for my current projects\";\n      DROP_NA := 1;\n      REPLACE_NA := 2;\n      CUSTOM_PROCESSING_FUNC := 3;\n      BOTH_PYTHON_AND_NON_PYTHON_USERS := 4;\n    }\n    \n    method GetEnvOrDefault(envVar: string, defaultValue: string) returns (result: string)\n    {\n      return defaultValue;\n    }\n  }\n}", "output": "module SurveyConfig {\n  class Configuration {\n    \n    const CSV_FILENAME: string\n    const TIDY_DATA_EXPORT_FILENAME: string\n    \n    \n    const NOT_PYTHON_STR: string\n    const DROP_NA: int\n    const REPLACE_NA: int\n    const CUSTOM_PROCESSING_FUNC: int\n    const BOTH_PYTHON_AND_NON_PYTHON_USERS: int\n    \n    constructor()\n      ensures CSV_FILENAME != \"\"\n      ensures TIDY_DATA_EXPORT_FILENAME != \"\"\n      ensures NOT_PYTHON_STR != \"\"\n      ensures DROP_NA == 1\n      ensures REPLACE_NA == 2\n      ensures CUSTOM_PROCESSING_FUNC == 3\n      ensures BOTH_PYTHON_AND_NON_PYTHON_USERS == 4\n    {\n      CSV_FILENAME := \"raw_survey_data.csv\";\n      TIDY_DATA_EXPORT_FILENAME := \"2018 Tidy Data.xlsx\";\n      NOT_PYTHON_STR := \"No, I don't use Python for my current projects\";\n      DROP_NA := 1;\n      REPLACE_NA := 2;\n      CUSTOM_PROCESSING_FUNC := 3;\n      BOTH_PYTHON_AND_NON_PYTHON_USERS := 4;\n    }\n    \n    method GetEnvOrDefault(envVar: string, defaultValue: string) returns (result: string)\n      requires envVar != \"\"\n      requires defaultValue != \"\"\n      ensures result != \"\"\n      ensures result == defaultValue  \n    {\n      return defaultValue;\n    }\n  }\n}", "name": "py2dfy_500", "id": 500}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class ObjectManager {\n  var deleteObject: bool\n  var toggleStatus: bool\n  \n  constructor()\n  {\n    deleteObject := true;\n    toggleStatus := true;\n  }\n  \n  method GetDeleteStatus() returns (status: bool)\n  {\n    return deleteObject;\n  }\n  \n  method GetToggleStatus() returns (status: bool)\n  {\n    return toggleStatus;\n  }\n  \n  method SetDeleteStatus(newStatus: bool)\n  {\n    deleteObject := newStatus;\n  }\n  \n  method SetToggleStatus(newStatus: bool)\n  {\n    toggleStatus := newStatus;\n  }\n  \n  method ToggleBoth()\n  {\n    deleteObject := !deleteObject;\n    toggleStatus := !toggleStatus;\n  }\n}", "output": "class ObjectManager {\n  var deleteObject: bool\n  var toggleStatus: bool\n  \n  constructor()\n    ensures deleteObject == true && toggleStatus == true  \n  {\n    deleteObject := true;\n    toggleStatus := true;\n  }\n  \n  method GetDeleteStatus() returns (status: bool)\n    ensures status == deleteObject  \n  {\n    return deleteObject;\n  }\n  \n  method GetToggleStatus() returns (status: bool)\n    ensures status == toggleStatus  \n  {\n    return toggleStatus;\n  }\n  \n  method SetDeleteStatus(newStatus: bool)\n    ensures deleteObject == newStatus  \n    modifies this\n  {\n    deleteObject := newStatus;\n  }\n  \n  method SetToggleStatus(newStatus: bool)\n    ensures toggleStatus == newStatus  \n    modifies this\n  {\n    toggleStatus := newStatus;\n  }\n  \n  method ToggleBoth()\n    ensures deleteObject == !old(deleteObject)  \n    ensures toggleStatus == !old(toggleStatus)  \n    modifies this\n  {\n    deleteObject := !deleteObject;\n    toggleStatus := !toggleStatus;\n  }\n}", "name": "py2dfy_486", "id": 486}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class SystemIPMapper {\n  \n  method GetSystemToIPMap(systemNames: seq<string>, systemIPs: seq<string>) \n    returns (systemIPMap: seq<(string, string)>)\n              systemIPMap[i] == (systemNames[i], systemIPs[i])  \n  {\n    systemIPMap := [];\n    \n    \n    if |systemNames| == 0 || |systemIPs| == 0 {\n      return systemIPMap;\n    }\n    \n    \n    var i := 0;\n    while i < |systemNames|\n                systemIPMap[j] == (systemNames[j], systemIPs[j])\n    {\n      systemIPMap := systemIPMap + [(systemNames[i], systemIPs[i])];\n      i := i + 1;\n    }\n    \n    return systemIPMap;\n  }\n  \n  \n  method Main() {\n    var systemNames := [\"host1\", \"host2\", \"host3\"];\n    var systemIPs := [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"];\n    \n    var mapping := GetSystemToIPMap(systemNames, systemIPs);\n    \n    \n    print \"System to IP Mapping:\\n\";\n    var j := 0;\n    while j < |mapping|\n    {\n      print mapping[j], \"\\n\";\n      j := j + 1;\n    }\n  }\n}", "output": "class SystemIPMapper {\n  \n  method GetSystemToIPMap(systemNames: seq<string>, systemIPs: seq<string>) \n    returns (systemIPMap: seq<(string, string)>)\n    requires |systemNames| == |systemIPs|  \n    ensures |systemIPMap| == |systemNames|  \n    ensures forall i :: 0 <= i < |systemIPMap| ==> \n              systemIPMap[i] == (systemNames[i], systemIPs[i])  \n  {\n    systemIPMap := [];\n    \n    \n    if |systemNames| == 0 || |systemIPs| == 0 {\n      return systemIPMap;\n    }\n    \n    \n    var i := 0;\n    while i < |systemNames|\n      invariant 0 <= i <= |systemNames|\n      invariant |systemIPMap| == i\n      invariant forall j :: 0 <= j < i ==> \n                systemIPMap[j] == (systemNames[j], systemIPs[j])\n    {\n      systemIPMap := systemIPMap + [(systemNames[i], systemIPs[i])];\n      i := i + 1;\n    }\n    \n    return systemIPMap;\n  }\n  \n  \n  method Main() {\n    var systemNames := [\"host1\", \"host2\", \"host3\"];\n    var systemIPs := [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"];\n    \n    var mapping := GetSystemToIPMap(systemNames, systemIPs);\n    \n    \n    print \"System to IP Mapping:\\n\";\n    var j := 0;\n    while j < |mapping|\n      invariant 0 <= j <= |mapping|\n    {\n      print mapping[j], \"\\n\";\n      j := j + 1;\n    }\n  }\n}", "name": "py2dfy_479", "id": 479}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DataContainer {\n    var data: array2?<real>\n    var frequency: real  \n    var channels: array?<string>\n    \n    ghost predicate Valid()\n    {\n        data != null &&\n        channels != null &&\n        data.Length1 > 0 &&\n        data.Length0 == channels.Length &&\n        frequency > 0.0\n    }\n    \n    constructor FromArray(inputData: array2?<real>, freq: real, channelNames: array?<string>)\n    {\n        var newData := new real[inputData.Length0, inputData.Length1];\n        var newChannels := new string[channelNames.Length];\n        \n        var i := 0;\n        var j := 0;\n        while i < inputData.Length0\n        {\n            j := 0;\n            while j < inputData.Length1\n            {\n                newData[i,j] := inputData[i,j];\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n        \n        i := 0;\n        while i < channelNames.Length\n        {\n            newChannels[i] := channelNames[i];\n            i := i + 1;\n        }\n        \n        data := newData;\n        channels := newChannels;\n        frequency := freq;\n    }\n    \n    method GetDuration() returns (duration: real)\n    {\n        duration := data.Length1 as real / frequency;\n    }\n    \n    method GetTimeSlice(start: real, end: real) returns (slice: DataContainer?)\n    {\n        var startSample := (start * frequency).Floor as int;\n        var endSample := (end * frequency).Floor as int;\n        \n        if startSample >= data.Length1 || endSample > data.Length1 || endSample <= startSample {\n            slice := null;\n            return;\n        }\n        \n        var newData := new real[data.Length0, endSample - startSample];\n        var newChannels := new string[channels.Length];\n        \n        var i := 0;\n        while i < data.Length0\n        {\n            var j := 0;\n            while j < endSample - startSample\n            {\n                newData[i,j] := data[i, startSample + j];\n                j := j + 1;\n            }\n            newChannels[i] := channels[i];\n            i := i + 1;\n        }\n        \n        slice := new DataContainer.FromArray(newData, frequency, newChannels);\n    }\n}", "output": "class DataContainer {\n    var data: array2?<real>\n    var frequency: real  \n    var channels: array?<string>\n    \n    ghost predicate Valid()\n    reads this\n    {\n        data != null &&\n        channels != null &&\n        data.Length1 > 0 &&\n        data.Length0 == channels.Length &&\n        frequency > 0.0\n    }\n    \n    constructor FromArray(inputData: array2?<real>, freq: real, channelNames: array?<string>)\n    requires inputData != null && channelNames != null\n    requires inputData.Length0 == channelNames.Length\n    requires inputData.Length1 > 0\n    requires freq > 0.0\n    ensures Valid()\n    ensures fresh(data) && fresh(channels)\n    ensures data.Length0 == inputData.Length0 && data.Length1 == inputData.Length1\n    ensures frequency == freq\n    {\n        var newData := new real[inputData.Length0, inputData.Length1];\n        var newChannels := new string[channelNames.Length];\n        \n        var i := 0;\n        var j := 0;\n        while i < inputData.Length0\n        invariant 0 <= i <= inputData.Length0\n        {\n            j := 0;\n            while j < inputData.Length1\n            invariant 0 <= j <= inputData.Length1\n            {\n                newData[i,j] := inputData[i,j];\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n        \n        i := 0;\n        while i < channelNames.Length\n        invariant 0 <= i <= channelNames.Length\n        {\n            newChannels[i] := channelNames[i];\n            i := i + 1;\n        }\n        \n        data := newData;\n        channels := newChannels;\n        frequency := freq;\n    }\n    \n    method GetDuration() returns (duration: real)\n    requires Valid()\n    ensures duration == data.Length1 as real / frequency\n    {\n        duration := data.Length1 as real / frequency;\n    }\n    \n    method GetTimeSlice(start: real, end: real) returns (slice: DataContainer?)\n    requires Valid()\n    requires 0.0 <= start < end\n    requires end <= (data.Length1 as real / frequency)\n    ensures slice != null ==> slice.Valid()\n    {\n        var startSample := (start * frequency).Floor as int;\n        var endSample := (end * frequency).Floor as int;\n        \n        if startSample >= data.Length1 || endSample > data.Length1 || endSample <= startSample {\n            slice := null;\n            return;\n        }\n        \n        var newData := new real[data.Length0, endSample - startSample];\n        var newChannels := new string[channels.Length];\n        \n        var i := 0;\n        while i < data.Length0\n        invariant 0 <= i <= data.Length0\n        {\n            var j := 0;\n            while j < endSample - startSample\n            invariant 0 <= j <= endSample - startSample\n            {\n                newData[i,j] := data[i, startSample + j];\n                j := j + 1;\n            }\n            newChannels[i] := channels[i];\n            i := i + 1;\n        }\n        \n        assert endSample > startSample;  \n        slice := new DataContainer.FromArray(newData, frequency, newChannels);\n    }\n}", "name": "py2dfy_495", "id": 495}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype S = S(G: array<int>)\ndatatype T = T(F: array<S>, ghost Repr: set<object>)\nghost predicate Valid(t: T)\n{\n  var short := t.F;\n  t.Repr == (set i | 0 <= i < short.Length :: short[i].G) + {short}\n}\nmethod Main() {\n}", "output": "datatype S = S(G: array<int>)\ndatatype T = T(F: array<S>, ghost Repr: set<object>)\nghost predicate Valid(t: T)\n  reads t.F\n  reads (set i | 0 <= i < t.F.Length :: t.F[i].G)\n{\n  var short := t.F;\n  t.Repr == (set i | 0 <= i < short.Length :: short[i].G) + {short}\n}\nmethod Main() {\n}", "name": "py2dfy_503", "id": 503}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype DateTime = DateTime(hour: int, day: int, month: int, year: int)\ndatatype DayPeriod = DayPeriod(earlyMorning: bool, morning: bool, afternoon: bool, evening: bool, night: bool, lateNight: bool)\nmethod DayTimePeriods(hour: int) returns (periods: DayPeriod)\n{\n  var earlyMorning := 4 <= hour <= 7;\n  var morning := 8 <= hour <= 11;\n  var afternoon := 12 <= hour <= 15;\n  var evening := 16 <= hour <= 19;\n  var night := 20 <= hour <= 23;\n  var lateNight := 0 <= hour <= 3;\n  \n  periods := DayPeriod(earlyMorning, morning, afternoon, evening, night, lateNight);\n}\nmethod IsAwakeHour(hour: int) returns (isAwake: bool)\n{\n  isAwake := hour == 0 || (8 <= hour <= 23);\n}\nmethod Discretize(value: real, numBins: int) returns (binIndex: int)\n{\n  \n  var binSize := 360.0 / numBins as real;\n  \n  \n  var normalizedValue := value + 180.0;\n  \n  \n  binIndex := (normalizedValue / binSize).Floor;\n  \n  \n  if binIndex >= numBins {\n    binIndex := numBins - 1;\n  }\n  if binIndex < 0 {\n    binIndex := 0;\n  }\n}\nmethod IsIntersection(address: string) returns (isIntersection: bool)\n{\n  isIntersection := false;\n  var i := 0;\n  \n  \n  while i < |address|\n  {\n    if address[i] == '/' {\n      isIntersection := true;\n      break;\n    }\n    i := i + 1;\n  }\n}", "output": "datatype DateTime = DateTime(hour: int, day: int, month: int, year: int)\ndatatype DayPeriod = DayPeriod(earlyMorning: bool, morning: bool, afternoon: bool, evening: bool, night: bool, lateNight: bool)\nmethod DayTimePeriods(hour: int) returns (periods: DayPeriod)\n  requires 0 <= hour <= 23  \n  ensures periods.earlyMorning <==> (4 <= hour <= 7)\n  ensures periods.morning <==> (8 <= hour <= 11)\n  ensures periods.afternoon <==> (12 <= hour <= 15)\n  ensures periods.evening <==> (16 <= hour <= 19)\n  ensures periods.night <==> (20 <= hour <= 23)\n  ensures periods.lateNight <==> (0 <= hour <= 3)\n{\n  var earlyMorning := 4 <= hour <= 7;\n  var morning := 8 <= hour <= 11;\n  var afternoon := 12 <= hour <= 15;\n  var evening := 16 <= hour <= 19;\n  var night := 20 <= hour <= 23;\n  var lateNight := 0 <= hour <= 3;\n  \n  periods := DayPeriod(earlyMorning, morning, afternoon, evening, night, lateNight);\n}\nmethod IsAwakeHour(hour: int) returns (isAwake: bool)\n  requires 0 <= hour <= 23\n  ensures isAwake <==> (hour == 0 || (8 <= hour <= 23))\n{\n  isAwake := hour == 0 || (8 <= hour <= 23);\n}\nmethod Discretize(value: real, numBins: int) returns (binIndex: int)\n  requires numBins > 0\n  requires -180.0 <= value <= 180.0  \n  ensures 0 <= binIndex < numBins\n{\n  \n  var binSize := 360.0 / numBins as real;\n  \n  \n  var normalizedValue := value + 180.0;\n  \n  \n  binIndex := (normalizedValue / binSize).Floor;\n  \n  \n  if binIndex >= numBins {\n    binIndex := numBins - 1;\n  }\n  if binIndex < 0 {\n    binIndex := 0;\n  }\n}\nmethod IsIntersection(address: string) returns (isIntersection: bool)\n  ensures isIntersection <==> exists i :: 0 <= i < |address| && address[i] == '/'\n{\n  isIntersection := false;\n  var i := 0;\n  \n  \n  while i < |address|\n    invariant 0 <= i <= |address|\n    invariant isIntersection <==> exists j :: 0 <= j < i && address[j] == '/'\n  {\n    if address[i] == '/' {\n      isIntersection := true;\n      break;\n    }\n    i := i + 1;\n  }\n}", "name": "py2dfy_480", "id": 480}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class ConnectionCredentials {\n  var host: string\n  var database: string  \n  var user: string\n  var password: string\n  \n  constructor(h: string, db: string, u: string, pw: string)\n  {\n    host := h;\n    database := db;\n    user := u;\n    password := pw;\n  }\n}\ndatatype ConnectionResult = \n  | Success(connection: DatabaseConnection?) \n  | Error(message: string)\nclass DatabaseConnection {\n  var isConnected: bool\n  var credentials: ConnectionCredentials?\n  \n  constructor(creds: ConnectionCredentials?)\n  {\n    isConnected := false;\n    credentials := creds;\n  }\n}\nmethod CreateConnection(creds: ConnectionCredentials?) returns (result: ConnectionResult)\n    match result {\n      case Success(conn) => \n        conn != null && \n        conn.credentials == creds\n      case Error(_) => true  \n    }\n{\n  var connection := new DatabaseConnection(creds);\n  \n  \n  if ValidateCredentials(creds) {\n    connection.isConnected := true;\n    return Success(connection);\n  } else {\n    return Error(\"Failed to connect to database\");\n  }\n}\npredicate ValidateCredentials(creds: ConnectionCredentials?)\n{\n  && creds.host != \"\"\n  && creds.database != \"\"\n  && creds.user != \"\"\n  && creds.password != \"\"\n}\nmethod ExecuteQuery(conn: DatabaseConnection?, query: string) returns (success: bool)\n{\n  \n  success := true;  \n}", "output": "class ConnectionCredentials {\n  var host: string\n  var database: string  \n  var user: string\n  var password: string\n  \n  constructor(h: string, db: string, u: string, pw: string)\n    requires h != \"\" && db != \"\" && u != \"\" && pw != \"\"\n    ensures host == h && database == db && user == u && password == pw\n  {\n    host := h;\n    database := db;\n    user := u;\n    password := pw;\n  }\n}\ndatatype ConnectionResult = \n  | Success(connection: DatabaseConnection?) \n  | Error(message: string)\nclass DatabaseConnection {\n  var isConnected: bool\n  var credentials: ConnectionCredentials?\n  \n  constructor(creds: ConnectionCredentials?)\n    requires creds != null\n    ensures isConnected == false\n    ensures credentials == creds\n  {\n    isConnected := false;\n    credentials := creds;\n  }\n}\nmethod CreateConnection(creds: ConnectionCredentials?) returns (result: ConnectionResult)\n  requires creds != null\n  ensures \n    match result {\n      case Success(conn) => \n        conn != null && \n        conn.credentials == creds\n      case Error(_) => true  \n    }\n{\n  var connection := new DatabaseConnection(creds);\n  \n  \n  if ValidateCredentials(creds) {\n    connection.isConnected := true;\n    return Success(connection);\n  } else {\n    return Error(\"Failed to connect to database\");\n  }\n}\npredicate ValidateCredentials(creds: ConnectionCredentials?)\n  requires creds != null\n  reads creds\n{\n  && creds.host != \"\"\n  && creds.database != \"\"\n  && creds.user != \"\"\n  && creds.password != \"\"\n}\nmethod ExecuteQuery(conn: DatabaseConnection?, query: string) returns (success: bool)\n  requires conn != null && query != \"\"\n  requires conn.isConnected\n  ensures success ==> conn.isConnected  \n{\n  \n  success := true;  \n}", "name": "py2dfy_498", "id": 498}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class File {\n  var content: seq<int>  \n  constructor()\n  {\n    content := [];\n  }\n}\nclass Task {\n  var id: int\n  var contentPath: string\n  var stylePath: string\n  var outputPath: string\n  var userId: int\n  var submissionTime: int  \n  \n  constructor(id: int, content: string, style: string, user: int)\n  {\n    this.id := id;\n    this.contentPath := content;\n    this.stylePath := style;\n    this.outputPath := \"\";\n    this.userId := user;\n    this.submissionTime := 0;  \n  }\n}\nmethod HandleUploadFile(\n  request: map<string, int>,  \n  contentFile: File?,\n  styleFile: File?\n) returns (task: Task)\n{\n  \n  var contentPath := GenerateUniquePath(\"content\");\n  var stylePath := GenerateUniquePath(\"style\");\n  \n  \n  SaveFile(contentFile, contentPath);\n  SaveFile(styleFile, stylePath);\n  \n  \n  var taskId := GetNextTaskId();\n  task := new Task(taskId, contentPath, stylePath, request[\"user_id\"]);\n  \n  \n  var args := BuildDispatchArgs(task);\n  DispatchTask(args);\n}\nmethod HandleOutputFile(args: map<string, int>, outputFile: File?, task: Task)\n{\n  \n  var outputPath := GenerateUniquePath(\"output\");\n  \n  \n  SaveFile(outputFile, outputPath);\n  \n  \n  task.outputPath := outputPath;\n}\nmethod GenerateUniquePath(prefix: string) returns (path: string)\n{\n  \n  path := prefix + \"_\" + \"unique_id\";  \n}\nmethod SaveFile(file: File?, path: string)\n{\n  \n}\nmethod GetNextTaskId() returns (id: int)\n{\n  \n  id := 0;  \n}\nmethod BuildDispatchArgs(task: Task?) returns (args: map<string, int>)\n{\n  args := map[\"task_id\" := task.id];\n}\nmethod DispatchTask(args: map<string, int>)\n{\n  \n}\nmethod GetTask(taskId: int) returns (task: Task?)\n{\n  \n  task := null;  \n}", "output": "class File {\n  var content: seq<int>  \n  constructor()\n    ensures content == []\n  {\n    content := [];\n  }\n}\nclass Task {\n  var id: int\n  var contentPath: string\n  var stylePath: string\n  var outputPath: string\n  var userId: int\n  var submissionTime: int  \n  \n  constructor(id: int, content: string, style: string, user: int)\n    requires id >= 0\n    requires user >= 0\n    ensures this.id == id\n    ensures this.contentPath == content\n    ensures this.stylePath == style\n    ensures this.userId == user\n    ensures this.outputPath == \"\"\n  {\n    this.id := id;\n    this.contentPath := content;\n    this.stylePath := style;\n    this.outputPath := \"\";\n    this.userId := user;\n    this.submissionTime := 0;  \n  }\n}\nmethod HandleUploadFile(\n  request: map<string, int>,  \n  contentFile: File?,\n  styleFile: File?\n) returns (task: Task)\n  requires \"user_id\" in request\n  requires request[\"user_id\"] >= 0\n  requires contentFile != null && styleFile != null\n  ensures task.id >= 0\n  ensures task.userId == request[\"user_id\"]\n{\n  \n  var contentPath := GenerateUniquePath(\"content\");\n  var stylePath := GenerateUniquePath(\"style\");\n  \n  \n  SaveFile(contentFile, contentPath);\n  SaveFile(styleFile, stylePath);\n  \n  \n  var taskId := GetNextTaskId();\n  task := new Task(taskId, contentPath, stylePath, request[\"user_id\"]);\n  \n  \n  var args := BuildDispatchArgs(task);\n  DispatchTask(args);\n}\nmethod HandleOutputFile(args: map<string, int>, outputFile: File?, task: Task)\n  requires outputFile != null\n  requires \"task_id\" in args\n  requires args[\"task_id\"] >= 0\n  modifies task\n{\n  \n  var outputPath := GenerateUniquePath(\"output\");\n  \n  \n  SaveFile(outputFile, outputPath);\n  \n  \n  task.outputPath := outputPath;\n}\nmethod GenerateUniquePath(prefix: string) returns (path: string)\n  ensures path != \"\"\n{\n  \n  path := prefix + \"_\" + \"unique_id\";  \n}\nmethod SaveFile(file: File?, path: string)\n  requires file != null\n  requires path != \"\"\n{\n  \n}\nmethod GetNextTaskId() returns (id: int)\n  ensures id >= 0\n{\n  \n  id := 0;  \n}\nmethod BuildDispatchArgs(task: Task?) returns (args: map<string, int>)\n  requires task != null\n  ensures \"task_id\" in args\n  ensures args[\"task_id\"] == task.id\n{\n  args := map[\"task_id\" := task.id];\n}\nmethod DispatchTask(args: map<string, int>)\n  requires \"task_id\" in args\n{\n  \n}\nmethod GetTask(taskId: int) returns (task: Task?)\n  requires taskId >= 0\n{\n  \n  task := null;  \n}", "name": "py2dfy_494", "id": 494}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class MPGRecord {\n    var id: int\n    var horsepower: real\n    var weight: real\n    \n    constructor(hp: real, w: real)\n    {\n        horsepower := hp;\n        weight := w;\n        id := 0;  \n    }\n    \n    predicate Valid()\n    {\n        horsepower >= 0.0 &&\n        weight > 0.0\n    }\n    \n    method UpdateHorsepower(newHp: real)\n    {\n        horsepower := newHp;\n        }\n    }\n    \n    method UpdateWeight(newWeight: real)\n    {\n        weight := newWeight;\n        }\n    }\n}\nclass MPGDatabase {\n    var records: seq<MPGRecord>\n    ghost var Contents: set<MPGRecord>\n    constructor()\n    {\n        records := [];\n        Contents := {};\n    }\n    \n    method AddRecord(hp: real, w: real) returns (newRecord: MPGRecord)\n    {\n        newRecord := new MPGRecord(hp, w);\n        records := records + [newRecord];\n        Contents := Contents + {newRecord};\n    }\n}", "output": "class MPGRecord {\n    var id: int\n    var horsepower: real\n    var weight: real\n    \n    constructor(hp: real, w: real)\n        requires hp >= 0.0  \n        requires w > 0.0    \n        ensures horsepower == hp\n        ensures weight == w\n        ensures Valid()\n    {\n        horsepower := hp;\n        weight := w;\n        id := 0;  \n    }\n    \n    predicate Valid()\n        reads this\n    {\n        horsepower >= 0.0 &&\n        weight > 0.0\n    }\n    \n    method UpdateHorsepower(newHp: real)\n        requires newHp >= 0.0\n        requires Valid()  \n        modifies this\n        ensures horsepower == newHp\n        ensures weight == old(weight)\n        ensures Valid()\n    {\n        horsepower := newHp;\n        assert weight == old(weight);\n        assert Valid() by {\n            assert horsepower >= 0.0;\n            assert weight > 0.0;\n        }\n    }\n    \n    method UpdateWeight(newWeight: real)\n        requires newWeight > 0.0\n        requires Valid()  \n        modifies this\n        ensures weight == newWeight\n        ensures horsepower == old(horsepower)\n        ensures Valid()\n    {\n        weight := newWeight;\n        assert horsepower == old(horsepower);\n        assert Valid() by {\n            assert horsepower >= 0.0;\n            assert weight > 0.0;\n        }\n    }\n}\nclass MPGDatabase {\n    var records: seq<MPGRecord>\n    ghost var Contents: set<MPGRecord>\n    constructor()\n        ensures records == []\n        ensures Contents == {}\n    {\n        records := [];\n        Contents := {};\n    }\n    \n    method AddRecord(hp: real, w: real) returns (newRecord: MPGRecord)\n        requires hp >= 0.0\n        requires w > 0.0\n        modifies this\n        ensures newRecord.Valid()\n        ensures newRecord in Contents\n        ensures |records| == old(|records|) + 1\n        ensures forall r :: r in old(Contents) ==> r in Contents\n    {\n        newRecord := new MPGRecord(hp, w);\n        records := records + [newRecord];\n        Contents := Contents + {newRecord};\n    }\n}", "name": "py2dfy_497", "id": 497}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "trait Tr { }\nclass A extends Tr { }\nclass B extends Tr { }\nghost predicate SpecialA(a: A)\n{\n  false\n}\ntype Ap  = x : A | SpecialA(x) witness *\nfunction testSpecial(x: Tr): bool\n{\n  1/0 == 0\n}\nfunction test(x: Tr): bool\n{\n  if x is B then 1/0 == 0 else true\n}\nmethod Main() {\n  var a := new A;\n  var b := new B;\n  var s: set<Tr> := {a, b};\n  var s2: set<Ap> := {};\n  var aa := forall a': A :: a' in s ==> test(a');\n  \n  \n  \n  var si: set<int> := {2, 3, 4};\n  var ai:= forall i: nat :: i in si ==> i > 1;\n  print \"ok\";\n}", "output": "trait Tr { }\nclass A extends Tr { }\nclass B extends Tr { }\nghost predicate SpecialA(a: A)\n{\n  false\n}\ntype Ap  = x : A | SpecialA(x) witness *\nfunction testSpecial(x: Tr): bool\n  requires x is A && SpecialA(x)\n{\n  1/0 == 0\n}\nfunction test(x: Tr): bool\n  requires x is A\n{\n  if x is B then 1/0 == 0 else true\n}\nmethod Main() {\n  var a := new A;\n  var b := new B;\n  var s: set<Tr> := {a, b};\n  var s2: set<Ap> := {};\n  var aa := forall a': A :: a' in s ==> test(a');\n  \n  \n  \n  var si: set<int> := {2, 3, 4};\n  var ai:= forall i: nat :: i in si ==> i > 1;\n  assert aa;\n  print \"ok\";\n}", "name": "py2dfy_510", "id": 510}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Position = Position(head: bv8, sector: bv8, cyl: bv8)\ndatatype Partition = Partition(\n  status: bv8,      \n  start: Position,    \n  partition_type: bv8,\n  end: Position,\n  start_sect: bv32, \n  sectors: bv32     \n)\ndatatype MBR = MBR(\n  unused: seq<bv8>,           \n  disk_signature: seq<bv8>,   \n  usually_nulls: seq<bv8>,    \n  partitions: seq<Partition>,   \n  signature: seq<bv8>         \n)\nmethod ValidateMBR(mbr: MBR) returns (isValid: bool)\n{\n  \n  isValid := mbr.signature[0] == 0x55 && mbr.signature[1] == 0xAA;\n}\nmethod UnpackPosition(data: seq<bv8>, offset: nat) returns (pos: Position)\n{\n  pos := Position(data[offset], data[offset + 1], data[offset + 2]);\n}\nmethod UnpackPartition(data: seq<bv8>, offset: nat) returns (part: Partition)\n{\n  var status := data[offset];\n  var start := UnpackPosition(data, offset + 1);\n  var ptype := data[offset + 4];\n  var end := UnpackPosition(data, offset + 5);\n  \n  \n  var start_sect := \n    (data[offset + 8] as bv32) +\n    ((data[offset + 9] as bv32) * 256) +\n    ((data[offset + 10] as bv32) * 65536) +\n    ((data[offset + 11] as bv32) * 16777216);\n    \n  var sectors := \n    (data[offset + 12] as bv32) +\n    ((data[offset + 13] as bv32) * 256) +\n    ((data[offset + 14] as bv32) * 65536) +\n    ((data[offset + 15] as bv32) * 16777216);\n    \n  part := Partition(status, start, ptype, end, start_sect, sectors);\n}\nmethod UnpackMBR(data: seq<bv8>) returns (mbr: MBR)\n{\n  \n  var unused := data[..440];\n  \n  \n  var disk_sig := data[440..444];\n  \n  \n  var nulls := data[444..446];\n  \n  \n  var parts := [];\n  var i := 0;\n  while i < 4\n  {\n    var part := UnpackPartition(data, 446 + i * 16);\n    parts := parts + [part];\n    i := i + 1;\n  }\n  \n  \n  var sig := data[510..512];\n  \n  mbr := MBR(unused, disk_sig, nulls, parts, sig);\n}", "output": "datatype Position = Position(head: bv8, sector: bv8, cyl: bv8)\ndatatype Partition = Partition(\n  status: bv8,      \n  start: Position,    \n  partition_type: bv8,\n  end: Position,\n  start_sect: bv32, \n  sectors: bv32     \n)\ndatatype MBR = MBR(\n  unused: seq<bv8>,           \n  disk_signature: seq<bv8>,   \n  usually_nulls: seq<bv8>,    \n  partitions: seq<Partition>,   \n  signature: seq<bv8>         \n)\nmethod ValidateMBR(mbr: MBR) returns (isValid: bool)\n  requires |mbr.unused| == 440\n  requires |mbr.disk_signature| == 4\n  requires |mbr.usually_nulls| == 2\n  requires |mbr.partitions| == 4\n  requires |mbr.signature| == 2\n  ensures isValid ==> (mbr.signature[0] == 0x55 && mbr.signature[1] == 0xAA)\n{\n  \n  isValid := mbr.signature[0] == 0x55 && mbr.signature[1] == 0xAA;\n}\nmethod UnpackPosition(data: seq<bv8>, offset: nat) returns (pos: Position)\n  requires |data| >= offset + 3  \n  ensures pos.head == data[offset]\n  ensures pos.sector == data[offset + 1]\n  ensures pos.cyl == data[offset + 2]\n{\n  pos := Position(data[offset], data[offset + 1], data[offset + 2]);\n}\nmethod UnpackPartition(data: seq<bv8>, offset: nat) returns (part: Partition)\n  requires |data| >= offset + 16  \n  ensures part.status == data[offset]\n{\n  var status := data[offset];\n  var start := UnpackPosition(data, offset + 1);\n  var ptype := data[offset + 4];\n  var end := UnpackPosition(data, offset + 5);\n  \n  \n  var start_sect := \n    (data[offset + 8] as bv32) +\n    ((data[offset + 9] as bv32) * 256) +\n    ((data[offset + 10] as bv32) * 65536) +\n    ((data[offset + 11] as bv32) * 16777216);\n    \n  var sectors := \n    (data[offset + 12] as bv32) +\n    ((data[offset + 13] as bv32) * 256) +\n    ((data[offset + 14] as bv32) * 65536) +\n    ((data[offset + 15] as bv32) * 16777216);\n    \n  part := Partition(status, start, ptype, end, start_sect, sectors);\n}\nmethod UnpackMBR(data: seq<bv8>) returns (mbr: MBR)\n  requires |data| == 512  \n  ensures |mbr.partitions| == 4\n  ensures |mbr.signature| == 2\n  ensures mbr.signature[0] == data[510]\n  ensures mbr.signature[1] == data[511]\n{\n  \n  var unused := data[..440];\n  \n  \n  var disk_sig := data[440..444];\n  \n  \n  var nulls := data[444..446];\n  \n  \n  var parts := [];\n  var i := 0;\n  while i < 4\n    invariant 0 <= i <= 4\n    invariant |parts| == i\n  {\n    var part := UnpackPartition(data, 446 + i * 16);\n    parts := parts + [part];\n    i := i + 1;\n  }\n  \n  \n  var sig := data[510..512];\n  \n  mbr := MBR(unused, disk_sig, nulls, parts, sig);\n}", "name": "py2dfy_485", "id": 485}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type WordCountMap = map<string, nat>\npredicate IsAlphaNumeric(c: char)\n{\n  ('a' <= c <= 'z') || ('0' <= c <= '9')\n}\nmethod CleanString(input: string) returns (output: string)\n{\n  var result := \"\";\n  var i := 0;\n  \n  while i < |input|\n  {\n    var c := input[i];\n    \n    if 'A' <= c <= 'Z' {\n      c := ((c - 'A') + 'a') as char;\n    }\n    \n    if IsAlphaNumeric(c) || c == ' ' {\n      result := result + [c];\n    }\n    i := i + 1;\n  }\n  return result;\n}\nmethod SplitIntoWords(s: string) returns (words: seq<string>)\n{\n  var result: seq<string> := [];\n  var currentWord := \"\";\n  var i := 0;\n  \n  while i < |s|\n  {\n    if s[i] != ' ' {\n      \n      currentWord := currentWord + [s[i]];\n    } else if |currentWord| > 0 {\n      result := result + [currentWord];\n      currentWord := \"\";\n    }\n    i := i + 1;\n  }\n  \n  \n  if |currentWord| > 0 {\n    result := result + [currentWord];\n  }\n  \n  return result;\n}\nmethod WordCount(input: string) returns (count: WordCountMap)\n{\n  \n  var cleanedStr := CleanString(input);\n  \n  \n  var words := SplitIntoWords(cleanedStr);\n  \n  \n  count := map[];\n  \n  \n  var i := 0;\n  while i < |words|\n  {\n    var word := words[i];\n    \n    \n    \n    \n    if word in count {\n      count := count[word := count[word] + 1];\n    } else {\n      count := count[word := 1];\n    }\n    i := i + 1;\n  }\n}", "output": "type WordCountMap = map<string, nat>\npredicate IsAlphaNumeric(c: char)\n{\n  ('a' <= c <= 'z') || ('0' <= c <= '9')\n}\nmethod CleanString(input: string) returns (output: string)\n  ensures forall i :: 0 <= i < |output| ==> IsAlphaNumeric(output[i]) || output[i] == ' '\n  ensures |output| <= |input|\n{\n  var result := \"\";\n  var i := 0;\n  \n  while i < |input|\n    invariant 0 <= i <= |input|\n    invariant forall k :: 0 <= k < |result| ==> IsAlphaNumeric(result[k]) || result[k] == ' '\n    invariant |result| <= i\n  {\n    var c := input[i];\n    \n    if 'A' <= c <= 'Z' {\n      c := ((c - 'A') + 'a') as char;\n    }\n    \n    if IsAlphaNumeric(c) || c == ' ' {\n      result := result + [c];\n    }\n    i := i + 1;\n  }\n  return result;\n}\nmethod SplitIntoWords(s: string) returns (words: seq<string>)\n  requires forall i :: 0 <= i < |s| ==> IsAlphaNumeric(s[i]) || s[i] == ' '\n  ensures forall w :: w in words ==> |w| > 0  \n  ensures forall w :: w in words ==> forall c :: c in w ==> IsAlphaNumeric(c)  \n{\n  var result: seq<string> := [];\n  var currentWord := \"\";\n  var i := 0;\n  \n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall w :: w in result ==> |w| > 0\n    invariant forall w :: w in result ==> forall c :: c in w ==> IsAlphaNumeric(c)\n    invariant forall c :: c in currentWord ==> IsAlphaNumeric(c)\n  {\n    if s[i] != ' ' {\n      \n      assert IsAlphaNumeric(s[i]) || s[i] == ' ';\n      assert s[i] != ' ' ==> IsAlphaNumeric(s[i]);\n      assert IsAlphaNumeric(s[i]);\n      currentWord := currentWord + [s[i]];\n    } else if |currentWord| > 0 {\n      result := result + [currentWord];\n      currentWord := \"\";\n    }\n    i := i + 1;\n  }\n  \n  \n  if |currentWord| > 0 {\n    result := result + [currentWord];\n  }\n  \n  return result;\n}\nmethod WordCount(input: string) returns (count: WordCountMap)\n  ensures forall w :: w in count ==> count[w] > 0  \n  ensures forall w :: w in count ==> forall c :: c in w ==> IsAlphaNumeric(c)  \n{\n  \n  var cleanedStr := CleanString(input);\n  \n  \n  var words := SplitIntoWords(cleanedStr);\n  \n  \n  count := map[];\n  \n  \n  var i := 0;\n  while i < |words|\n    invariant 0 <= i <= |words|\n    invariant forall w :: w in count ==> count[w] > 0\n    invariant forall w :: w in count ==> forall c :: c in w ==> IsAlphaNumeric(c)\n  {\n    var word := words[i];\n    \n    \n    \n    assert word in words;\n    assert forall w :: w in words ==> forall c :: c in w ==> IsAlphaNumeric(c);\n    \n    if word in count {\n      count := count[word := count[word] + 1];\n    } else {\n      count := count[word := 1];\n    }\n    i := i + 1;\n  }\n}", "name": "py2dfy_482", "id": 482}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module BME680 {\n  const BME680_STATUS: int := 0x73\n  const BME680_RESET: int := 0xE0\n  const BME680_ID: int := 0xD0\n  datatype OperationMode = Sleep | ForcedMode\n  datatype Oversampling = \n    | Skipped \n    | X1 \n    | X2 \n    | X4 \n    | X8 \n    | X16\n  class BME680Sensor {\n    var calT1: int\n    var calT2: int\n    var calT3: int\n    var calRangeSwErr: int\n    var fineTemperature: real\n    method CompensateTemperature(tempADC: int) returns (temperature: real)\n    {\n      var var1: real := ((tempADC as real / 16384.0) - (calT1 as real / 1024.0)) * calT2 as real;\n      var var2: real := (((tempADC as real / 131072.0) - (calT1 as real / 8192.0)) * \n                         ((tempADC as real / 131072.0) - (calT1 as real / 8192.0))) * \n                        (calT3 as real * 16.0);\n      \n      fineTemperature := var1 + var2;\n      temperature := fineTemperature / 5120.0;\n      \n      if temperature < -40.0 {\n        temperature := -40.0;\n      }\n      if temperature > 85.0 {\n        temperature := 85.0;\n      }\n    }\n    method ReadTemperature() returns (temp: real)\n    {\n      var tempADC: int := 0;\n      temp := CompensateTemperature(tempADC);\n    }\n    method CalculateGasResistance(gasResADC: int, gasRange: int) returns (resistance: real)\n    {\n      var constArray1: array<real> := new real[16];\n      var constArray2: array<real> := new real[16];\n      \n      var i := 0;\n      while i < 16\n      {\n        constArray1[i] := 1.0;\n        constArray2[i] := 244.140625 + (i as real) * 500000.0;\n        i := i + 1;\n      }\n      \n      var var1: real := (1340.0 + 5.0 * calRangeSwErr as real) * constArray1[gasRange];\n      \n      \n      if (gasResADC as real - 512.0 + var1) == 0.0 {\n        resistance := 1.0; \n      } else {\n        resistance := var1 * constArray2[gasRange] / (gasResADC as real - 512.0 + var1);\n        \n        if resistance <= 0.0 {\n          resistance := 1.0;\n        }\n      }\n    }\n    constructor ()\n    {\n      calT1 := 0;\n      calT2 := 0;\n      calT3 := 0;\n      calRangeSwErr := 0;\n      fineTemperature := 0.0;\n    }\n    predicate Valid()\n    {\n      true\n    }\n  }\n}", "output": "module BME680 {\n  const BME680_STATUS: int := 0x73\n  const BME680_RESET: int := 0xE0\n  const BME680_ID: int := 0xD0\n  datatype OperationMode = Sleep | ForcedMode\n  datatype Oversampling = \n    | Skipped \n    | X1 \n    | X2 \n    | X4 \n    | X8 \n    | X16\n  class BME680Sensor {\n    var calT1: int\n    var calT2: int\n    var calT3: int\n    var calRangeSwErr: int\n    var fineTemperature: real\n    method CompensateTemperature(tempADC: int) returns (temperature: real)\n      requires tempADC >= 0\n      ensures temperature >= -40.0 && temperature <= 85.0\n      modifies this\n    {\n      var var1: real := ((tempADC as real / 16384.0) - (calT1 as real / 1024.0)) * calT2 as real;\n      var var2: real := (((tempADC as real / 131072.0) - (calT1 as real / 8192.0)) * \n                         ((tempADC as real / 131072.0) - (calT1 as real / 8192.0))) * \n                        (calT3 as real * 16.0);\n      \n      fineTemperature := var1 + var2;\n      temperature := fineTemperature / 5120.0;\n      \n      if temperature < -40.0 {\n        temperature := -40.0;\n      }\n      if temperature > 85.0 {\n        temperature := 85.0;\n      }\n    }\n    method ReadTemperature() returns (temp: real)\n      ensures temp >= -40.0 && temp <= 85.0\n      modifies this\n    {\n      var tempADC: int := 0;\n      temp := CompensateTemperature(tempADC);\n    }\n    method CalculateGasResistance(gasResADC: int, gasRange: int) returns (resistance: real)\n      requires 0 <= gasRange < 16\n      requires gasResADC >= 0 \n      requires gasResADC != 512\n      ensures resistance > 0.0\n    {\n      var constArray1: array<real> := new real[16];\n      var constArray2: array<real> := new real[16];\n      \n      var i := 0;\n      while i < 16\n        invariant 0 <= i <= 16\n        modifies constArray1, constArray2\n      {\n        constArray1[i] := 1.0;\n        constArray2[i] := 244.140625 + (i as real) * 500000.0;\n        i := i + 1;\n      }\n      \n      var var1: real := (1340.0 + 5.0 * calRangeSwErr as real) * constArray1[gasRange];\n      \n      \n      if (gasResADC as real - 512.0 + var1) == 0.0 {\n        resistance := 1.0; \n      } else {\n        resistance := var1 * constArray2[gasRange] / (gasResADC as real - 512.0 + var1);\n        \n        if resistance <= 0.0 {\n          resistance := 1.0;\n        }\n      }\n    }\n    constructor ()\n      ensures Valid()\n    {\n      calT1 := 0;\n      calT2 := 0;\n      calT3 := 0;\n      calRangeSwErr := 0;\n      fineTemperature := 0.0;\n    }\n    predicate Valid()\n      reads this\n    {\n      true\n    }\n  }\n}", "name": "py2dfy_488", "id": 488}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "type URL = string\ntype Attribute = (string, string)  \nclass URLParser {\n  \n  var urls: seq<URL>\n  var imgs: seq<URL>\n  \n  predicate Valid()\n  {\n    true  \n  }\n  \n  constructor()\n  {\n    urls := [];\n    imgs := [];\n  }\n  \n  method Clear()\n  {\n    urls := [];\n    imgs := [];\n  }\n  \n  method GetUrls() returns (result: seq<URL>)\n  {\n    return urls;\n  }\n  \n  method GetImgs() returns (result: seq<URL>)\n  {\n    return imgs;\n  }\n  \n  method ProcessAnchorTag(attrs: seq<Attribute>)\n  {\n    var i := 0;\n    while i < |attrs|\n    {\n      var (key, value) := attrs[i];\n      if key == \"href\" && StartsWith(value, \"http\") {\n        urls := urls + [value];\n      }\n      i := i + 1;\n    }\n  }\n  \n  method ProcessImgTag(attrs: seq<Attribute>)\n  {\n    var i := 0;\n    while i < |attrs|\n    {\n      var (key, value) := attrs[i];\n      if key == \"src\" && StartsWith(value, \"http\") {\n        imgs := imgs + [value];\n      }\n      i := i + 1;\n    }\n  }\n  \n  predicate StartsWith(s: string, prefix: string)\n  {\n    |s| >= |prefix| && s[..|prefix|] == prefix\n  }\n}", "output": "type URL = string\ntype Attribute = (string, string)  \nclass URLParser {\n  \n  var urls: seq<URL>\n  var imgs: seq<URL>\n  \n  predicate Valid()\n    reads this\n  {\n    true  \n  }\n  \n  constructor()\n    ensures Valid()\n    ensures fresh(this)\n    ensures urls == []\n    ensures imgs == []\n  {\n    urls := [];\n    imgs := [];\n  }\n  \n  method Clear()\n    modifies this\n    ensures Valid()\n    ensures urls == []\n    ensures imgs == []\n  {\n    urls := [];\n    imgs := [];\n  }\n  \n  method GetUrls() returns (result: seq<URL>)\n    requires Valid()\n    ensures result == urls\n    ensures Valid()\n  {\n    return urls;\n  }\n  \n  method GetImgs() returns (result: seq<URL>)\n    requires Valid()\n    ensures result == imgs\n    ensures Valid()\n  {\n    return imgs;\n  }\n  \n  method ProcessAnchorTag(attrs: seq<Attribute>)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures |urls| >= old(|urls|)  \n    ensures imgs == old(imgs)      \n  {\n    var i := 0;\n    while i < |attrs|\n      invariant 0 <= i <= |attrs|\n      invariant Valid()\n      invariant imgs == old(imgs)\n      invariant |urls| >= old(|urls|)  \n    {\n      var (key, value) := attrs[i];\n      if key == \"href\" && StartsWith(value, \"http\") {\n        urls := urls + [value];\n      }\n      i := i + 1;\n    }\n  }\n  \n  method ProcessImgTag(attrs: seq<Attribute>)\n    requires Valid()\n    modifies this\n    ensures Valid()\n    ensures |imgs| >= old(|imgs|)  \n    ensures urls == old(urls)      \n  {\n    var i := 0;\n    while i < |attrs|\n      invariant 0 <= i <= |attrs|\n      invariant Valid()\n      invariant urls == old(urls)\n      invariant |imgs| >= old(|imgs|)  \n    {\n      var (key, value) := attrs[i];\n      if key == \"src\" && StartsWith(value, \"http\") {\n        imgs := imgs + [value];\n      }\n      i := i + 1;\n    }\n  }\n  \n  predicate StartsWith(s: string, prefix: string)\n    requires prefix != \"\"\n  {\n    |s| >= |prefix| && s[..|prefix|] == prefix\n  }\n}", "name": "py2dfy_496", "id": 496}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class DateTime {\n  var year: int\n  var month: int \n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  predicate Valid()\n  {\n    1 <= month <= 12 &&\n    1 <= day <= 31 &&\n    0 <= hour < 24 &&\n    0 <= minute < 60 &&\n    0 <= second < 60\n  }\n  constructor()\n  {\n    year := 2024;  \n    month := 1;\n    day := 1;\n    hour := 0;\n    minute := 0;\n    second := 0;\n  }\n}\nclass User {\n  var id: int\n  var username: string\n  predicate Valid()\n  {\n    id > 0\n  }\n  constructor(userId: int, name: string)\n  {\n    id := userId;\n    username := name;\n  }\n}\nclass Order {\n  var id: int\n  var cliente: User?  \n  var createdAt: DateTime\n  var updatedAt: DateTime\n  predicate Valid()\n  {\n    id > 0 &&\n    (cliente != null ==> cliente.Valid()) &&\n    createdAt.Valid() &&\n    updatedAt.Valid()\n  }\n  constructor(orderId: int)\n  {\n    id := orderId;\n    cliente := null;\n    createdAt := new DateTime();\n    updatedAt := new DateTime();\n  }\n  \n  method ToString() returns (s: string)\n  {\n    s := \"Pedido: #\" + Itos(id);\n  }\n  \n  method SetCliente(user: User?)\n  {\n    cliente := user;\n  }\n}\nfunction Itos(i: int): string", "output": "class DateTime {\n  var year: int\n  var month: int \n  var day: int\n  var hour: int\n  var minute: int\n  var second: int\n  predicate Valid()\n    reads this\n  {\n    1 <= month <= 12 &&\n    1 <= day <= 31 &&\n    0 <= hour < 24 &&\n    0 <= minute < 60 &&\n    0 <= second < 60\n  }\n  constructor()\n    ensures Valid() \n  {\n    year := 2024;  \n    month := 1;\n    day := 1;\n    hour := 0;\n    minute := 0;\n    second := 0;\n  }\n}\nclass User {\n  var id: int\n  var username: string\n  predicate Valid()\n    reads this\n  {\n    id > 0\n  }\n  constructor(userId: int, name: string)\n    requires userId > 0\n    ensures Valid()\n    ensures id == userId\n    ensures username == name\n  {\n    id := userId;\n    username := name;\n  }\n}\nclass Order {\n  var id: int\n  var cliente: User?  \n  var createdAt: DateTime\n  var updatedAt: DateTime\n  predicate Valid()\n    reads this, cliente, createdAt, updatedAt\n  {\n    id > 0 &&\n    (cliente != null ==> cliente.Valid()) &&\n    createdAt.Valid() &&\n    updatedAt.Valid()\n  }\n  constructor(orderId: int)\n    requires orderId > 0\n    ensures Valid()\n    ensures id == orderId\n    ensures cliente == null  \n    ensures fresh(createdAt)\n    ensures fresh(updatedAt)\n  {\n    id := orderId;\n    cliente := null;\n    createdAt := new DateTime();\n    updatedAt := new DateTime();\n  }\n  \n  method ToString() returns (s: string)\n    requires Valid()\n    ensures s == \"Pedido: #\" + Itos(id)\n  {\n    s := \"Pedido: #\" + Itos(id);\n  }\n  \n  method SetCliente(user: User?)\n    requires Valid()\n    requires user != null ==> user.Valid()\n    modifies this\n    ensures Valid()\n    ensures cliente == user\n    ensures createdAt == old(createdAt)\n    ensures updatedAt == old(updatedAt)\n    ensures id == old(id)\n  {\n    cliente := user;\n  }\n}\nfunction Itos(i: int): string", "name": "py2dfy_507", "id": 507}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method CountNonSpaces(s: string) returns (count: nat)\n{\n  count := 0;        \n  var spaces := 0;   \n  \n  \n  var i := 0;\n  while i < |s|\n  {\n    if s[i] == ' ' {\n      spaces := spaces + 1;\n    }\n    i := i + 1;\n  }\n  \n  \n  count := |s| - spaces;\n}\nfunction CountSpacesUpTo(s: string, upTo: int): nat\n{\n  if upTo == 0 then 0\n  else (if s[upTo-1] == ' ' then 1 else 0) + CountSpacesUpTo(s, upTo-1)\n}\nfunction CountSpaces(s: string): nat\n{\n  CountSpacesUpTo(s, |s|)\n}", "output": "method CountNonSpaces(s: string) returns (count: nat)\n  ensures count == |s| - CountSpaces(s)  \n{\n  count := 0;        \n  var spaces := 0;   \n  \n  \n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant spaces == CountSpacesUpTo(s, i)\n    invariant spaces <= i\n  {\n    if s[i] == ' ' {\n      spaces := spaces + 1;\n    }\n    i := i + 1;\n  }\n  \n  \n  assert spaces <= |s|;\n  count := |s| - spaces;\n}\nfunction CountSpacesUpTo(s: string, upTo: int): nat\n  requires 0 <= upTo <= |s|\n  ensures CountSpacesUpTo(s, upTo) <= upTo\n{\n  if upTo == 0 then 0\n  else (if s[upTo-1] == ' ' then 1 else 0) + CountSpacesUpTo(s, upTo-1)\n}\nfunction CountSpaces(s: string): nat\n  ensures CountSpaces(s) <= |s|\n{\n  CountSpacesUpTo(s, |s|)\n}", "name": "py2dfy_499", "id": 499}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype BleuStats = BleuStats(\n  correct: seq<int>,  \n  total: seq<int>,    \n  sysLen: int,        \n  refLen: int         \n)\ndatatype BleuResult = BleuResult(\n  score: real,        \n  precisions: seq<real>, \n  bp: real            \n)\nfunction MyLog(x: real): real \n{\n  if x == 0.0 then -9999999999.0 else -1.0 \n}\nfunction MyExp(x: real): real {\n  1.0 \n}\nmethod ComputeBleu(stats: BleuStats, effectiveOrder: int) returns (result: BleuResult)\n{\n  \n  var precisions := new real[|stats.correct|];\n  var i := 0;\n  while i < |stats.correct|\n  {\n    if stats.total[i] == 0 {\n      precisions[i] := 0.0;\n    } else {\n      precisions[i] := 100.0 * (stats.correct[i] as real) / (stats.total[i] as real);\n    }\n    i := i + 1;\n  }\n  \n  var bp: real;\n  if stats.sysLen < stats.refLen && stats.sysLen > 0 {\n    bp := MyExp(1.0 - (stats.refLen as real) / (stats.sysLen as real));\n  } else {\n    bp := 1.0;\n  }\n  \n  var logSum := 0.0;\n  i := 0;\n  while i < effectiveOrder\n  {\n    logSum := logSum + MyLog(precisions[i] / 100.0);\n    i := i + 1;\n  }\n  var score := bp * MyExp(logSum / (effectiveOrder as real));\n  \n  result := BleuResult(score, precisions[..], bp);\n}\nmethod ExtractNgrams(tokens: seq<string>, minOrder: int, maxOrder: int) returns (counts: map<string, int>)\n{\n  counts := map[];\n  \n  var order := minOrder;\n  while order <= maxOrder\n  {\n    var i := 0;\n    while i <= |tokens| - order\n    {\n      \n      var ngram := \"\";\n      var j := 0;\n      while j < order\n      {\n        if j > 0 { ngram := ngram + \" \"; }\n        ngram := ngram + tokens[i+j];\n        j := j + 1;\n      }\n      \n      counts := counts[ngram := if ngram in counts then counts[ngram] + 1 else 1];\n      i := i + 1;\n    }\n    order := order + 1;\n  }\n}", "output": "datatype BleuStats = BleuStats(\n  correct: seq<int>,  \n  total: seq<int>,    \n  sysLen: int,        \n  refLen: int         \n)\ndatatype BleuResult = BleuResult(\n  score: real,        \n  precisions: seq<real>, \n  bp: real            \n)\nfunction MyLog(x: real): real \n  requires x >= 0.0\n{\n  if x == 0.0 then -9999999999.0 else -1.0 \n}\nfunction MyExp(x: real): real {\n  1.0 \n}\nmethod ComputeBleu(stats: BleuStats, effectiveOrder: int) returns (result: BleuResult)\n  requires |stats.correct| == |stats.total|\n  requires 1 <= effectiveOrder <= |stats.correct|\n  requires forall i :: 0 <= i < |stats.correct| ==> stats.total[i] >= stats.correct[i] >= 0\n  requires stats.refLen >= 0 && stats.sysLen >= 0\n  ensures 0.0 <= result.score <= 1.0\n{\n  \n  var precisions := new real[|stats.correct|];\n  var i := 0;\n  while i < |stats.correct|\n    invariant 0 <= i <= |stats.correct|\n    invariant precisions.Length == |stats.correct|\n    invariant forall j :: 0 <= j < i ==> 0.0 <= precisions[j] <= 100.0\n  {\n    if stats.total[i] == 0 {\n      precisions[i] := 0.0;\n    } else {\n      precisions[i] := 100.0 * (stats.correct[i] as real) / (stats.total[i] as real);\n    }\n    i := i + 1;\n  }\n  \n  var bp: real;\n  if stats.sysLen < stats.refLen && stats.sysLen > 0 {\n    bp := MyExp(1.0 - (stats.refLen as real) / (stats.sysLen as real));\n  } else {\n    bp := 1.0;\n  }\n  \n  var logSum := 0.0;\n  i := 0;\n  while i < effectiveOrder\n    invariant 0 <= i <= effectiveOrder\n    invariant -9999999999.0 * (i as real) <= logSum <= 0.0\n  {\n    logSum := logSum + MyLog(precisions[i] / 100.0);\n    i := i + 1;\n  }\n  var score := bp * MyExp(logSum / (effectiveOrder as real));\n  \n  result := BleuResult(score, precisions[..], bp);\n}\nmethod ExtractNgrams(tokens: seq<string>, minOrder: int, maxOrder: int) returns (counts: map<string, int>)\n  requires 1 <= minOrder <= maxOrder\n  requires |tokens| >= maxOrder  \n  ensures forall ngram :: ngram in counts ==> counts[ngram] > 0\n{\n  counts := map[];\n  \n  var order := minOrder;\n  while order <= maxOrder\n    invariant minOrder <= order <= maxOrder + 1\n    invariant forall ngram :: ngram in counts ==> counts[ngram] > 0\n  {\n    var i := 0;\n    while i <= |tokens| - order\n      invariant 0 <= i <= |tokens| - order + 1\n      invariant forall ngram :: ngram in counts ==> counts[ngram] > 0\n    {\n      \n      var ngram := \"\";\n      var j := 0;\n      while j < order\n        invariant 0 <= j <= order\n      {\n        if j > 0 { ngram := ngram + \" \"; }\n        ngram := ngram + tokens[i+j];\n        j := j + 1;\n      }\n      \n      counts := counts[ngram := if ngram in counts then counts[ngram] + 1 else 1];\n      i := i + 1;\n    }\n    order := order + 1;\n  }\n}", "name": "py2dfy_483", "id": 483}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class TVRemote {\n  var tvStatus: string\n  var volume: int\n  var channels: seq<string>\n  var currentChannel: string\n  predicate Valid()\n  {\n    0 <= volume <= 15 &&\n    |channels| > 0 &&\n    currentChannel in channels\n  }\n  constructor()\n  {\n    tvStatus := \"Off\";\n    volume := 0;\n    channels := [\"TRT\"];\n    currentChannel := \"TRT\";\n  }\n  method TurnOn()\n  {\n    tvStatus := \"On\";\n  }\n  method TurnOff()\n  {\n    tvStatus := \"Off\";\n  }\n  method AddChannel(newChannel: string)\n  {\n    channels := channels + [newChannel];\n  }\n  method AdjustVolume(increase: bool)\n         then volume == old(volume) + 1 \n         else if !increase && old(volume) > 0 \n         then volume == old(volume) - 1 \n         else volume == old(volume)\n  {\n    if increase && volume < 15 {\n      volume := volume + 1;\n    } else if !increase && volume > 0 {\n      volume := volume - 1;\n    }\n  }\n  method SwitchToRandomChannel()\n  {\n    var idx := 0;\n    while idx < |channels|\n    {\n      idx := idx + 1;\n    }\n    currentChannel := channels[0];\n  }\n  method GetTVInfo() returns (info: string)\n  {\n    info := \"TV Status: \" + tvStatus + \n            \"\\nVolume: \" + Stringify(volume) + \n            \"\\nCurrent Channel: \" + currentChannel;\n  }\n  \n  function Stringify(n: int): string\n  {\n    if n < 10 then \n      [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"][n]\n    else \n      Stringify(n / 10) + Stringify(n % 10)\n  }\n}", "output": "class TVRemote {\n  var tvStatus: string\n  var volume: int\n  var channels: seq<string>\n  var currentChannel: string\n  predicate Valid()\n  reads this\n  {\n    0 <= volume <= 15 &&\n    |channels| > 0 &&\n    currentChannel in channels\n  }\n  constructor()\n  ensures Valid()\n  ensures tvStatus == \"Off\"\n  ensures volume == 0\n  ensures channels == [\"TRT\"]\n  ensures currentChannel == \"TRT\"\n  {\n    tvStatus := \"Off\";\n    volume := 0;\n    channels := [\"TRT\"];\n    currentChannel := \"TRT\";\n  }\n  method TurnOn()\n  modifies this\n  requires Valid()\n  ensures Valid()\n  ensures tvStatus == \"On\"\n  ensures volume == old(volume)\n  ensures channels == old(channels)\n  ensures currentChannel == old(currentChannel)\n  {\n    tvStatus := \"On\";\n  }\n  method TurnOff()\n  modifies this\n  requires Valid()\n  ensures Valid()\n  ensures tvStatus == \"Off\"\n  ensures volume == old(volume)\n  ensures channels == old(channels)\n  ensures currentChannel == old(currentChannel)\n  {\n    tvStatus := \"Off\";\n  }\n  method AddChannel(newChannel: string)\n  modifies this\n  requires Valid()\n  requires newChannel !in channels\n  ensures Valid()\n  ensures channels == old(channels) + [newChannel]\n  ensures tvStatus == old(tvStatus)\n  ensures volume == old(volume)\n  ensures currentChannel == old(currentChannel)\n  {\n    channels := channels + [newChannel];\n  }\n  method AdjustVolume(increase: bool)\n  modifies this\n  requires Valid()\n  ensures Valid()\n  ensures if increase && old(volume) < 15 \n         then volume == old(volume) + 1 \n         else if !increase && old(volume) > 0 \n         then volume == old(volume) - 1 \n         else volume == old(volume)\n  ensures channels == old(channels)\n  ensures currentChannel == old(currentChannel)\n  ensures tvStatus == old(tvStatus)\n  {\n    if increase && volume < 15 {\n      volume := volume + 1;\n    } else if !increase && volume > 0 {\n      volume := volume - 1;\n    }\n  }\n  method SwitchToRandomChannel()\n  modifies this\n  requires Valid()\n  ensures Valid()\n  ensures currentChannel in channels\n  ensures volume == old(volume)\n  ensures channels == old(channels)\n  ensures tvStatus == old(tvStatus)\n  {\n    var idx := 0;\n    while idx < |channels|\n      invariant 0 <= idx <= |channels|\n    {\n      idx := idx + 1;\n    }\n    currentChannel := channels[0];\n  }\n  method GetTVInfo() returns (info: string)\n  requires Valid()\n  ensures Valid()\n  ensures info != \"\"\n  {\n    info := \"TV Status: \" + tvStatus + \n            \"\\nVolume: \" + Stringify(volume) + \n            \"\\nCurrent Channel: \" + currentChannel;\n  }\n  \n  function Stringify(n: int): string\n  requires n >= 0\n  decreases n\n  {\n    if n < 10 then \n      [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"][n]\n    else \n      Stringify(n / 10) + Stringify(n % 10)\n  }\n}", "name": "py2dfy_509", "id": 509}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "module CommandTesting {\n    \n    datatype CommandResult = Success | Failure\n    \n    datatype Path = ValidPath(s: string) | InvalidPath(s: string)\n    \n    \n    predicate Contains(s: string, c: char)\n    {\n      exists i :: 0 <= i < |s| && s[i] == c\n    }\n    \n    lemma ContainsExclamation()\n    {\n    }\n    \n    method ImportJson() returns (result: CommandResult)\n    {\n        return Success;\n    }\n    \n    method ImportCsvz() returns (result: CommandResult)\n    {\n        return Success;\n    }\n    \n    method CheckPath(path: string) returns (result: Path)\n    {\n        if Contains(path, '!') {\n            return InvalidPath(path);\n        }\n        return ValidPath(path);\n    }\n    \n    method TestImportJson() returns (success: bool)\n    {\n        var result := ImportJson();\n        success := result == Success;\n        return success;\n    }\n    \n    method TestImportCsvz() returns (success: bool)\n    {\n        var result := ImportCsvz();\n        success := result == Success;\n        return success;\n    }\n    \n    method TestCheckPath() returns (success: bool)\n    {\n        ContainsExclamation();  \n        var result := CheckPath(\"!invalid!\");\n        success := result.InvalidPath?;\n        return success;\n    }\n    \n    method RunAllTests() returns (allPassed: bool)\n    {\n        var test1 := TestImportJson();\n        var test2 := TestImportCsvz();\n        var test3 := TestCheckPath();\n        \n        allPassed := test1 && test2 && test3;\n        return allPassed;\n    }\n}", "output": "module CommandTesting {\n    \n    datatype CommandResult = Success | Failure\n    \n    datatype Path = ValidPath(s: string) | InvalidPath(s: string)\n    \n    \n    predicate Contains(s: string, c: char)\n    {\n      exists i :: 0 <= i < |s| && s[i] == c\n    }\n    \n    lemma ContainsExclamation()\n        ensures Contains(\"!invalid!\", '!')\n    {\n        assert \"!invalid!\"[0] == '!';\n        assert 0 < |\"!invalid!\"|;\n    }\n    \n    method ImportJson() returns (result: CommandResult)\n        ensures result == Success  \n    {\n        return Success;\n    }\n    \n    method ImportCsvz() returns (result: CommandResult)\n        ensures result == Success  \n    {\n        return Success;\n    }\n    \n    method CheckPath(path: string) returns (result: Path)\n        ensures Contains(path, '!') ==> result.InvalidPath?  \n        ensures !Contains(path, '!') ==> result.ValidPath?   \n    {\n        if Contains(path, '!') {\n            return InvalidPath(path);\n        }\n        return ValidPath(path);\n    }\n    \n    method TestImportJson() returns (success: bool)\n        ensures success  \n    {\n        var result := ImportJson();\n        success := result == Success;\n        return success;\n    }\n    \n    method TestImportCsvz() returns (success: bool)\n        ensures success  \n    {\n        var result := ImportCsvz();\n        success := result == Success;\n        return success;\n    }\n    \n    method TestCheckPath() returns (success: bool)\n        ensures success  \n    {\n        ContainsExclamation();  \n        var result := CheckPath(\"!invalid!\");\n        success := result.InvalidPath?;\n        assert Contains(\"!invalid!\", '!');  \n        assert result.InvalidPath?;         \n        assert success;                     \n        return success;\n    }\n    \n    method RunAllTests() returns (allPassed: bool)\n        ensures allPassed  \n    {\n        var test1 := TestImportJson();\n        var test2 := TestImportCsvz();\n        var test3 := TestCheckPath();\n        \n        allPassed := test1 && test2 && test3;\n        return allPassed;\n    }\n}", "name": "py2dfy_508", "id": 508}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "class Face {\n  var x: int\n  var y: int \n  var width: int\n  var height: int\n  constructor(x': int, y': int, w: int, h: int)\n  {\n    x := x';\n    y := y';\n    width := w;\n    height := h;\n  }\n  function Area(): int\n  {\n    width * height\n  }\n}\nmethod DetectFaces(image: array2<int>) returns (faces: seq<Face>)\n{\n  var detectedFaces: seq<Face> := [];\n  var i := 0;\n  while i < image.Length0\n  {\n    var j := 0;\n    while j < image.Length1\n    {\n      if IsFace(image, i, j)\n      {\n        var face := new Face(i, j, 10, 10);  \n        detectedFaces := detectedFaces + [face];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  faces := detectedFaces;\n}\nmethod GetLargestFace(faces: seq<Face>) returns (largestFace: Face?)\n{\n  if |faces| == 0 {\n    largestFace := null;\n    return;\n  }\n  var maxArea := faces[0].Area();\n  var maxFace: Face := faces[0];\n  var i := 1;\n  while i < |faces|\n  {\n    if faces[i].Area() > maxArea {\n      maxArea := faces[i].Area();\n      maxFace := faces[i];\n    }\n    i := i + 1;\n  }\n  largestFace := maxFace;\n}\npredicate IsFace(image: array2<int>, x: int, y: int)\n{\n  image[x, y] > 128  \n}", "output": "class Face {\n  var x: int\n  var y: int \n  var width: int\n  var height: int\n  constructor(x': int, y': int, w: int, h: int)\n    requires w > 0 && h > 0\n    ensures x == x' && y == y' && width == w && height == h\n  {\n    x := x';\n    y := y';\n    width := w;\n    height := h;\n  }\n  function Area(): int\n    reads this\n    requires width > 0 && height > 0  \n    ensures Area() > 0\n    ensures Area() == width * height\n  {\n    width * height\n  }\n}\nmethod DetectFaces(image: array2<int>) returns (faces: seq<Face>)\n  requires image.Length0 > 0 && image.Length1 > 0\n  ensures |faces| >= 0\n  ensures forall f :: f in faces ==> f.width > 0 && f.height > 0\n{\n  var detectedFaces: seq<Face> := [];\n  var i := 0;\n  while i < image.Length0\n    invariant 0 <= i <= image.Length0\n    invariant |detectedFaces| >= 0\n    invariant forall f :: f in detectedFaces ==> f.width > 0 && f.height > 0\n  {\n    var j := 0;\n    while j < image.Length1\n      invariant 0 <= j <= image.Length1\n      invariant |detectedFaces| >= 0\n      invariant forall f :: f in detectedFaces ==> f.width > 0 && f.height > 0\n    {\n      if IsFace(image, i, j)\n      {\n        var face := new Face(i, j, 10, 10);  \n        detectedFaces := detectedFaces + [face];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  faces := detectedFaces;\n}\nmethod GetLargestFace(faces: seq<Face>) returns (largestFace: Face?)\n  requires |faces| >= 0\n  requires forall f :: f in faces ==> f.width > 0 && f.height > 0\n  ensures largestFace == null ==> |faces| == 0\n  ensures largestFace != null ==> largestFace in faces\n  ensures largestFace != null ==> forall f :: f in faces ==> largestFace.Area() >= f.Area()\n{\n  if |faces| == 0 {\n    largestFace := null;\n    return;\n  }\n  var maxArea := faces[0].Area();\n  var maxFace: Face := faces[0];\n  var i := 1;\n  while i < |faces|\n    invariant 1 <= i <= |faces|\n    invariant maxFace in faces[..i]\n    invariant maxFace.Area() == maxArea\n    invariant forall j :: 0 <= j < i ==> maxArea >= faces[j].Area()\n  {\n    if faces[i].Area() > maxArea {\n      maxArea := faces[i].Area();\n      maxFace := faces[i];\n    }\n    i := i + 1;\n  }\n  largestFace := maxFace;\n}\npredicate IsFace(image: array2<int>, x: int, y: int)\n  requires 0 <= x < image.Length0 && 0 <= y < image.Length1\n  reads image\n{\n  image[x, y] > 128  \n}", "name": "py2dfy_501", "id": 501}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Matrix = Matrix(rows: int, cols: int, values: array2<real>)\ndatatype TokenizerState = TokenizerState(wordIndex: map<char, int>, indexWord: map<int, char>)\nclass TextProcessor {\n    const INPUT_CHARS: int := 6\n    const NUM_CHARACTERS: int := 34\n    \n    var tokenizer: TokenizerState\n    constructor()\n            0 <= i < NUM_CHARACTERS\n            0 <= tokenizer.wordIndex[c] < NUM_CHARACTERS\n            tokenizer.indexWord[i] in tokenizer.wordIndex.Keys &&\n            tokenizer.wordIndex[tokenizer.indexWord[i]] == i\n            tokenizer.indexWord[tokenizer.wordIndex[c]] == c\n    {\n        var chars := ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', ' '];\n        var wordIndex: map<char,int> := map[];\n        var indexWord: map<int,char> := map[];\n        var i := 0;\n        while i < |chars|\n                indexWord[k] in wordIndex.Keys && wordIndex[indexWord[k]] == k\n                indexWord[wordIndex[c]] == c\n        {\n            wordIndex := wordIndex[chars[i] := i];\n            indexWord := indexWord[i := chars[i]];\n            i := i + 1;\n        }\n        tokenizer := TokenizerState(wordIndex, indexWord);\n    }\n    method CleanText(text: string) returns (cleaned: string)\n            (cleaned[i] in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \" )\n    {\n        var result := \"\";\n        var i := 0;\n        \n        while i < |text|\n                (result[k] in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \" )\n        {\n            var c := text[i];\n            if c in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \"\n            {\n                result := result + [c];\n            }\n            i := i + 1;\n        }\n        return result;\n    }\n    method TextsToMatrix(text: string) returns (matrix: Matrix)\n            text[i] in tokenizer.wordIndex.Keys\n            0 <= tokenizer.wordIndex[c] < NUM_CHARACTERS\n    {\n        var values := new real[|text|, NUM_CHARACTERS];\n        \n        var i := 0;\n        while i < |text|\n        {\n            var j := 0;\n            while j < NUM_CHARACTERS\n            {\n                values[i,j] := 0.0;\n                j := j + 1;\n            }\n            \n            var charIndex := tokenizer.wordIndex[text[i]];\n            values[i,charIndex] := 1.0;\n            i := i + 1;\n        }\n        \n        return Matrix(|text|, NUM_CHARACTERS, values);\n    }\n    method PredictNextChar(input: string) returns (nextChar: char)\n            input[i] in tokenizer.wordIndex.Keys\n    {\n        return tokenizer.indexWord[0];\n    }\n    method BuildPhrase(initial: string, length: int) returns (result: string)\n            initial[i] in tokenizer.wordIndex.Keys\n            result[k] in tokenizer.wordIndex.Keys\n    {\n        result := initial;\n        \n        var i := 0;\n        while i < length\n                result[k] in tokenizer.wordIndex.Keys\n        {\n            var inputWindow := result[|result|-INPUT_CHARS..];\n            var nextChar := PredictNextChar(inputWindow);\n            result := result + [nextChar];\n            i := i + 1;\n        }\n        \n        return result;\n    }\n}", "output": "datatype Matrix = Matrix(rows: int, cols: int, values: array2<real>)\ndatatype TokenizerState = TokenizerState(wordIndex: map<char, int>, indexWord: map<int, char>)\nclass TextProcessor {\n    const INPUT_CHARS: int := 6\n    const NUM_CHARACTERS: int := 34\n    \n    var tokenizer: TokenizerState\n    constructor()\n        ensures tokenizer.wordIndex.Keys == tokenizer.indexWord.Values\n        ensures 0 in tokenizer.indexWord\n        ensures forall i :: i in tokenizer.indexWord ==> \n            0 <= i < NUM_CHARACTERS\n        ensures forall c :: c in tokenizer.wordIndex ==>\n            0 <= tokenizer.wordIndex[c] < NUM_CHARACTERS\n        ensures tokenizer.indexWord[0] in tokenizer.wordIndex.Keys\n        ensures forall i :: i in tokenizer.indexWord ==>\n            tokenizer.indexWord[i] in tokenizer.wordIndex.Keys &&\n            tokenizer.wordIndex[tokenizer.indexWord[i]] == i\n        ensures forall c :: c in tokenizer.wordIndex ==>\n            tokenizer.indexWord[tokenizer.wordIndex[c]] == c\n    {\n        var chars := ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', ' '];\n        var wordIndex: map<char,int> := map[];\n        var indexWord: map<int,char> := map[];\n        var i := 0;\n        while i < |chars|\n            invariant 0 <= i <= |chars|\n            invariant forall k :: 0 <= k < i ==> chars[k] in wordIndex\n            invariant forall k :: 0 <= k < i ==> k in indexWord\n            invariant forall k :: 0 <= k < i ==> wordIndex[chars[k]] == k\n            invariant forall k :: 0 <= k < i ==> indexWord[k] == chars[k]\n            invariant forall k :: k in wordIndex ==> 0 <= wordIndex[k] < i\n            invariant forall k :: k in indexWord ==> 0 <= k < i\n            invariant wordIndex.Keys == set k | 0 <= k < i :: chars[k]\n            invariant indexWord.Values == set k | 0 <= k < i :: chars[k]\n            invariant forall k :: k in indexWord ==> \n                indexWord[k] in wordIndex.Keys && wordIndex[indexWord[k]] == k\n            invariant forall c :: c in wordIndex ==> \n                indexWord[wordIndex[c]] == c\n        {\n            wordIndex := wordIndex[chars[i] := i];\n            indexWord := indexWord[i := chars[i]];\n            i := i + 1;\n        }\n        tokenizer := TokenizerState(wordIndex, indexWord);\n    }\n    method CleanText(text: string) returns (cleaned: string)\n        ensures |cleaned| <= |text|\n        ensures forall i :: 0 <= i < |cleaned| ==> \n            (cleaned[i] in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \" )\n    {\n        var result := \"\";\n        var i := 0;\n        \n        while i < |text|\n            invariant 0 <= i <= |text|\n            invariant |result| <= i\n            invariant forall k :: 0 <= k < |result| ==>\n                (result[k] in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \" )\n        {\n            var c := text[i];\n            if c in \"АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя \"\n            {\n                result := result + [c];\n            }\n            i := i + 1;\n        }\n        return result;\n    }\n    method TextsToMatrix(text: string) returns (matrix: Matrix)\n        requires |text| > 0\n        requires forall i :: 0 <= i < |text| ==> \n            text[i] in tokenizer.wordIndex.Keys\n        requires forall c :: c in tokenizer.wordIndex ==>\n            0 <= tokenizer.wordIndex[c] < NUM_CHARACTERS\n        ensures matrix.rows == |text|\n        ensures matrix.cols == NUM_CHARACTERS\n        ensures fresh(matrix.values)\n    {\n        var values := new real[|text|, NUM_CHARACTERS];\n        \n        var i := 0;\n        while i < |text|\n            invariant 0 <= i <= |text|\n            invariant fresh(values)\n        {\n            var j := 0;\n            while j < NUM_CHARACTERS\n                invariant 0 <= j <= NUM_CHARACTERS\n                invariant fresh(values)\n            {\n                values[i,j] := 0.0;\n                j := j + 1;\n            }\n            \n            var charIndex := tokenizer.wordIndex[text[i]];\n            values[i,charIndex] := 1.0;\n            i := i + 1;\n        }\n        \n        return Matrix(|text|, NUM_CHARACTERS, values);\n    }\n    method PredictNextChar(input: string) returns (nextChar: char)\n        requires |input| == INPUT_CHARS\n        requires forall i :: 0 <= i < |input| ==> \n            input[i] in tokenizer.wordIndex.Keys\n        requires 0 in tokenizer.indexWord\n        requires tokenizer.indexWord[0] in tokenizer.wordIndex.Keys\n        ensures nextChar in tokenizer.wordIndex.Keys\n    {\n        return tokenizer.indexWord[0];\n    }\n    method BuildPhrase(initial: string, length: int) returns (result: string)\n        requires |initial| >= INPUT_CHARS\n        requires length >= 0\n        requires forall i :: 0 <= i < |initial| ==> \n            initial[i] in tokenizer.wordIndex.Keys\n        requires 0 in tokenizer.indexWord\n        requires tokenizer.indexWord[0] in tokenizer.wordIndex.Keys\n        ensures |result| == |initial| + length\n        ensures result[..|initial|] == initial\n        ensures forall k :: 0 <= k < |result| ==>\n            result[k] in tokenizer.wordIndex.Keys\n    {\n        result := initial;\n        \n        var i := 0;\n        while i < length\n            invariant 0 <= i <= length\n            invariant |result| == |initial| + i\n            invariant result[..|initial|] == initial\n            invariant forall k :: 0 <= k < |result| ==>\n                result[k] in tokenizer.wordIndex.Keys\n        {\n            var inputWindow := result[|result|-INPUT_CHARS..];\n            var nextChar := PredictNextChar(inputWindow);\n            result := result + [nextChar];\n            i := i + 1;\n        }\n        \n        return result;\n    }\n}", "name": "py2dfy_484", "id": 484}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "datatype Shape = Shape(batch: nat, channels: nat, height: nat, width: nat)\nclass {:autocontracts} Tensor {\n  var data: array4<real>\n  var shape: Shape\n  \n  ghost predicate Valid()\n  {\n    data.Length0 == shape.batch &&\n    data.Length1 == shape.channels &&\n    data.Length2 == shape.height &&\n    data.Length3 == shape.width\n  }\n  constructor(s: Shape)\n  {\n    shape := s;\n    data := new real[s.batch, s.channels, s.height, s.width]((i,j,k,l) => 0.0);\n  }\n}\nclass DeConvLayer {\n  var weights: Tensor\n  var bias: array<real>\n  var activation: string\n  var batchNorm: bool\n  \n  ghost predicate Valid() reads this, weights\n  {\n    bias.Length == weights.shape.channels &&\n    (activation == \"relu\" || activation == \"tanh\" || activation == \"none\")\n  }\n  constructor(inChannels: nat, outChannels: nat, act: string, w: Tensor, b: array<real>, bn: bool)\n  {\n    weights := w;\n    bias := b;\n    activation := act;\n    batchNorm := bn;\n  }\n  method Deconv(input: Tensor) returns (output: Tensor)\n  {\n    \n    var outHeight := input.shape.height * 2;\n    var outWidth := input.shape.width * 2;\n    \n    \n    output := new Tensor(Shape(\n      input.shape.batch,\n      weights.shape.channels,\n      outHeight,\n      outWidth\n    ));\n    \n    DeconvolutionOperation(input, output);\n    \n    \n    if batchNorm {\n      BatchNormalize(output);\n    }\n    \n    AddBias(output);\n    \n    ApplyActivation(output);\n  }\n  method DeconvolutionOperation(input: Tensor, output: Tensor)\n  {\n    \n    \n    var i := 0;\n    while i < input.shape.batch\n    {\n      var c := 0;\n      while c < output.shape.channels\n      {\n        \n        c := c + 1;\n      }\n      i := i + 1;\n    }\n  }\n  method BatchNormalize(tensor: Tensor)\n  {\n    \n    \n  }\n  method AddBias(tensor: Tensor)\n  {\n    \n    var b := 0;\n    while b < tensor.shape.batch\n    {\n      var c := 0;\n      while c < tensor.shape.channels\n      {\n        var h := 0;\n        while h < tensor.shape.height\n        {\n          var w := 0;\n          while w < tensor.shape.width\n          {\n            tensor.data[b,c,h,w] := tensor.data[b,c,h,w] + bias[c];\n            w := w + 1;\n          }\n          h := h + 1;\n        }\n        c := c + 1;\n      }\n      b := b + 1;\n    }\n  }\n  method ApplyActivation(tensor: Tensor)\n  {\n    if activation == \"relu\" {\n      ApplyReLU(tensor);\n    } else if activation == \"tanh\" {\n      ApplyTanhActivation(tensor);\n    }\n  }\n  method ApplyReLU(tensor: Tensor)\n  {\n    \n    var b := 0;\n    while b < tensor.shape.batch\n    {\n      var c := 0;\n      while c < tensor.shape.channels\n      {\n        var h := 0;\n        while h < tensor.shape.height\n        {\n          var w := 0;\n          while w < tensor.shape.width\n          {\n            if tensor.data[b,c,h,w] < 0.0 {\n              tensor.data[b,c,h,w] := 0.0;\n            }\n            w := w + 1;\n          }\n          h := h + 1;\n        }\n        c := c + 1;\n      }\n      b := b + 1;\n    }\n  }\n  method ApplyTanhActivation(tensor: Tensor)\n  {\n    \n    \n  }\n}", "output": "datatype Shape = Shape(batch: nat, channels: nat, height: nat, width: nat)\nclass {:autocontracts} Tensor {\n  var data: array4<real>\n  var shape: Shape\n  \n  ghost predicate Valid()\n  {\n    data.Length0 == shape.batch &&\n    data.Length1 == shape.channels &&\n    data.Length2 == shape.height &&\n    data.Length3 == shape.width\n  }\n  constructor(s: Shape)\n    ensures shape == s\n  {\n    shape := s;\n    data := new real[s.batch, s.channels, s.height, s.width]((i,j,k,l) => 0.0);\n  }\n}\nclass DeConvLayer {\n  var weights: Tensor\n  var bias: array<real>\n  var activation: string\n  var batchNorm: bool\n  \n  ghost predicate Valid() reads this, weights\n  {\n    bias.Length == weights.shape.channels &&\n    (activation == \"relu\" || activation == \"tanh\" || activation == \"none\")\n  }\n  constructor(inChannels: nat, outChannels: nat, act: string, w: Tensor, b: array<real>, bn: bool)\n    requires b.Length == outChannels\n    requires act == \"relu\" || act == \"tanh\" || act == \"none\"\n    requires w.shape.channels == outChannels\n    ensures Valid()\n    ensures weights == w\n    ensures bias == b\n    ensures activation == act\n    ensures batchNorm == bn\n  {\n    weights := w;\n    bias := b;\n    activation := act;\n    batchNorm := bn;\n  }\n  method Deconv(input: Tensor) returns (output: Tensor)\n    requires Valid()\n    requires input.Valid()\n    ensures output.Valid()\n    ensures output.shape.channels == weights.shape.channels\n  {\n    \n    var outHeight := input.shape.height * 2;\n    var outWidth := input.shape.width * 2;\n    \n    \n    output := new Tensor(Shape(\n      input.shape.batch,\n      weights.shape.channels,\n      outHeight,\n      outWidth\n    ));\n    \n    DeconvolutionOperation(input, output);\n    \n    \n    if batchNorm {\n      BatchNormalize(output);\n    }\n    \n    AddBias(output);\n    \n    ApplyActivation(output);\n  }\n  method DeconvolutionOperation(input: Tensor, output: Tensor)\n    requires input.Valid() && output.Valid()\n    modifies output.data\n    ensures output.Valid()\n  {\n    \n    \n    var i := 0;\n    while i < input.shape.batch\n      invariant 0 <= i <= input.shape.batch\n      invariant output.Valid()\n    {\n      var c := 0;\n      while c < output.shape.channels\n      {\n        \n        c := c + 1;\n      }\n      i := i + 1;\n    }\n  }\n  method BatchNormalize(tensor: Tensor)\n    requires tensor.Valid()\n    modifies tensor.data\n    ensures tensor.Valid()\n  {\n    \n    \n  }\n  method AddBias(tensor: Tensor)\n    requires tensor.Valid()\n    requires bias.Length == tensor.shape.channels\n    modifies tensor.data\n    ensures tensor.Valid()\n  {\n    \n    var b := 0;\n    while b < tensor.shape.batch\n      invariant 0 <= b <= tensor.shape.batch\n      invariant tensor.Valid()\n    {\n      var c := 0;\n      while c < tensor.shape.channels\n      {\n        var h := 0;\n        while h < tensor.shape.height\n        {\n          var w := 0;\n          while w < tensor.shape.width\n          {\n            tensor.data[b,c,h,w] := tensor.data[b,c,h,w] + bias[c];\n            w := w + 1;\n          }\n          h := h + 1;\n        }\n        c := c + 1;\n      }\n      b := b + 1;\n    }\n  }\n  method ApplyActivation(tensor: Tensor)\n    requires tensor.Valid()\n    requires activation == \"relu\" || activation == \"tanh\" || activation == \"none\"\n    modifies tensor.data\n    ensures tensor.Valid()\n  {\n    if activation == \"relu\" {\n      ApplyReLU(tensor);\n    } else if activation == \"tanh\" {\n      ApplyTanhActivation(tensor);\n    }\n  }\n  method ApplyReLU(tensor: Tensor)\n    requires tensor.Valid()\n    modifies tensor.data\n    ensures tensor.Valid()\n  {\n    \n    var b := 0;\n    while b < tensor.shape.batch\n      invariant 0 <= b <= tensor.shape.batch\n      invariant tensor.Valid()\n    {\n      var c := 0;\n      while c < tensor.shape.channels\n      {\n        var h := 0;\n        while h < tensor.shape.height\n        {\n          var w := 0;\n          while w < tensor.shape.width\n          {\n            if tensor.data[b,c,h,w] < 0.0 {\n              tensor.data[b,c,h,w] := 0.0;\n            }\n            w := w + 1;\n          }\n          h := h + 1;\n        }\n        c := c + 1;\n      }\n      b := b + 1;\n    }\n  }\n  method ApplyTanhActivation(tensor: Tensor)\n    requires tensor.Valid()\n    modifies tensor.data\n    ensures tensor.Valid()\n  {\n    \n    \n  }\n}", "name": "py2dfy_506", "id": 506}
{"instruction": "Given a Dafny program with function signature, preconditions, postconditions, and code, but with annotations missing. Please return a complete Dafny program with the strongest possible annotation (loop invariants, assert statements, etc.) filled back in. Do not explain or output any text. If you have to explain, put all explanations in comments form. There should only be code body in your output. Please use exactly the same function signature, preconditions, and postconditions. Do not ever modify the given lines. Below is the program:\n", "system": "You are an expert in Dafny. You will be given tasks dealing with Dafny programs including precise annotations. You should only return code body in all circumstances. No text is allowed.\n", "input": "method PascalTriangle(n: nat) returns (triangle: seq<seq<int>>)\n    triangle[i][j] == if j == 0 || j == i then 1 \n                      else triangle[i-1][j-1] + triangle[i-1][j]\n{\n  triangle := [];\n  var i := 0;\n  while i < n\n      triangle[k][j] == if j == 0 || j == k then 1 \n                        else triangle[k-1][j-1] + triangle[k-1][j]\n  {\n    var row := [1];\n    if i > 0 {\n      var j := 1;\n      while j < i\n          row[k] == triangle[i-1][k-1] + triangle[i-1][k]\n      {\n        row := row + [triangle[i-1][j-1] + triangle[i-1][j]];\n        j := j + 1;\n      }\n      row := row + [1];\n    }\n    triangle := triangle + [row];\n    i := i + 1;\n  }\n}\nmethod PrintTriangle(triangle: seq<seq<int>>)\n{\n  var i := 0;\n  while i < |triangle|\n  {\n    print \"[\";\n    var j := 0;\n    while j < |triangle[i]|\n    {\n      if j > 0 { print \", \"; }\n      print triangle[i][j];\n      j := j + 1;\n    }\n    print \"]\\n\";\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  print \"----0----\\n\";\n  var triangle := PascalTriangle(0);\n  PrintTriangle(triangle);\n  print \"----1----\\n\";\n  triangle := PascalTriangle(1);\n  PrintTriangle(triangle);\n  print \"----5----\\n\";\n  triangle := PascalTriangle(5);\n  PrintTriangle(triangle);\n  print \"----10----\\n\";\n  triangle := PascalTriangle(10);\n  PrintTriangle(triangle);\n}", "output": "method PascalTriangle(n: nat) returns (triangle: seq<seq<int>>)\n  ensures |triangle| == n\n  ensures forall i :: 0 <= i < n ==> |triangle[i]| == i + 1\n  ensures forall i, j {:trigger triangle[i][j]} :: 0 <= i < n && 0 <= j <= i ==> \n    triangle[i][j] == if j == 0 || j == i then 1 \n                      else triangle[i-1][j-1] + triangle[i-1][j]\n{\n  triangle := [];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant |triangle| == i\n    invariant forall k :: 0 <= k < i ==> |triangle[k]| == k + 1\n    invariant forall k, j {:trigger triangle[k][j]} :: 0 <= k < i && 0 <= j <= k ==>\n      triangle[k][j] == if j == 0 || j == k then 1 \n                        else triangle[k-1][j-1] + triangle[k-1][j]\n  {\n    var row := [1];\n    if i > 0 {\n      var j := 1;\n      while j < i\n        invariant 1 <= j <= i\n        invariant |row| == j\n        invariant row[0] == 1\n        invariant forall k :: 1 <= k < j ==> \n          row[k] == triangle[i-1][k-1] + triangle[i-1][k]\n      {\n        row := row + [triangle[i-1][j-1] + triangle[i-1][j]];\n        j := j + 1;\n      }\n      row := row + [1];\n    }\n    triangle := triangle + [row];\n    i := i + 1;\n  }\n}\nmethod PrintTriangle(triangle: seq<seq<int>>)\n{\n  var i := 0;\n  while i < |triangle|\n  {\n    print \"[\";\n    var j := 0;\n    while j < |triangle[i]|\n    {\n      if j > 0 { print \", \"; }\n      print triangle[i][j];\n      j := j + 1;\n    }\n    print \"]\\n\";\n    i := i + 1;\n  }\n}\nmethod Main()\n{\n  print \"----0----\\n\";\n  var triangle := PascalTriangle(0);\n  PrintTriangle(triangle);\n  print \"----1----\\n\";\n  triangle := PascalTriangle(1);\n  PrintTriangle(triangle);\n  print \"----5----\\n\";\n  triangle := PascalTriangle(5);\n  PrintTriangle(triangle);\n  print \"----10----\\n\";\n  triangle := PascalTriangle(10);\n  PrintTriangle(triangle);\n}", "name": "py2dfy_204", "id": 204}

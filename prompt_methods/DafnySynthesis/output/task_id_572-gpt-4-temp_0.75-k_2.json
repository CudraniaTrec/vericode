{"id": "572", "K": 2, "temperature": 0.75, "task_id": "572", "task_description": "Write a method in Dafny to remove duplicate numbers from a given integer array.", "model": "gpt-4", "response": "```dafny\n\n// Helper function to check array equality (assumes order matters)\nfunction method arrayEquals(a: array<int>, b: array<int>): bool\n    requires a != null && b != null\n    reads a, b\n{\n    a.Length == b.Length &&\n    (forall i :: 0 <= i < a.Length ==> a[i] == b[i])\n}\n\n// Main method to remove duplicate numbers (only keep numbers that occur once)\nmethod twoUniqueNums(nums: array<int>) returns (res: array<int>)\n    requires nums != null\n    ensures res != null\n    ensures forall i :: 0 <= i < res.Length ==> \n                (exists k :: 0 <= k < nums.Length && nums[k] == res[i] &&\n                   (forall j :: 0 <= j < nums.Length && j != k ==> nums[j] != res[i]))\n    ensures res.Length == |set i | 0 <= i < nums.Length && (forall j :: 0 <= j < nums.Length && j != i ==> nums[j] != nums[i])|\n    ensures (forall i :: 0 <= i < res.Length ==> (forall j :: 0 <= j < nums.Length ==> (res[i] == nums[j] ==> (forall k :: 0 <= k < nums.Length && k != j ==> nums[k] != res[i]))))\n{\n    // First pass: Count occurrences using a map from int to int\n    var count := map[int]int[];\n\n    var i := 0;\n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant count.Keys <= set nums[j] | 0 <= j < i\n        decreases nums.Length - i\n    {\n        var v := nums[i];\n        if v in count {\n            count[v] := count[v] + 1;\n        } else {\n            count[v] := 1;\n        }\n        i := i + 1;\n    }\n\n    // Second pass: Collect numbers that occur exactly once, in original order\n    var unique := new int[nums.Length];\n    var idx := 0;\n    i := 0;\n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant 0 <= idx <= i\n        invariant (forall j :: 0 <= j < idx ==> count[unique[j]] == 1)\n        invariant (forall j :: 0 <= j < idx ==> (exists k :: 0 <= k < i && nums[k] == unique[j]))\n        invariant (forall m,n :: 0 <= m < n < idx ==> unique[m] != unique[n])\n        decreases nums.Length - i\n    {\n        var v := nums[i];\n        if count[v] == 1 {\n            // Only add if not already added (avoid duplicates in result, as input may have multiple unique values)\n            var already := false;\n            var j := 0;\n            while j < idx\n                invariant 0 <= j <= idx\n                invariant !already ==> (forall k :: 0 <= k < j ==> unique[k] != v)\n                decreases idx - j\n            {\n                if unique[j] == v {\n                    already := true;\n                }\n                j := j + 1;\n            }\n            if !already {\n                unique[idx] := v;\n                idx := idx + 1;\n            }\n        }\n        i := i + 1;\n    }\n\n    // Resize result to correct length\n    res := new int[idx];\n    i := 0;\n    while i < idx\n        invariant 0 <= i <= idx\n        decreases idx - i\n    {\n        res[i] := unique[i];\n        i := i + 1;\n    }\n}\n```\n", "dafny_code": "// Helper function to check array equality (assumes order matters)\nfunction method arrayEquals(a: array<int>, b: array<int>): bool\n    requires a != null && b != null\n    reads a, b\n{\n    a.Length == b.Length &&\n    (forall i :: 0 <= i < a.Length ==> a[i] == b[i])\n}\n\n// Main method to remove duplicate numbers (only keep numbers that occur once)\nmethod twoUniqueNums(nums: array<int>) returns (res: array<int>)\n    requires nums != null\n    ensures res != null\n    ensures forall i :: 0 <= i < res.Length ==> \n                (exists k :: 0 <= k < nums.Length && nums[k] == res[i] &&\n                   (forall j :: 0 <= j < nums.Length && j != k ==> nums[j] != res[i]))\n    ensures res.Length == |set i | 0 <= i < nums.Length && (forall j :: 0 <= j < nums.Length && j != i ==> nums[j] != nums[i])|\n    ensures (forall i :: 0 <= i < res.Length ==> (forall j :: 0 <= j < nums.Length ==> (res[i] == nums[j] ==> (forall k :: 0 <= k < nums.Length && k != j ==> nums[k] != res[i]))))\n{\n    // First pass: Count occurrences using a map from int to int\n    var count := map[int]int[];\n\n    var i := 0;\n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant count.Keys <= set nums[j] | 0 <= j < i\n        decreases nums.Length - i\n    {\n        var v := nums[i];\n        if v in count {\n            count[v] := count[v] + 1;\n        } else {\n            count[v] := 1;\n        }\n        i := i + 1;\n    }\n\n    // Second pass: Collect numbers that occur exactly once, in original order\n    var unique := new int[nums.Length];\n    var idx := 0;\n    i := 0;\n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant 0 <= idx <= i\n        invariant (forall j :: 0 <= j < idx ==> count[unique[j]] == 1)\n        invariant (forall j :: 0 <= j < idx ==> (exists k :: 0 <= k < i && nums[k] == unique[j]))\n        invariant (forall m,n :: 0 <= m < n < idx ==> unique[m] != unique[n])\n        decreases nums.Length - i\n    {\n        var v := nums[i];\n        if count[v] == 1 {\n            // Only add if not already added (avoid duplicates in result, as input may have multiple unique values)\n            var already := false;\n            var j := 0;\n            while j < idx\n                invariant 0 <= j <= idx\n                invariant !already ==> (forall k :: 0 <= k < j ==> unique[k] != v)\n                decreases idx - j\n            {\n                if unique[j] == v {\n                    already := true;\n                }\n                j := j + 1;\n            }\n            if !already {\n                unique[idx] := v;\n                idx := idx + 1;\n            }\n        }\n        i := i + 1;\n    }\n\n    // Resize result to correct length\n    res := new int[idx];\n    i := 0;\n    while i < idx\n        invariant 0 <= i <= idx\n        decreases idx - i\n    {\n        res[i] := unique[i];\n        i := i + 1;\n    }\n}", "isVerified": false, "verification_bits": {"method": 3, "ensure": 4, "requires": 2, "function": 2, "lemma": 0, "predicate": 0, "invariant": 10, "assert_count": 0}}